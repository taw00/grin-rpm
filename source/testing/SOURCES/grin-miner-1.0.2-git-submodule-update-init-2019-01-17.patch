diff -urN '--exclude=.git' grin-miner-1.0.2/.auto-release.sh grin-miner-copy/.auto-release.sh
--- grin-miner-1.0.2/.auto-release.sh	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/.auto-release.sh	1969-12-31 19:00:00.000000000 -0500
@@ -1,75 +0,0 @@
-#!/bin/bash
-
-repo_slug="mimblewimble/grin-miner"
-token="$GITHUB_TOKEN"
-
-tagname=`git describe --tags --exact-match 2>/dev/null || git symbolic-ref -q --short HEAD`
-deploy_dir="deploy/grin-miner-$tagname"
-
-echo 'make a tarball for the release binary...\n'
-
-if [[ $TRAVIS_OS_NAME == 'osx' ]]; then
-
-    # Do some custom requirements on OS X
-    mkdir -p $deploy_dir; cp grin-miner.toml $deploy_dir; cp -R target/release/plugins $deploy_dir
-    cp target/release/grin-miner $deploy_dir
-    cd deploy ; rm -f *.tgz; tar zcf "grin-miner-$tagname-$TRAVIS_JOB_ID-osx.tgz" *
-    /bin/ls -ls *.tgz  | awk '{print $6,$7,$8,$9,$10}'
-    md5 "grin-miner-$tagname-$TRAVIS_JOB_ID-osx.tgz" > "grin-miner-$tagname-$TRAVIS_JOB_ID-osx.tgz"-md5sum.txt
-    /bin/ls -ls *-md5sum.txt  | awk '{print $6,$7,$8,$9,$10}'
-    cd - > /dev/null;
-    echo "tarball generated\n"
-
-    # Only generate changelog on Linux platform, to avoid duplication
-    exit 0
-else
-    # Do some custom requirements on Linux
-    mkdir -p $deploy_dir; cp grin-miner.toml $deploy_dir; cp -R target/release/plugins $deploy_dir
-    cp target/release/deps/libocl_cuckatoo.so "$deploy_dir/plugins/ocl_cuckatoo.cuckooplugin"
-    cp target/release/deps/libocl_cuckaroo.so "$deploy_dir/plugins/ocl_cuckaroo.cuckooplugin"
-    cp target/release/grin-miner $deploy_dir
-    cd deploy ; rm -f *.tgz; tar zcf "grin-miner-$tagname-$TRAVIS_JOB_ID-linux-amd64.tgz" *
-    /bin/ls -ls *.tgz  | awk '{print $6,$7,$8,$9,$10}'
-    md5sum "grin-miner-$tagname-$TRAVIS_JOB_ID-linux-amd64.tgz" > "grin-miner-$tagname-$TRAVIS_JOB_ID-linux-amd64.tgz"-md5sum.txt
-    /bin/ls -ls *-md5sum.txt  | awk '{print $6,$7,$8,$9,$10}'
-    cd - > /dev/null;
-    echo "tarball generated\n"
-fi
-
-version="$tagname"
-branch="`git symbolic-ref -q --short HEAD`"
-
-# automatic changelog generator
-gem install github_changelog_generator
-
-LAST_REVISION=$(git rev-list --tags --skip=1 --max-count=1)
-LAST_RELEASE_TAG=$(git describe --abbrev=0 --tags ${LAST_REVISION})
-
-# Generate CHANGELOG.md
-github_changelog_generator \
-  -u $(cut -d "/" -f1 <<< $repo_slug) \
-  -p $(cut -d "/" -f2 <<< $repo_slug) \
-  --token $token \
-  --since-tag ${LAST_RELEASE_TAG}
-
-body="$(cat CHANGELOG.md)"
-
-# Overwrite CHANGELOG.md with JSON data for GitHub API
-jq -n \
-  --arg body "$body" \
-  --arg name "$version" \
-  --arg tag_name "$version" \
-  --arg target_commitish "$branch" \
-  '{
-    body: $body,
-    name: $name,
-    tag_name: $tag_name,
-    target_commitish: $target_commitish,
-    draft: false,
-    prerelease: false
-  }' > CHANGELOG.md
-
-echo "Create release $version for repo: $repo_slug, branch: $branch"
-curl -H "Authorization: token $token" --data @CHANGELOG.md "https://api.github.com/repos/$repo_slug/releases"
-echo "auto changelog uploaded.\n"
-
diff -urN '--exclude=.git' grin-miner-1.0.2/Cargo.lock grin-miner-copy/Cargo.lock
--- grin-miner-1.0.2/Cargo.lock	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/Cargo.lock	1969-12-31 19:00:00.000000000 -0500
@@ -1,1555 +0,0 @@
-[[package]]
-name = "aho-corasick"
-version = "0.6.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "memchr 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "arc-swap"
-version = "0.3.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "array-macro"
-version = "1.0.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "arrayvec"
-version = "0.4.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "backtrace"
-version = "0.3.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "backtrace-sys 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)",
- "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "backtrace-sys"
-version = "0.1.24"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "bitflags"
-version = "0.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "bitflags"
-version = "1.0.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "blake2-rfc"
-version = "0.2.18"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)",
- "constant_time_eq 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "bufstream"
-version = "0.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "built"
-version = "0.2.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "git2 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)",
- "semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
- "toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "byteorder"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "byteorder"
-version = "1.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "cc"
-version = "1.0.25"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "cfg-if"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "chrono"
-version = "0.4.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "cl-sys"
-version = "0.4.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "cloudabi"
-version = "0.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "cmake"
-version = "0.1.34"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "const-cstr"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "constant_time_eq"
-version = "0.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "core-foundation"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "core-foundation-sys 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "core-foundation-sys"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "crossbeam"
-version = "0.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "crossbeam-channel"
-version = "0.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "crossbeam-epoch 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "crossbeam-epoch"
-version = "0.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)",
- "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "crossbeam-utils"
-version = "0.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "cuckoo_miner"
-version = "1.0.2"
-dependencies = [
- "blake2-rfc 0.2.18 (registry+https://github.com/rust-lang/crates.io-index)",
- "byteorder 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "cmake 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)",
- "const-cstr 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
- "grin_miner_plugin 1.0.2",
- "grin_miner_util 1.0.2",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "libloading 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)",
- "regex 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
- "rust-crypto 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_derive 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_json 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)",
- "slog 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "cursive"
-version = "0.9.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "crossbeam-channel 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "enum-map 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "enumset 0.3.10 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "maplit 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "ncurses 5.94.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "num 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "signal-hook 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "term_size 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "xi-unicode 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "dirs"
-version = "1.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "enum-map"
-version = "0.4.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "array-macro 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "enum-map-derive 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "reexport-proc-macro 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "enum-map-derive"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
- "quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "enum_primitive"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-traits 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "enumset"
-version = "0.3.10"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "failure"
-version = "0.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "failure_derive"
-version = "0.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
- "quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "syn 0.15.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "foreign-types"
-version = "0.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "foreign-types-shared 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "foreign-types-shared"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "fs_extra"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "fuchsia-zircon"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "fuchsia-zircon-sys"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "futures"
-version = "0.1.25"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "gcc"
-version = "0.3.54"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "git2"
-version = "0.6.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "libgit2-sys 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)",
- "url 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "glob"
-version = "0.2.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "grin_miner"
-version = "1.0.2"
-dependencies = [
- "backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "built 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "cuckoo_miner 1.0.2",
- "cursive 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "grin_miner_config 1.0.2",
- "grin_miner_plugin 1.0.2",
- "grin_miner_util 1.0.2",
- "native-tls 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "ocl_cuckaroo 1.0.2",
- "ocl_cuckatoo 1.0.2",
- "serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_derive 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_json 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)",
- "slog 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "grin_miner_config"
-version = "1.0.2"
-dependencies = [
- "cuckoo_miner 1.0.2",
- "dirs 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "grin_miner_util 1.0.2",
- "serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_derive 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "slog 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "grin_miner_plugin"
-version = "1.0.2"
-dependencies = [
- "blake2-rfc 0.2.18 (registry+https://github.com/rust-lang/crates.io-index)",
- "byteorder 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_derive 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_json 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "grin_miner_util"
-version = "1.0.2"
-dependencies = [
- "backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "byteorder 1.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde_derive 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
- "slog 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "slog-async 2.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "slog-term 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "hashbrown"
-version = "0.1.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "byteorder 1.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "idna"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "isatty"
-version = "0.1.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "itoa"
-version = "0.4.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "kernel32-sys"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "lazy_static"
-version = "0.2.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "lazy_static"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "version_check 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "libc"
-version = "0.1.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "libc"
-version = "0.2.43"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "libgit2-sys"
-version = "0.6.19"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)",
- "cmake 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "libz-sys 1.0.22 (registry+https://github.com/rust-lang/crates.io-index)",
- "pkg-config 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "libloading"
-version = "0.4.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "libz-sys"
-version = "1.0.22"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "pkg-config 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)",
- "vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "lock_api"
-version = "0.1.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "log"
-version = "0.3.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "log"
-version = "0.4.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "maplit"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "matches"
-version = "0.1.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "memchr"
-version = "2.0.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "memoffset"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "native-tls"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "openssl 0.10.15 (registry+https://github.com/rust-lang/crates.io-index)",
- "openssl-probe 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "openssl-sys 0.9.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "schannel 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)",
- "security-framework 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "security-framework-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "ncurses"
-version = "5.94.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "pkg-config 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "nodrop"
-version = "0.1.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "num"
-version = "0.1.42"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-bigint 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-complex 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-iter 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-rational 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-complex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-iter 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-rational 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-bigint"
-version = "0.1.44"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-complex"
-version = "0.1.43"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-complex"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-integer"
-version = "0.1.39"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-iter"
-version = "0.1.37"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-rational"
-version = "0.1.42"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-bigint 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-rational"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-traits"
-version = "0.1.43"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "num-traits"
-version = "0.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "ocl"
-version = "0.19.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)",
- "nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "ocl-core 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "qutex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "ocl-core"
-version = "0.10.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "cl-sys 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-complex 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "ocl-core-vector 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc_version 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "ocl-core-vector"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "num 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "ocl_cuckaroo"
-version = "1.0.2"
-dependencies = [
- "blake2-rfc 0.2.18 (registry+https://github.com/rust-lang/crates.io-index)",
- "byteorder 1.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "grin_miner_plugin 1.0.2",
- "hashbrown 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "ocl 0.19.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "ocl_cuckatoo"
-version = "1.0.2"
-dependencies = [
- "blake2-rfc 0.2.18 (registry+https://github.com/rust-lang/crates.io-index)",
- "byteorder 1.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "grin_miner_plugin 1.0.2",
- "hashbrown 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "ocl 0.19.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "openssl"
-version = "0.10.15"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "openssl-sys 0.9.39 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "openssl-probe"
-version = "0.1.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "openssl-sys"
-version = "0.9.39"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "pkg-config 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)",
- "vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "owning_ref"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "owning_ref"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "parking_lot"
-version = "0.6.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "parking_lot_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "parking_lot_core"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "percent-encoding"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "pkg-config"
-version = "0.3.14"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "proc-macro2"
-version = "0.4.19"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "quote"
-version = "0.6.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "qutex"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "crossbeam 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand"
-version = "0.3.22"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand"
-version = "0.4.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand"
-version = "0.5.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand"
-version = "0.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_chacha 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_pcg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand_chacha"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand_core"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand_core"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "rand_hc"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand_isaac"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand_pcg"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rand_xorshift"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "redox_syscall"
-version = "0.1.40"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "reexport-proc-macro"
-version = "1.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "regex"
-version = "0.2.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "aho-corasick 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "memchr 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "regex-syntax 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "utf8-ranges 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "regex-syntax"
-version = "0.5.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "ucd-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "remove_dir_all"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rust-crypto"
-version = "0.2.36"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
- "time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rustc-demangle"
-version = "0.1.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "rustc-serialize"
-version = "0.3.24"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "rustc_version"
-version = "0.1.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "semver 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "rustc_version"
-version = "0.2.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "ryu"
-version = "0.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "schannel"
-version = "0.1.14"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "scopeguard"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "security-framework"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "core-foundation 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "core-foundation-sys 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "security-framework-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "security-framework-sys"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "core-foundation-sys 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "semver"
-version = "0.1.20"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "semver"
-version = "0.9.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "semver-parser"
-version = "0.7.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "serde"
-version = "1.0.78"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "serde_derive"
-version = "1.0.78"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
- "quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "syn 0.15.4 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "serde_json"
-version = "1.0.27"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "ryu 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "signal-hook"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "arc-swap 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "slog"
-version = "2.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "slog-async"
-version = "2.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "slog 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "take_mut 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "slog-term"
-version = "2.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "isatty 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "slog 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "smallvec"
-version = "0.6.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "stable_deref_trait"
-version = "1.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "syn"
-version = "0.14.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
- "quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "syn"
-version = "0.15.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
- "quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "synstructure"
-version = "0.10.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)",
- "quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "syn 0.15.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "take_mut"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "tempfile"
-version = "3.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
- "remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "term"
-version = "0.4.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "term"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "byteorder 1.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "term_size"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "thread_local"
-version = "0.3.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "time"
-version = "0.1.40"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)",
- "redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "toml"
-version = "0.4.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "ucd-util"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "unicode-bidi"
-version = "0.3.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "unicode-normalization"
-version = "0.1.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "unicode-segmentation"
-version = "1.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "unicode-width"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "unicode-xid"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "unreachable"
-version = "1.0.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "url"
-version = "1.7.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "utf8-ranges"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "vcpkg"
-version = "0.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "version_check"
-version = "0.1.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "void"
-version = "1.0.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "winapi"
-version = "0.2.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "winapi"
-version = "0.3.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
-[[package]]
-name = "winapi-build"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "winapi-i686-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "winapi-x86_64-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[[package]]
-name = "xi-unicode"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-
-[metadata]
-"checksum aho-corasick 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)" = "68f56c7353e5a9547cbd76ed90f7bb5ffc3ba09d4ea9bd1d8c06c8b1142eeb5a"
-"checksum arc-swap 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "af192669a9f44d2fb63c691a04183c8e12428f34041449270b08c0456587f5a5"
-"checksum array-macro 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "8b1b1a00de235e9f2cc0e650423dc249d875c116a5934188c08fdd0c02d840ef"
-"checksum arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)" = "a1e964f9e24d588183fcb43503abda40d288c8657dfc27311516ce2f05675aef"
-"checksum backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)" = "89a47830402e9981c5c41223151efcced65a0510c13097c769cede7efb34782a"
-"checksum backtrace-sys 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)" = "c66d56ac8dabd07f6aacdaf633f4b8262f5b3601a810a0dcddffd5c22c69daa0"
-"checksum bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)" = "4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5"
-"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)" = "228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12"
-"checksum blake2-rfc 0.2.18 (registry+https://github.com/rust-lang/crates.io-index)" = "5d6d530bdd2d52966a6d03b7a964add7ae1a288d25214066fd4b600f0f796400"
-"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32"
-"checksum built 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)" = "228f798edaa90084bf383b0584e7a50654f2732014a7101321c4ea496743c0c9"
-"checksum byteorder 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)" = "0fc10e8cc6b2580fda3f36eb6dc5316657f812a3df879a44a66fc9f0fdbc4855"
-"checksum byteorder 1.2.6 (registry+https://github.com/rust-lang/crates.io-index)" = "90492c5858dd7d2e78691cfb89f90d273a2800fc11d98f60786e5d87e2f83781"
-"checksum cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)" = "f159dfd43363c4d08055a07703eb7a3406b0dac4d0584d96965a3262db3c9d16"
-"checksum cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "0c4e7bb64a8ebb0d856483e1e682ea3422f883c5f5615a90d51a2c82fe87fdd3"
-"checksum chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)" = "45912881121cb26fad7c38c17ba7daa18764771836b34fab7d3fbd93ed633878"
-"checksum cl-sys 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)" = "052e750edad96f2058980bc8972d97ece68249a6d4f8aacf69f3e3b8088a0ba5"
-"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f"
-"checksum cmake 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)" = "848b314ea70f48f0e13828c5554e34200952ce5720d6d3aa466b4d983af6c70e"
-"checksum const-cstr 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "2e950b379a7f9c5a83d43257fa1df616689141f326b4fc3bfb7aa7f3c7bc44d2"
-"checksum constant_time_eq 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e"
-"checksum core-foundation 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "286e0b41c3a20da26536c6000a280585d519fd07b3956b43aed8a79e9edce980"
-"checksum core-foundation-sys 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "716c271e8613ace48344f723b60b900a93150271e5be206212d052bbc0883efa"
-"checksum crossbeam 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "24ce9782d4d5c53674646a6a4c1863a21a8fc0cb649b3c94dfc16e45071dea19"
-"checksum crossbeam-channel 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)" = "7b85741761b7f160bc5e7e0c14986ef685b7f8bf9b7ad081c60c604bb4649827"
-"checksum crossbeam-epoch 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "9c90f1474584f38e270b5b613e898c8c328aa4f3dea85e0a27ac2e642f009416"
-"checksum crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "677d453a17e8bd2b913fa38e8b9cf04bcdbb5be790aa294f2389661d72036015"
-"checksum cursive 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)" = "1df013f020cf1e66c456c9af584ae660590b8147186fd66b941604f85145b880"
-"checksum dirs 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "f679c09c1cf5428702cc10f6846c56e4e23420d3a88bcc9335b17c630a7b710b"
-"checksum enum-map 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)" = "caa1769f019df7ccd8f9a741d2d608309688d0f1bd8a8747c14ac993660c761c"
-"checksum enum-map-derive 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "f915c8ef505ce27b6fa51515463938aa2e9135081fefc93aef786539a646a365"
-"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180"
-"checksum enumset 0.3.10 (registry+https://github.com/rust-lang/crates.io-index)" = "9505d5f599d98d1a83d54d270c3938d253e6794c788847b4c4b9346eae9895de"
-"checksum failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "6dd377bcc1b1b7ce911967e3ec24fa19c3224394ec05b54aa7b083d498341ac7"
-"checksum failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "64c2d913fe8ed3b6c6518eedf4538255b989945c14c2a7d5cbff62a5e2120596"
-"checksum foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
-"checksum foreign-types-shared 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"
-"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674"
-"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82"
-"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7"
-"checksum futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)" = "49e7653e374fe0d0c12de4250f0bdb60680b8c80eed558c5c7538eec9c89e21b"
-"checksum gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)" = "5e33ec290da0d127825013597dbdfc28bee4964690c7ce1166cbc2a7bd08b1bb"
-"checksum git2 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)" = "ee5b4bb7cd2a44e6e5ee3a26ba6a9ca10d4ce2771cdc3839bbc54b47b7d1be84"
-"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb"
-"checksum hashbrown 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "64b7d419d0622ae02fe5da6b9a5e1964b610a65bb37923b976aeebb6dbb8f86e"
-"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e"
-"checksum isatty 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)" = "e31a8281fc93ec9693494da65fbf28c0c2aa60a2eaec25dc58e2f31952e95edc"
-"checksum itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)" = "1306f3464951f30e30d12373d31c79fbd52d236e5e896fd92f96ec7babbbe60b"
-"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d"
-"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73"
-"checksum lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ca488b89a5657b0a2ecd45b95609b3e848cf1755da332a0da46e2b2b1cb371a7"
-"checksum libc 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)" = "e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122"
-"checksum libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)" = "76e3a3ef172f1a0b9a9ff0dd1491ae5e6c948b94479a3021819ba7d860c8645d"
-"checksum libgit2-sys 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)" = "6eeae66e7b1c995de45cb4e65c5ab438a96a7b4077e448645d4048dc753ad357"
-"checksum libloading 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)" = "fd38073de8f7965d0c17d30546d4bb6da311ab428d1c7a3fc71dff7f9d4979b9"
-"checksum libz-sys 1.0.22 (registry+https://github.com/rust-lang/crates.io-index)" = "65ff614643d7635dfa2151913d95c4ee90ee1fe15d9e0980f4dcb1a7e5837c18"
-"checksum lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "775751a3e69bde4df9b38dd00a1b5d6ac13791e4223d4a0506577f0dd27cfb7a"
-"checksum log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)" = "e19e8d5c34a3e0e2223db8e060f9e8264aeeb5c5fc64a4ee9965c062211c024b"
-"checksum log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)" = "d4fcce5fa49cc693c312001daf1d13411c4a5283796bac1084299ea3e567113f"
-"checksum maplit 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "08cbb6b4fef96b6d77bfc40ec491b1690c779e77b05cd9f07f787ed376fd4c43"
-"checksum matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)" = "7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08"
-"checksum memchr 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "a3b4142ab8738a78c51896f704f83c11df047ff1bda9a92a661aa6361552d93d"
-"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3"
-"checksum native-tls 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "ff8e08de0070bbf4c31f452ea2a70db092f36f6f2e4d897adf5674477d488fb2"
-"checksum ncurses 5.94.0 (registry+https://github.com/rust-lang/crates.io-index)" = "4a02f0da600c09fa2e5fd6479093ba8a4b21f4ed5bed3b6ddc26583b50d31319"
-"checksum nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)" = "9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2"
-"checksum num 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)" = "4703ad64153382334aa8db57c637364c322d3372e097840c72000dabdcf6156e"
-"checksum num 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "cf4825417e1e1406b3782a8ce92f4d53f26ec055e3622e1881ca8e9f5f9e08db"
-"checksum num-bigint 0.1.44 (registry+https://github.com/rust-lang/crates.io-index)" = "e63899ad0da84ce718c14936262a41cee2c79c981fc0a0e7c7beb47d5a07e8c1"
-"checksum num-complex 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)" = "b288631d7878aaf59442cffd36910ea604ecd7745c36054328595114001c9656"
-"checksum num-complex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "107b9be86cd2481930688277b675b0114578227f034674726605b8a482d8baf8"
-"checksum num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)" = "e83d528d2677f0518c570baf2b7abdcf0cd2d248860b68507bdcb3e91d4c0cea"
-"checksum num-iter 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)" = "af3fdbbc3291a5464dc57b03860ec37ca6bf915ed6ee385e7c6c052c422b2124"
-"checksum num-rational 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)" = "ee314c74bd753fc86b4780aa9475da469155f3848473a261d2d18e35245a784e"
-"checksum num-rational 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "4e96f040177bb3da242b5b1ecf3f54b5d5af3efbbfb18608977a5d2767b22f10"
-"checksum num-traits 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)" = "92e5113e9fd4cc14ded8e499429f396a20f98c772a47cc8622a736e1ec843c31"
-"checksum num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)" = "0b3a5d7cc97d6d30d8b9bc8fa19bf45349ffe46241e8816f50f62f6d6aaabee1"
-"checksum ocl 0.19.1 (registry+https://github.com/rust-lang/crates.io-index)" = "22a50f4253b11da2acbaac59fcd162e6faf49e74e4d939536687a498caabbf83"
-"checksum ocl-core 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)" = "bdff9d2d2e0404524bb6bf01faf8068b017c18e7e1141dfbdca7ec6981c3cec5"
-"checksum ocl-core-vector 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "b4072920739958adeec5abedec51af70febc58f7fff0601aaa0827c1f3c8fefd"
-"checksum openssl 0.10.15 (registry+https://github.com/rust-lang/crates.io-index)" = "5e1309181cdcbdb51bc3b6bedb33dfac2a83b3d585033d3f6d9e22e8c1928613"
-"checksum openssl-probe 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de"
-"checksum openssl-sys 0.9.39 (registry+https://github.com/rust-lang/crates.io-index)" = "278c1ad40a89aa1e741a1eed089a2f60b18fab8089c3139b542140fc7d674106"
-"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37"
-"checksum owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13"
-"checksum parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)" = "f0802bff09003b291ba756dc7e79313e51cc31667e94afbe847def490424cde5"
-"checksum parking_lot_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ad7f7e6ebdc79edff6fdcb87a55b620174f7a989e3eb31b65231f4af57f00b8c"
-"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831"
-"checksum pkg-config 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)" = "676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c"
-"checksum proc-macro2 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)" = "ffe022fb8c8bd254524b0b3305906c1921fa37a84a644e29079a9e62200c3901"
-"checksum quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)" = "dd636425967c33af890042c483632d33fa7a18f19ad1d7ea72e8998c6ef8dea5"
-"checksum qutex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "5d6bfe94e9c7d8e8b51e8f0e68757c94fb17af45e8ca3b2cb987acaf55f7f0e7"
-"checksum rand 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)" = "15a732abf9d20f0ad8eeb6f909bf6868722d9a06e1e50802b6a70351f40b4eb1"
-"checksum rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)" = "8356f47b32624fef5b3301c1be97e5944ecdd595409cc5da11d05f211db6cfbd"
-"checksum rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)" = "e464cd887e869cddcae8792a4ee31d23c7edd516700695608f5b98c67ee0131c"
-"checksum rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ae9d223d52ae411a33cf7e54ec6034ec165df296ccd23533d671a28252b6f66a"
-"checksum rand_chacha 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "771b009e3a508cb67e8823dda454aaa5368c7bc1c16829fb77d3e980440dd34a"
-"checksum rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "1961a422c4d189dfb50ffa9320bf1f2a9bd54ecb92792fb9477f99a1045f3372"
-"checksum rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "0905b6b7079ec73b314d4c748701f6931eb79fd97c668caa3f1899b22b32c6db"
-"checksum rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4"
-"checksum rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08"
-"checksum rand_pcg 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "086bd09a33c7044e56bb44d5bdde5a60e7f119a9e95b0775f545de759a32fe05"
-"checksum rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "effa3fcaa47e18db002bdde6060944b6d2f9cfd8db471c30e873448ad9187be3"
-"checksum redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)" = "c214e91d3ecf43e9a4e41e578973adeb14b474f2bee858742d127af75a0112b1"
-"checksum reexport-proc-macro 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)" = "438fe63770eda15baf98e30b4d27ada49b932866307fa04fec24d9043fe63324"
-"checksum regex 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "9329abc99e39129fcceabd24cf5d85b4671ef7c29c50e972bc5afe32438ec384"
-"checksum regex-syntax 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)" = "7d707a4fa2637f2dca2ef9fd02225ec7661fe01a53623c1e6515b6916511f7a7"
-"checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5"
-"checksum rust-crypto 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)" = "f76d05d3993fd5f4af9434e8e436db163a12a9d40e1a58a726f27a01dfd12a2a"
-"checksum rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)" = "bcfe5b13211b4d78e5c2cadfebd7769197d95c639c35a50057eb4c05de811395"
-"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)" = "dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda"
-"checksum rustc_version 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "c5f5376ea5e30ce23c03eb77cbe4962b988deead10910c372b226388b594c084"
-"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)" = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
-"checksum ryu 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)" = "7153dd96dade874ab973e098cb62fcdbb89a03682e46b144fd09550998d4a4a7"
-"checksum schannel 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)" = "0e1a231dc10abf6749cfa5d7767f25888d484201accbd919b66ab5413c502d56"
-"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27"
-"checksum security-framework 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "697d3f3c23a618272ead9e1fb259c1411102b31c6af8b93f1d64cca9c3b0e8e0"
-"checksum security-framework-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ab01dfbe5756785b5b4d46e0289e5a18071dfa9a7c2b24213ea00b9ef9b665bf"
-"checksum semver 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)" = "d4f410fedcf71af0345d7607d246e7ad15faaadd49d240ee3b24e5dc21a820ac"
-"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)" = "1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"
-"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3"
-"checksum serde 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)" = "92ec94e2754699adddbbc4f555791bd3acc2a2f5574cba16c93a4a9cf4a04415"
-"checksum serde_derive 1.0.78 (registry+https://github.com/rust-lang/crates.io-index)" = "0fb622d85245add5327d4f08b2d24fd51fa5d35fe1bba19ee79a1f211e9ac0ff"
-"checksum serde_json 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)" = "59790990c5115d16027f00913e2e66de23a51f70422e549d2ad68c8c5f268f1c"
-"checksum signal-hook 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "f7ca1f1c0ed6c8beaab713ad902c041e4f09d06e1b4bb74c5fc553c078ed0110"
-"checksum slog 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "0a6b13b17f4225771f7f15cece704a4e68d3a5f31278ed26367f497133398a18"
-"checksum slog-async 2.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "e544d16c6b230d84c866662fe55e31aacfca6ae71e6fc49ae9a311cb379bfc2f"
-"checksum slog-term 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "5951a808c40f419922ee014c15b6ae1cd34d963538b57d8a4778b9ca3fff1e0b"
-"checksum smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)" = "153ffa32fd170e9944f7e0838edf824a754ec4c1fc64746fcc9fe1f8fa602e5d"
-"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8"
-"checksum syn 0.14.9 (registry+https://github.com/rust-lang/crates.io-index)" = "261ae9ecaa397c42b960649561949d69311f08eeaea86a65696e6e46517cf741"
-"checksum syn 0.15.4 (registry+https://github.com/rust-lang/crates.io-index)" = "9056ebe7f2d6a38bc63171816fd1d3430da5a43896de21676dc5c0a4b8274a11"
-"checksum synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)" = "73687139bf99285483c96ac0add482c3776528beac1d97d444f6e91f203a2015"
-"checksum take_mut 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "f764005d11ee5f36500a149ace24e00e3da98b0158b3e2d53a7495660d3f4d60"
-"checksum tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)" = "7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2"
-"checksum term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)" = "fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1"
-"checksum term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "5e6b677dd1e8214ea1ef4297f85dbcbed8e8cdddb561040cc998ca2551c37561"
-"checksum term_size 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "9e5b9a66db815dcfd2da92db471106457082577c3c278d4138ab3e3b4e189327"
-"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)" = "c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b"
-"checksum time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)" = "d825be0eb33fda1a7e68012d51e9c7f451dc1a69391e7fdc197060bb8c56667b"
-"checksum toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)" = "a0263c6c02c4db6c8f7681f9fd35e90de799ebd4cfdeab77a38f4ff6b3d8c0d9"
-"checksum ucd-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fd2be2d6639d0f8fe6cdda291ad456e23629558d466e2789d2c3e9892bda285d"
-"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5"
-"checksum unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "6a0180bc61fc5a987082bfa111f4cc95c4caff7f9799f3e46df09163a937aa25"
-"checksum unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1"
-"checksum unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526"
-"checksum unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc"
-"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56"
-"checksum url 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "2a321979c09843d272956e73700d12c4e7d3d92b2ee112b31548aef0d4efc5a6"
-"checksum utf8-ranges 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fd70f467df6810094968e2fce0ee1bd0e87157aceb026a8c083bcf5e25b9efe4"
-"checksum vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)" = "def296d3eb3b12371b2c7d0e83bfe1403e4db2d7a0bba324a12b21c4ee13143d"
-"checksum version_check 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "7716c242968ee87e5542f8021178248f267f295a5c4803beae8b8b7fd9bc6051"
-"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d"
-"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)" = "167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a"
-"checksum winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)" = "773ef9dcc5f24b7d850d0ff101e542ff24c3b090a9768e03ff889fdef41f00fd"
-"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc"
-"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
-"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
-"checksum xi-unicode 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "12ea8eda4b1eb72f02d148402e23832d56a33f55d8c1b2d5bcdde91d79d47cb1"
diff -urN '--exclude=.git' grin-miner-1.0.2/Cargo.toml grin-miner-copy/Cargo.toml
--- grin-miner-1.0.2/Cargo.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/Cargo.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,49 +0,0 @@
-[package]
-name = "grin_miner"
-version = "1.0.2"
-authors = ["Grin Developers <mimblewimble@lists.launchpad.net>"]
-description = "Mining software for Grin, supports CPU and CUDA GPUs."
-build = "src/build/build.rs"
-license = "Apache-2.0"
-repository = "https://github.com/mimblewimble/grin-miner"
-keywords = [ "crypto", "grin", "mimblewimble", "mining"]
-autobins = false
-
-[workspace]
-members = ["config", "util", "plugin"]
-
-[features]
-default = ["tui"]
-opencl = ["ocl_cuckatoo", "ocl_cuckaroo"]
-tui = ["cursive"]
-
-[[bin]]
-name = "grin-miner"
-path = "src/bin/grin_miner.rs"
-
-[dependencies]
-backtrace = "0.3"
-bufstream = "~0.1"
-native-tls = "0.2"
-serde = "1"
-serde_derive = "1"
-serde_json = "1"
-slog = { version = "~2.1", features = ["max_level_trace", "release_max_level_trace"] }
-term = "0.4"
-time = "0.1"
-
-grin_miner_util = { path = "./util", version = "1.0.2" }
-grin_miner_plugin = { path = "./plugin", version = "1.0.2" }
-grin_miner_config = { path = "./config", version = "1.0.2" }
-cuckoo_miner = { path = "./cuckoo-miner", version = "1.0.2" }
-#use this alternative inclusion below to build cuda plugins
-#cuckoo_miner = { path = "./cuckoo-miner", version = "1.0.2", features = ["build-cuda-plugins"]}
-ocl_cuckatoo = { path = "./ocl_cuckatoo", version = "1.0.2", optional = true}
-ocl_cuckaroo = { path = "./ocl_cuckaroo", version = "1.0.2", optional = true}
-
-[dependencies.cursive]
-version = "0.9.0"
-optional = true
-
-[build-dependencies]
-built = "0.2"
diff -urN '--exclude=.git' grin-miner-1.0.2/config/Cargo.toml grin-miner-copy/config/Cargo.toml
--- grin-miner-1.0.2/config/Cargo.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/config/Cargo.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-[package]
-name = "grin_miner_config"
-version = "1.0.2"
-authors = ["Grin Developers <mimblewimble@lists.launchpad.net>"]
-description = "Configuration handling for the grin miner"
-license = "Apache-2.0"
-repository = "https://github.com/mimblewimble/grin-miner"
-workspace = ".."
-
-[dependencies]
-serde = "1"
-serde_derive = "1"
-toml = "0.4"
-dirs = "1.0"
-
-cuckoo_miner = { path = "../cuckoo-miner", version = "1.0.2" }
-slog = { version = "~2.1", features = ["max_level_trace", "release_max_level_trace"] }
-grin_miner_util = { path = "../util", version = "1.0.2" }
diff -urN '--exclude=.git' grin-miner-1.0.2/config/src/config.rs grin-miner-copy/config/src/config.rs
--- grin-miner-1.0.2/config/src/config.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/config/src/config.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,263 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Configuration file management
-
-use std::env;
-use std::fs::File;
-use std::io::Read;
-use std::path::PathBuf;
-
-use cuckoo::{CuckooMinerError, PluginConfig};
-use toml;
-use types::MinerConfig;
-use types::{ConfigError, ConfigMembers, GlobalConfig, GrinMinerPluginConfig};
-use util::{LoggingConfig, LOGGER};
-
-extern crate dirs;
-
-/// The default file name to use when trying to derive
-/// the config file location
-
-const CONFIG_FILE_NAME: &'static str = "grin-miner.toml";
-const GRIN_HOME: &'static str = ".grin";
-
-/// resolve a read parameter to a solver param, (or not if it isn't found)
-fn resolve_param(config: &mut PluginConfig, name: &str, value: u32) {
-	match name {
-		"nthreads" => config.params.nthreads = value,
-		"ntrims" => config.params.ntrims = value,
-		"cpuload" => {
-			config.params.cpuload = match value {
-				1 => true,
-				_ => false,
-			}
-		}
-		"device" => config.params.device = value,
-		"blocks" => config.params.blocks = value,
-		"tbp" => config.params.tpb = value,
-		"expand" => config.params.expand = value,
-		"genablocks" => config.params.genablocks = value,
-		"genatpb" => config.params.genatpb = value,
-		"genbtpb" => config.params.genbtpb = value,
-		"trimtpb" => config.params.trimtpb = value,
-		"tailtpb" => config.params.tailtpb = value,
-		"recoverblocks" => config.params.recoverblocks = value,
-		"recovertpb" => config.params.recovertpb = value,
-		"platform" => config.params.platform = value,
-		"edge_bits" => config.params.edge_bits = value,
-		n => {
-			warn!(LOGGER, "Configuration param: {} unknown. Ignored.", n);
-		}
-	};
-}
-
-/// Transforms a set of grin-miner plugin configs to cuckoo-miner plugins configs
-pub fn read_configs(
-	plugin_dir: Option<PathBuf>,
-	conf_in: Vec<GrinMinerPluginConfig>,
-) -> Result<Vec<PluginConfig>, CuckooMinerError> {
-	// Resolve a final plugin path, either config-provided or from the current executable path
-	let plugin_dir_absolute_path = match plugin_dir {
-		Some(path) => {
-			let absolute_path = path.canonicalize().map_err(CuckooMinerError::from);
-			if let Ok(path) = &absolute_path {
-				debug!(
-					LOGGER,
-					"Using mining plugin dir provided by config: {:?}", path
-				);
-			};
-			absolute_path
-		}
-		None => {
-			let absolute_path =
-				env::current_exe()
-					.map_err(CuckooMinerError::from)
-					.map(|mut env_path| {
-						env_path.pop();
-						// cargo test exes are a directory further down
-						if env_path.ends_with("deps") {
-							env_path.pop();
-						}
-						env_path.push("plugins");
-						env_path
-					});
-			if let Ok(path) = &absolute_path {
-				debug!(
-					LOGGER,
-					"No mining plugin dir provided by config. Using default plugin dir: {:?}", path
-				);
-			};
-			absolute_path
-		}
-	}?;
-
-	let mut return_vec = vec![];
-	for conf in conf_in {
-		let res = PluginConfig::new(plugin_dir_absolute_path.clone(), &conf.plugin_name);
-		match res {
-			Err(e) => {
-				error!(LOGGER, "Error reading plugin config: {:?}", e);
-				return Err(e);
-			}
-			Ok(mut c) => {
-				if conf.parameters.is_some() {
-					let params = conf.parameters.unwrap();
-					for k in params.keys() {
-						resolve_param(&mut c, k, *params.get(k).unwrap());
-					}
-				}
-				return_vec.push(c)
-			}
-		}
-	}
-	Ok(return_vec)
-}
-
-/// Returns the defaults, as strewn throughout the code
-impl Default for ConfigMembers {
-	fn default() -> ConfigMembers {
-		ConfigMembers {
-			mining: MinerConfig::default(),
-			logging: Some(LoggingConfig::default()),
-		}
-	}
-}
-
-impl Default for GlobalConfig {
-	fn default() -> GlobalConfig {
-		GlobalConfig {
-			config_file_path: None,
-			using_config_file: false,
-			members: Some(ConfigMembers::default()),
-		}
-	}
-}
-
-impl GlobalConfig {
-	/// Need to decide on rules where to read the config file from,
-	/// but will take a stab at logic for now
-
-	fn derive_config_location(&mut self) -> Result<(), ConfigError> {
-		// First, check working directory
-		let mut config_path = env::current_dir().unwrap();
-		config_path.push(CONFIG_FILE_NAME);
-		if config_path.exists() {
-			self.config_file_path = Some(config_path);
-			return Ok(());
-		}
-		// Next, look in directory of executable
-		let mut config_path = env::current_exe().unwrap();
-		config_path.pop();
-		config_path.push(CONFIG_FILE_NAME);
-		if config_path.exists() {
-			self.config_file_path = Some(config_path);
-			return Ok(());
-		}
-		// Then look in {user_home}/.grin
-		let config_path = dirs::home_dir();
-		if let Some(mut p) = config_path {
-			p.push(GRIN_HOME);
-			p.push(CONFIG_FILE_NAME);
-			if p.exists() {
-				self.config_file_path = Some(p);
-				return Ok(());
-			}
-		}
-
-		// Give up
-		Err(ConfigError::FileNotFoundError(String::from("")))
-	}
-
-	/// Takes the path to a config file, or if NONE, tries
-	/// to determine a config file based on rules in
-	/// derive_config_location
-
-	pub fn new(file_path: Option<&str>) -> Result<GlobalConfig, ConfigError> {
-		let mut return_value = GlobalConfig::default();
-		if let Some(fp) = file_path {
-			return_value.config_file_path = Some(PathBuf::from(&fp));
-		} else {
-			let _result = return_value.derive_config_location();
-		}
-
-		// No attempt at a config file, just return defaults
-		if let None = return_value.config_file_path {
-			return Ok(return_value);
-		}
-
-		// Config file path is given but not valid
-		if !return_value.config_file_path.as_mut().unwrap().exists() {
-			return Err(ConfigError::FileNotFoundError(String::from(
-				return_value
-					.config_file_path
-					.as_mut()
-					.unwrap()
-					.to_str()
-					.unwrap()
-					.clone(),
-			)));
-		}
-
-		// Try to parse the config file if it exists
-		// explode if it does exist but something's wrong
-		// with it
-		return_value.read_config()
-	}
-
-	/// Read config
-	pub fn read_config(mut self) -> Result<GlobalConfig, ConfigError> {
-		let mut file = File::open(self.config_file_path.as_mut().unwrap())?;
-		let mut contents = String::new();
-		file.read_to_string(&mut contents)?;
-		let decoded: Result<ConfigMembers, toml::de::Error> = toml::from_str(&contents);
-		match decoded {
-			Ok(gc) => {
-				// Put the struct back together, because the config
-				// file was flattened a bit
-				self.using_config_file = true;
-				self.members = Some(gc);
-				return Ok(self);
-			}
-			Err(e) => {
-				return Err(ConfigError::ParseError(
-					String::from(
-						self.config_file_path
-							.as_mut()
-							.unwrap()
-							.to_str()
-							.unwrap()
-							.clone(),
-					),
-					String::from(format!("{}", e)),
-				));
-			}
-		}
-	}
-
-	/// Serialize config
-	pub fn ser_config(&mut self) -> Result<String, ConfigError> {
-		let encoded: Result<String, toml::ser::Error> =
-			toml::to_string(self.members.as_mut().unwrap());
-		match encoded {
-			Ok(enc) => return Ok(enc),
-			Err(e) => {
-				return Err(ConfigError::SerializationError(String::from(format!(
-					"{}",
-					e
-				))));
-			}
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/config/src/lib.rs grin-miner-copy/config/src/lib.rs
--- grin-miner-1.0.2/config/src/lib.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/config/src/lib.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Crate wrapping up mining configuration file
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-extern crate serde;
-#[macro_use]
-extern crate serde_derive;
-extern crate toml;
-
-#[macro_use]
-extern crate slog;
-
-extern crate grin_miner_util as util;
-extern crate cuckoo_miner as cuckoo;
-
-mod config;
-mod types;
-
-pub use types::{ConfigError, ConfigMembers, GlobalConfig, GrinMinerPluginConfig, MinerConfig};
-pub use config::read_configs;
diff -urN '--exclude=.git' grin-miner-1.0.2/config/src/types.rs grin-miner-copy/config/src/types.rs
--- grin-miner-1.0.2/config/src/types.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/config/src/types.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,156 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Public types for config modules
-
-use std::collections::HashMap;
-use std::path::PathBuf;
-use std::{fmt, io};
-
-use util;
-
-/// CuckooMinerPlugin configuration
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct GrinMinerPluginConfig {
-	/// The type of plugin to load (i.e. filters on filename)
-	pub plugin_name: String,
-
-	///
-	pub parameters: Option<HashMap<String, u32>>,
-}
-
-impl Default for GrinMinerPluginConfig {
-	fn default() -> GrinMinerPluginConfig {
-		GrinMinerPluginConfig {
-			plugin_name: String::new(),
-			parameters: None,
-		}
-	}
-}
-
-/// Error type wrapping config errors.
-#[derive(Debug)]
-pub enum ConfigError {
-	/// Error with parsing of config file
-	ParseError(String, String),
-
-	/// Error with fileIO while reading config file
-	FileIOError(String, String),
-
-	/// No file found
-	FileNotFoundError(String),
-
-	/// Error serializing config values
-	SerializationError(String),
-}
-
-impl fmt::Display for ConfigError {
-	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-		match *self {
-			ConfigError::ParseError(ref file_name, ref message) => write!(
-				f,
-				"Error parsing configuration file at {} - {}",
-				file_name, message
-			),
-			ConfigError::FileIOError(ref file_name, ref message) => {
-				write!(f, "{} {}", message, file_name)
-			}
-			ConfigError::FileNotFoundError(ref file_name) => {
-				write!(f, "Configuration file not found: {}", file_name)
-			}
-			ConfigError::SerializationError(ref message) => {
-				write!(f, "Error serializing configuration: {}", message)
-			}
-		}
-	}
-}
-
-impl From<io::Error> for ConfigError {
-	fn from(error: io::Error) -> ConfigError {
-		ConfigError::FileIOError(
-			String::from(""),
-			String::from(format!("Error loading config file: {}", error)),
-		)
-	}
-}
-
-/// basic mining configuration
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct MinerConfig {
-	/// Whether to run the tui
-	pub run_tui: bool,
-
-	/// mining loop by adding a sleep to the thread
-	pub stratum_server_addr: String,
-
-	/// login for the stratum server
-	pub stratum_server_login: Option<String>,
-
-	/// password for the stratum server
-	pub stratum_server_password: Option<String>,
-
-	/// whether tls is enabled for the stratum server
-	pub stratum_server_tls_enabled: Option<bool>,
-
-	/// plugin dir
-	pub miner_plugin_dir: Option<PathBuf>,
-
-	/// Cuckoo miner plugin configuration, one for each plugin
-	pub miner_plugin_config: Vec<GrinMinerPluginConfig>,
-}
-
-impl Default for MinerConfig {
-	fn default() -> MinerConfig {
-		MinerConfig {
-			run_tui: false,
-			miner_plugin_dir: None,
-			miner_plugin_config: vec![],
-			stratum_server_addr: String::from("http://127.0.0.1:13416"),
-			stratum_server_login: None,
-			stratum_server_password: None,
-			stratum_server_tls_enabled: None,
-		}
-	}
-}
-
-/// separately for now, then put them together as a single
-/// ServerConfig object afterwards. This is to flatten
-/// out the configuration file into logical sections,
-/// as they tend to be quite nested in the code
-/// Most structs optional, as they may or may not
-/// be needed depending on what's being run
-#[derive(Debug, Serialize, Deserialize)]
-pub struct GlobalConfig {
-	/// Keep track of the file we've read
-	pub config_file_path: Option<PathBuf>,
-	/// keep track of whether we're using
-	/// a config file or just the defaults
-	/// for each member
-	pub using_config_file: bool,
-	/// Global member config
-	pub members: Option<ConfigMembers>,
-}
-
-/// Keeping an 'inner' structure here, as the top
-/// level GlobalConfigContainer options might want to keep
-/// internal state that we don't necessarily
-/// want serialised or deserialised
-#[derive(Debug, Serialize, Deserialize)]
-pub struct ConfigMembers {
-	/// Server config
-	/// Mining config
-	pub mining: MinerConfig,
-	/// Logging config
-	pub logging: Option<util::types::LoggingConfig>,
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/Cargo.toml grin-miner-copy/cuckoo-miner/Cargo.toml
--- grin-miner-1.0.2/cuckoo-miner/Cargo.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/Cargo.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,43 +0,0 @@
-[package]
-name = "cuckoo_miner"
-version = "1.0.2"
-authors = ["yeastplume"]
-license = "MIT/Apache-2.0/BSD-3-Clause"
-description = "Rust bindings to John Tromp's Cuckoo Cycle Implementations"
-repository = "https://github.com/mimblewimble/grin-miner"
-readme = "../README.md"
-build = "src/build.rs"
-
-[features]
-default = []
-#feature to allow turing off plugin builds
-no-plugin-build = []
-#whether to test avx2 CPU plugins
-test-avx2 = []
-#feature which defines whether to build cuda libs
-build-cuda-plugins = []
-
-[dependencies]
-grin_miner_util = { path = "../util", version = "1.0.2" }
-grin_miner_plugin = { path = "../plugin", version = "1.0.2" }
-time = "^0.1"
-rust-crypto = "0.2.36"
-log = "^0.3"
-rand = "^0.3.16"
-byteorder = "^0.5"
-blake2-rfc = "~0.2.17"
-regex = "~0.2.2"
-glob = "0.2.11"
-serde = "~1.0.8"
-serde_derive = "~1.0.8"
-serde_json = "~1.0.2"
-libc = "0.2.24"
-libloading = "0.4.1"
-slog = { version = "~2.1", features = ["max_level_trace", "release_max_level_trace"] }
-
-[dev-dependencies]
-const-cstr = "0.2"
-
-[build-dependencies]
-cmake = "0.1.24"
-fs_extra = "1.1.0"
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/build.rs grin-miner-copy/cuckoo-miner/src/build.rs
--- grin-miner-1.0.2/cuckoo-miner/src/build.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/build.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,91 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! cmake wrapper for build
-
-extern crate cmake;
-extern crate fs_extra;
-
-mod sanity;
-
-use cmake::Config;
-use std::{env, fs};
-use std::path::PathBuf;
-use fs_extra::dir::*;
-use sanity::Finder;
-
-
-#[cfg(feature = "build-cuda-plugins")]
-const BUILD_CUDA_PLUGINS:&str="TRUE";
-#[cfg(not(feature = "build-cuda-plugins"))]
-const BUILD_CUDA_PLUGINS:&str="FALSE";
-
-/// Tests whether source cuckoo directory exists
-
-pub fn fail_on_empty_directory(name: &str) {
-	if fs::read_dir(name).unwrap().count() == 0 {
-		println!(
-			"The `{}` directory is empty. Did you forget to pull the submodules?",
-			name
-		);
-		println!("Try `git submodule update --init --recursive`");
-		panic!();
-	}
-}
-
-fn main() {
-	#[cfg(feature = "no-plugin-build")]
-	return;
-	fail_on_empty_directory("src/cuckoo_sys/plugins/cuckoo");
-	let path_str = env::var("OUT_DIR").unwrap();
-	let mut out_path = PathBuf::from(&path_str);
-	out_path.pop();
-	out_path.pop();
-	out_path.pop();
-	let mut plugin_path = PathBuf::from(&path_str);
-	plugin_path.push("build");
-	plugin_path.push("plugins");
-	// Collect the files and directories we care about
-	let p = PathBuf::from("src/cuckoo_sys/plugins");
-	let dir_content = match get_dir_content(p) {
-		Ok(c) => c,
-		Err(e) => panic!("Error getting directory content: {}", e),
-	};
-	for d in dir_content.directories {
-		let file_content = get_dir_content(d).unwrap();
-		for f in file_content.files {
-			println!("cargo:rerun-if-changed={}", f);
-		}
-	}
-	for f in dir_content.files {
-		println!("cargo:rerun-if-changed={}", f);
-	}
-
-	let dst = Config::new("src/cuckoo_sys/plugins")
-	                      .define("BUILD_CUDA_PLUGINS",BUILD_CUDA_PLUGINS) //whatever flags go here
-	                      //.cflag("-foo") //and here
-	                      .build_target("")
-	                      .build();
-
-	println!("Plugin path: {:?}", plugin_path);
-	println!("OUT PATH: {:?}", out_path);
-	let mut options = CopyOptions::new();
-	options.overwrite = true;
-	if let Err(e) = copy(plugin_path, out_path, &options) {
-		println!("{:?}", e);
-	}
-
-	println!("cargo:rustc-link-search=native={}", dst.display());
-
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/config/mod.rs grin-miner-copy/cuckoo-miner/src/config/mod.rs
--- grin-miner-1.0.2/cuckoo-miner/src/config/mod.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/config/mod.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Configuration types
-//! for loading a mining plugin and performing a cuckoo mining call.
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-pub mod types;
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/config/types.rs grin-miner-copy/cuckoo-miner/src/config/types.rs
--- grin-miner-1.0.2/cuckoo-miner/src/config/types.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/config/types.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,104 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Public Types used for cuckoo-miner module
-
-use plugin::SolverParams;
-use std::path::PathBuf;
-use std::{fmt, io};
-use {CuckooMinerError, PluginLibrary};
-
-pub static SO_SUFFIX: &str = ".cuckooplugin";
-
-/// CuckooMinerPlugin configuration
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct PluginConfig {
-	/// The display name of the plugin to load
-	pub name: String,
-
-	/// The path to the file
-	pub file: String,
-
-	/// device params
-	pub params: SolverParams,
-}
-
-impl PluginConfig {
-	/// create new!
-	pub fn new(mut plugin_dir: PathBuf, name: &str) -> Result<PluginConfig, CuckooMinerError> {
-		plugin_dir.push(format!("{}{}", name, SO_SUFFIX).as_str());
-		let plugin_file_str = plugin_dir.to_str().ok_or_else(|| {
-			CuckooMinerError::PluginNotFoundError(
-				"Invalid plugin path. Paths must be valid unicode".to_owned(),
-			)
-		})?;
-
-		PluginLibrary::new(plugin_file_str).map(|plugin_library| {
-			let params = plugin_library.get_default_params();
-			plugin_library.unload();
-			PluginConfig {
-				name: name.to_owned(),
-				file: plugin_file_str.to_owned(),
-				params,
-			}
-		})
-	}
-}
-
-/// Error type wrapping config errors.
-#[derive(Debug)]
-#[allow(dead_code)]
-pub enum ConfigError {
-	/// Error with parsing of config file
-	ParseError(String, String),
-
-	/// Error with fileIO while reading config file
-	FileIOError(String, String),
-
-	/// No file found
-	FileNotFoundError(String),
-
-	/// Error serializing config values
-	SerializationError(String),
-}
-
-impl fmt::Display for ConfigError {
-	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-		match *self {
-			ConfigError::ParseError(ref file_name, ref message) => write!(
-				f,
-				"Error parsing configuration file at {} - {}",
-				file_name, message
-			),
-			ConfigError::FileIOError(ref file_name, ref message) => {
-				write!(f, "{} {}", message, file_name)
-			}
-			ConfigError::FileNotFoundError(ref file_name) => {
-				write!(f, "Configuration file not found: {}", file_name)
-			}
-			ConfigError::SerializationError(ref message) => {
-				write!(f, "Error serializing configuration: {}", message)
-			}
-		}
-	}
-}
-
-impl From<io::Error> for ConfigError {
-	fn from(error: io::Error) -> ConfigError {
-		ConfigError::FileIOError(
-			String::from(""),
-			String::from(format!("Error loading config file: {}", error)),
-		)
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/ffi.rs grin-miner-copy/cuckoo-miner/src/cuckoo_sys/ffi.rs
--- grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/ffi.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/cuckoo_sys/ffi.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,205 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Low-Level manager for loading and unloading plugins. These functions
-//! should generally not be called directly by most consumers, who should
-//! be using the high level interfaces found in the config, manager, and
-//! miner modules. These functions are meant for internal cuckoo-miner crates,
-//! and will not be exposed to other projects including the cuckoo-miner crate.
-
-use plugin::*;
-use std::sync::{Arc, Mutex};
-use util::LOGGER;
-
-use libloading;
-
-use error::error::CuckooMinerError;
-
-/// Struct to hold instances of loaded plugins
-
-pub struct PluginLibrary {
-	///The full file path to the plugin loaded by this instance
-	pub lib_full_path: String,
-
-	loaded_library: Arc<Mutex<libloading::Library>>,
-	cuckoo_create_solver_ctx: Arc<Mutex<CuckooCreateSolverCtx>>,
-	cuckoo_destroy_solver_ctx: Arc<Mutex<CuckooDestroySolverCtx>>,
-	cuckoo_run_solver: Arc<Mutex<CuckooRunSolver>>,
-	cuckoo_stop_solver: Arc<Mutex<CuckooStopSolver>>,
-	cuckoo_fill_default_params: Arc<Mutex<CuckooFillDefaultParams>>,
-}
-
-impl PluginLibrary {
-	/// Loads the specified library
-
-	pub fn new(lib_full_path: &str) -> Result<PluginLibrary, CuckooMinerError> {
-		debug!(LOGGER, "Loading miner plugin: {}", &lib_full_path);
-
-		let result = libloading::Library::new(lib_full_path);
-
-		if let Err(e) = result {
-			return Err(CuckooMinerError::PluginNotFoundError(String::from(
-				format!("{} - {:?}", lib_full_path, e),
-			)));
-		}
-
-		let loaded_library = result.unwrap();
-		PluginLibrary::load_symbols(loaded_library, lib_full_path)
-	}
-
-	fn load_symbols(
-		loaded_library: libloading::Library,
-		path: &str,
-	) -> Result<PluginLibrary, CuckooMinerError> {
-		unsafe {
-			let ret_val = PluginLibrary {
-				lib_full_path: String::from(path),
-
-				cuckoo_create_solver_ctx: {
-					let cuckoo_create_solver_ctx: libloading::Symbol<
-						CuckooCreateSolverCtx,
-					> = loaded_library.get(b"create_solver_ctx\0").unwrap();
-					Arc::new(Mutex::new(*cuckoo_create_solver_ctx.into_raw()))
-				},
-
-				cuckoo_destroy_solver_ctx: {
-					let cuckoo_destroy_solver_ctx: libloading::Symbol<
-						CuckooDestroySolverCtx,
-					> = loaded_library.get(b"destroy_solver_ctx\0").unwrap();
-					Arc::new(Mutex::new(*cuckoo_destroy_solver_ctx.into_raw()))
-				},
-
-				cuckoo_run_solver: {
-					let cuckoo_run_solver: libloading::Symbol<CuckooRunSolver> =
-						loaded_library.get(b"run_solver\0").unwrap();
-					Arc::new(Mutex::new(*cuckoo_run_solver.into_raw()))
-				},
-
-				cuckoo_stop_solver: {
-					let cuckoo_stop_solver: libloading::Symbol<
-						CuckooStopSolver,
-					> = loaded_library.get(b"stop_solver\0").unwrap();
-					Arc::new(Mutex::new(*cuckoo_stop_solver.into_raw()))
-				},
-
-				cuckoo_fill_default_params: {
-					let cuckoo_fill_default_params: libloading::Symbol<
-						CuckooFillDefaultParams,
-					> = loaded_library.get(b"fill_default_params\0").unwrap();
-					Arc::new(Mutex::new(*cuckoo_fill_default_params.into_raw()))
-				},
-
-				loaded_library: Arc::new(Mutex::new(loaded_library)),
-			};
-
-			return Ok(ret_val);
-		}
-	}
-
-	/// #Description
-	///
-	/// Unloads the currently loaded plugin and all symbols.
-	///
-	/// #Arguments
-	///
-	/// None
-	///
-	/// #Returns
-	///
-	/// Nothing
-	///
-
-	pub fn unload(&self) {
-		let cuckoo_create_solver_ref = self.cuckoo_create_solver_ctx.lock().unwrap();
-		drop(cuckoo_create_solver_ref);
-
-		let cuckoo_destroy_solver_ref = self.cuckoo_destroy_solver_ctx.lock().unwrap();
-		drop(cuckoo_destroy_solver_ref);
-
-		let cuckoo_run_solver_ref = self.cuckoo_run_solver.lock().unwrap();
-		drop(cuckoo_run_solver_ref);
-
-		let cuckoo_stop_solver_ref = self.cuckoo_stop_solver.lock().unwrap();
-		drop(cuckoo_stop_solver_ref);
-
-		let cuckoo_fill_default_params_ref = self.cuckoo_fill_default_params.lock().unwrap();
-		drop(cuckoo_fill_default_params_ref);
-
-		let loaded_library_ref = self.loaded_library.lock().unwrap();
-		drop(loaded_library_ref);
-	}
-
-	/// Create a solver context
-	pub fn create_solver_ctx(&self, params: &mut SolverParams) -> *mut SolverCtx {
-		let call_ref = self.cuckoo_create_solver_ctx.lock().unwrap();
-		unsafe { call_ref(params) }
-	}
-
-	/// Destroy solver context
-	pub fn destroy_solver_ctx(&self, ctx: *mut SolverCtx) {
-		let call_ref = self.cuckoo_destroy_solver_ctx.lock().unwrap();
-		unsafe { call_ref(ctx) }
-	}
-
-	/// Run Solver
-	pub fn run_solver(
-		&self,
-		ctx: *mut SolverCtx,
-		header: Vec<u8>,
-		nonce: u64,
-		range: u32,
-		solutions: &mut SolverSolutions,
-		stats: &mut SolverStats,
-	) -> u32 {
-		let call_ref = self.cuckoo_run_solver.lock().unwrap();
-		unsafe {
-			call_ref(
-				ctx,
-				header.as_ptr(),
-				header.len() as u32,
-				nonce,
-				range,
-				solutions,
-				stats,
-			)
-		}
-	}
-
-	/// Stop solver
-	pub fn stop_solver(&self, ctx: *mut SolverCtx) {
-		let call_ref = self.cuckoo_stop_solver.lock().unwrap();
-		unsafe { call_ref(ctx) }
-	}
-
-	/// Get default params
-	pub fn get_default_params(&self) -> SolverParams {
-		let mut ret_params = SolverParams::default();
-		let call_ref = self.cuckoo_fill_default_params.lock().unwrap();
-		unsafe {
-			call_ref(&mut ret_params);
-			ret_params
-		}
-	}
-
-	/// Get an instance of the stop function, to allow it to run in another thread
-	pub fn get_stop_solver_instance(&self) -> Arc<Mutex<CuckooStopSolver>> {
-		self.cuckoo_stop_solver.clone()
-	}
-
-	/// Stop solver from a "detached" instance
-	pub fn stop_solver_from_instance(inst: Arc<Mutex<CuckooStopSolver>>, ctx: *mut SolverCtx) {
-		let call_ref = inst.lock().unwrap();
-		unsafe { call_ref(ctx) }
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/mod.rs grin-miner-copy/cuckoo-miner/src/cuckoo_sys/mod.rs
--- grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/mod.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/cuckoo_sys/mod.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,30 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-//! Crate containing the low level calls to cuckoo-miner plugins, including
-//! functions
-//! for loading and unloading plugins, querying what plugins are installed on
-//! the system,
-//! as well as the actual mining calls to a plugin. This crate should be used
-//! by other
-//! cuckoo-miner crates, but should not be exposed to external consumers of the
-//! crate.
-
-pub mod ffi;
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/plugins/cmake/CudaComputeTargetFlags.cmake grin-miner-copy/cuckoo-miner/src/cuckoo_sys/plugins/cmake/CudaComputeTargetFlags.cmake
--- grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/plugins/cmake/CudaComputeTargetFlags.cmake	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/cuckoo_sys/plugins/cmake/CudaComputeTargetFlags.cmake	1969-12-31 19:00:00.000000000 -0500
@@ -1,43 +0,0 @@
-#
-#  Compute target flags macros by Anatoly Baksheev
-# 
-#  Usage in CmakeLists.txt:
-#   	include(CudaComputeTargetFlags.cmake)
-#		APPEND_TARGET_ARCH_FLAGS() 
-
-#compute flags macros
-MACRO(CUDA_COMPUTE_TARGET_FLAGS arch_bin arch_ptx cuda_nvcc_target_flags)
-	string(REGEX REPLACE "\\." "" ARCH_BIN_WITHOUT_DOTS "${${arch_bin}}")
-	string(REGEX REPLACE "\\." "" ARCH_PTX_WITHOUT_DOTS "${${arch_ptx}}")
-								
-	set(cuda_computer_target_flags_temp "") 
-	
-	# Tell NVCC to add binaries for the specified GPUs
-	string(REGEX MATCHALL "[0-9()]+" ARCH_LIST "${ARCH_BIN_WITHOUT_DOTS}")
-	foreach(ARCH IN LISTS ARCH_LIST)
-		if (ARCH MATCHES "([0-9]+)\\(([0-9]+)\\)")
-			# User explicitly specified PTX for the concrete BIN					
-			set(cuda_computer_target_flags_temp ${cuda_computer_target_flags_temp} -gencode arch=compute_${CMAKE_MATCH_2},code=sm_${CMAKE_MATCH_1})					
-		else()					
-			# User didn't explicitly specify PTX for the concrete BIN, we assume PTX=BIN                				
-			set(cuda_computer_target_flags_temp ${cuda_computer_target_flags_temp} -gencode arch=compute_${ARCH},code=sm_${ARCH})					
-		endif()
-	endforeach()
-				
-	# Tell NVCC to add PTX intermediate code for the specified architectures
-	string(REGEX MATCHALL "[0-9]+" ARCH_LIST "${ARCH_PTX_WITHOUT_DOTS}")
-	foreach(ARCH IN LISTS ARCH_LIST)				
-		set(cuda_computer_target_flags_temp ${cuda_computer_target_flags_temp} -gencode arch=compute_${ARCH},code=compute_${ARCH})				
-	endforeach()	
-							
-	set(${cuda_nvcc_target_flags} ${cuda_computer_target_flags_temp})		
-ENDMACRO()
-
-MACRO(APPEND_TARGET_ARCH_FLAGS)
-	set(cuda_nvcc_target_flags "")
-	CUDA_COMPUTE_TARGET_FLAGS(CUDA_ARCH_BIN CUDA_ARCH_PTX cuda_nvcc_target_flags)		
-	if (cuda_nvcc_target_flags)
-		message(STATUS "CUDA NVCC target flags: ${cuda_nvcc_target_flags}")
-		list(APPEND CUDA_NVCC_FLAGS ${cuda_nvcc_target_flags})
-	endif()
-ENDMACRO()
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/plugins/cmake/find_cuda.cmake grin-miner-copy/cuckoo-miner/src/cuckoo_sys/plugins/cmake/find_cuda.cmake
--- grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/plugins/cmake/find_cuda.cmake	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/cuckoo_sys/plugins/cmake/find_cuda.cmake	1969-12-31 19:00:00.000000000 -0500
@@ -1,69 +0,0 @@
-#from: https://github.com/PointCloudLibrary/pcl/blob/master/cmake/pcl_find_cuda.cmake
-# Find CUDA
-if(MSVC)
-	# Setting this to true brakes Visual Studio builds.
-	set(CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE OFF CACHE BOOL "CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE")
-endif()
-
-set(CUDA_FIND_QUIETLY TRUE)
-find_package(CUDA 4)
-
-if(CUDA_FOUND)
-	message(STATUS "Found CUDA Toolkit v${CUDA_VERSION_STRING}")
-	
-	# CUDA 9.1 + installs a symlink to its preferred compiler, so use that if it exists
-	# Otherwise, try to default to /usr/bin/gcc if one hasn't been supplied at the command line
-	# This will not override an existing cache
-	# value if the user has passed CUDA_HOST_COMPILER_OVERRIDE on the command line.
-	if (CUDA_HOST_COMPILER_OVERRIDE)
-	  set (CUDA_HOST_COMPILER ${CUDA_HOST_COMPILER_OVERRIDE})
-	elseif (EXISTS /opt/cuda/bin/gcc)
-	  set(CUDA_HOST_COMPILER /opt/cuda/bin/gcc)
-	elseif (EXISTS /usr/bin/gcc)
-	  set(CUDA_HOST_COMPILER /usr/bin/gcc)
-	elseif (EXISTS /usr/bin/cc)
-	  set(CUDA_HOST_COMPILER /usr/bin/cc)
-	endif()
-
-	message(STATUS "Setting CMAKE_HOST_COMPILER to ${CUDA_HOST_COMPILER}.")
-
-	# Send a warning if CUDA_HOST_COMPILER is set to a compiler that is known
-	# to be unsupported.
-	if (CUDA_HOST_COMPILER STREQUAL CMAKE_C_COMPILER AND CMAKE_C_COMPILER_ID STREQUAL "Clang")
-	  message(WARNING "CUDA_HOST_COMPILER is set to an unsupported compiler: ${CMAKE_C_COMPILER}.")
-	endif()
-
-	# CUDA_ARCH_BIN is a space separated list of versions to include in output so-file. So you can set CUDA_ARCH_BIN = 10 11 12 13 20
-	# Also user can specify virtual arch in parenthesis to limit instructions  set, 
-	# for example CUDA_ARCH_BIN = 11(11) 12(11) 13(11) 20(11) 21(11) -> forces using only sm_11 instructions.
-	# The CMake scripts interpret XX as XX (XX). This allows user to omit parenthesis. 
-	# Arch 21 is an exceptional case since it doesn't have own sm_21 instructions set. 
-	# So 21 = 21(21) is an invalid configuration and user has to explicitly force previous sm_20 instruction set via 21(20).
-	# CUDA_ARCH_BIN adds support of only listed GPUs. As alternative CMake scripts also parse 'CUDA_ARCH_PTX' variable,
-	# which is a list of intermediate PTX codes to include in final so-file. The PTX code can/will be JIT compiled for any current or future GPU. 
-	# To add support of older GPU for kinfu, I would embed PTX 11 and 12 into so-file. GPU with sm_13  will run PTX 12 code (no difference for kinfu)
-	
-	# Find a complete list for CUDA compute capabilities at http://developer.nvidia.com/cuda-gpus
-
-        if(NOT ${CUDA_VERSION_STRING} VERSION_LESS "10.0")
-                set(__cuda_arch_bin "3.5 3.7 5.0 5.2 6.0 6.1 7.0 7.2 7.5")
-        elseif(NOT ${CUDA_VERSION_STRING} VERSION_LESS "9.0")
-                set(__cuda_arch_bin "3.5 3.7 5.0 5.2 6.0 6.1 7.0")
-        elseif(NOT ${CUDA_VERSION_STRING} VERSION_LESS "8.0")
-                set(__cuda_arch_bin "3.5 5.0 5.2 5.3 6.0 6.1")
-        else()
-                set(__cuda_arch_bin "3.5")
-        endif()
-
-        set(CUDA_ARCH_BIN ${__cuda_arch_bin} CACHE STRING "Specify 'real' GPU architectures to build binaries for, BIN(PTX) format is supported")
-
-	set(CUDA_ARCH_PTX "" CACHE STRING "Specify 'virtual' PTX arch to build PTX intermediate code for. Example: 1.0 1.2 or 10 12")
-	#set(CUDA_ARCH_PTX "1.1 1.2" CACHE STRING "Specify 'virtual' PTX arch to build PTX intermediate code for. Example: 1.0 1.2 or 10 12")
-
-	# Guess this macros will be included in cmake distributive
-	include(cmake/CudaComputeTargetFlags.cmake)
-	APPEND_TARGET_ARCH_FLAGS()
-
-  # Prevent compilation issues between recent gcc versions and old CUDA versions
-  list(APPEND CUDA_NVCC_FLAGS "-D_FORCE_INLINES")
-endif()
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/plugins/CMakeLists.txt grin-miner-copy/cuckoo-miner/src/cuckoo_sys/plugins/CMakeLists.txt
--- grin-miner-1.0.2/cuckoo-miner/src/cuckoo_sys/plugins/CMakeLists.txt	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/cuckoo_sys/plugins/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
@@ -1,133 +0,0 @@
-cmake_minimum_required(VERSION 3.2)
-project (CuckooMinerPlugins)
-
-set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/plugins)
-set (CMAKE_CXX_FLAGS "--std=c++11")
-
-set (OPT "-O3")
-set (DOPT "-DPREFETCH")
-
-set (FLAGS "-Wno-format -Wno-deprecated-declarations -D_POSIX_C_SOURCE=200112L ${OPT} ${DOPT} -I. ${CPPFLAGS} -pthread")
-set (GPP_FLAGS "-march=native -m64 ${FLAGS}")
-set (CFLAGS "-Wno-format -fomit-frame-pointer ${OPT}")
-set (GCC_FLAGS "-m64 -std=gnu11 ${CFLAGS}")
-
-set (CUDA_HOST_COMPILER_OVERRIDE $ENV{CUDA_HOST_COMPILER})
-set (SKIP_CUCKATOO_GPU $ENV{SKIP_CUCKATOO_GPU})
-
-#blake2b prerequisite
-set (BLAKE_2B "cuckoo/src/crypto/blake2b-ref.c")
-
-#common to all plugins
-set (PLUGIN_BUILD_FLAGS "-DC_CALL_CONVENTION=1 -DSQUASH_OUTPUT=1")
-
-#build CPU target
-function (build_cpu_target sources target props)
-	add_library(${target} SHARED ${sources})
-	set_target_properties(${target} PROPERTIES COMPILE_FLAGS "${GPP_FLAGS} ${props} ${PLUGIN_BUILD_FLAGS}" PREFIX "" SUFFIX ".cuckooplugin")
-endfunction()
-
-function (build_cuda_target sources target props)
-	if (BUILD_CUDA_PLUGINS)
-		include("cmake/find_cuda.cmake")
-		if (CUDA_FOUND)
-			set (CUDA_PROPAGATE_HOST_FLAGS ON)
-			cuda_add_library (${target} SHARED ${sources} OPTIONS "${props} ${PLUGIN_BUILD_FLAGS}")
-			set_target_properties(${target} PROPERTIES PREFIX "" SUFFIX ".cuckooplugin")
-		endif (CUDA_FOUND)
-	endif (BUILD_CUDA_PLUGINS)
-endfunction()
-
-##################################################################################
-### CUCKATOO (Asic Tuned) ########################################################
-##################################################################################
-
-### AT LEAN CPU TARGETS  #########################################
-
-set (AT_LEAN_CPU_SRC
-			cuckoo/src/cuckatoo/cuckatoo.h
-			cuckoo/src/cuckatoo/bitmap.hpp
-			cuckoo/src/cuckatoo/graph.hpp
-			cuckoo/src/cuckatoo/compress.hpp
-			cuckoo/src/threads/barrier.hpp
-			cuckoo/src/crypto/siphash.hpp
-			cuckoo/src/cuckatoo/lean.hpp
-			cuckoo/src/cuckatoo/lean.cpp
-			${BLAKE_2B})
-
-build_cpu_target("${AT_LEAN_CPU_SRC}" cuckatoo_lean_cpu_compat_19 "-DNSIPHASH=1 -DATOMIC -DEDGEBITS=19")
-build_cpu_target("${AT_LEAN_CPU_SRC}" cuckatoo_lean_cpu_compat_31 "-mno-avx2 -DNSIPHASH=4 -DATOMIC -DEDGEBITS=31")
-build_cpu_target("${AT_LEAN_CPU_SRC}" cuckatoo_lean_cpu_avx2_31 "-mavx2 -DNSIPHASH=8 -DATOMIC -DEDGEBITS=31")
-
-### AT MEAN CPU TARGETS  #########################################
-
-set (AT_MEAN_CPU_SRC
-			cuckoo/src/cuckatoo/cuckatoo.h
-			cuckoo/src/cuckatoo/bitmap.hpp
-			cuckoo/src/cuckatoo/graph.hpp
-			cuckoo/src/cuckatoo/compress.hpp
-			cuckoo/src/threads/barrier.hpp
-			cuckoo/src/crypto/siphash.hpp
-			cuckoo/src/cuckatoo/mean.hpp
-			cuckoo/src/cuckatoo/mean.cpp
-			${BLAKE_2B})
-
-build_cpu_target("${AT_MEAN_CPU_SRC}" cuckatoo_mean_cpu_compat_19 "-DXBITS=2 -DNSIPHASH=1 -DSAVEEDGES -DEDGEBITS=19")
-build_cpu_target("${AT_MEAN_CPU_SRC}" cuckatoo_mean_cpu_avx2_19 "-mavx2 -DXBITS=2 -DNSIPHASH=8 -DSAVEEDGES -DEDGEBITS=19")
-build_cpu_target("${AT_MEAN_CPU_SRC}" cuckatoo_mean_cpu_compat_31 "-mno-avx2 -DXBITS=8 -DNSIPHASH=4 -DEXPANDROUND=8 -DCOMPRESSROUND=22 -DSAVEEDGES -DEDGEBITS=31")
-build_cpu_target("${AT_MEAN_CPU_SRC}" cuckatoo_mean_cpu_avx2_31 "-mavx2 -DXBITS=8 -DNSIPHASH=8 -DEXPANDROUND=8 -DCOMPRESSROUND=22 -DSAVEEDGES -DEDGEBITS=31")
-
-### AT LEAN CUDA TARGETS  #########################################
-
-set (AT_LEAN_CUDA_SRC
-			cuckoo/src/crypto/siphash.cuh
-			cuckoo/src/cuckatoo/lean.cu
-			${BLAKE_2B} )
-
-if (NOT SKIP_CUCKATOO_GPU)
-  build_cuda_target("${AT_LEAN_CUDA_SRC}" cuckatoo_lean_cuda_19 "-DEDGEBITS=19")
-  build_cuda_target("${AT_LEAN_CUDA_SRC}" cuckatoo_lean_cuda_31 "-DEDGEBITS=31")
-endif()
-
-### AT MEAN CUDA TARGETS  #########################################
-
-set (AT_MEAN_CUDA_SRC
-			cuckoo/src/crypto/siphash.cuh
-			cuckoo/src/cuckatoo/mean.cu
-			${BLAKE_2B} )
-
-if (NOT SKIP_CUCKATOO_GPU)
-  build_cuda_target("${AT_MEAN_CUDA_SRC}" cuckatoo_mean_cuda_19 "-DNEPS_A=512 -DNEPS_B=384 -DIDXSHIFT=6 -DEDGEBITS=19")
-  build_cuda_target("${AT_MEAN_CUDA_SRC}" cuckatoo_mean_cuda_rtx_31 "-DNEPS_A=128 -DNEPS_B=80 -DPART_BITS=0 -DEDGEBITS=31")
-  build_cuda_target("${AT_MEAN_CUDA_SRC}" cuckatoo_mean_cuda_gtx_31 "-DNEPS_A=130 -DNEPS_B=84 -DPART_BITS=1 -DEDGEBITS=31")
-endif()
-
-##################################################################################
-### CUCKAROO (Asic Resistant)  ###################################################
-##################################################################################
-
-### AR CPU BUILDING  #########################################
-
-set (AR_CPU_SRC
-			cuckoo/src/cuckaroo/cuckaroo.hpp
-			cuckoo/src/cuckaroo/bitmap.hpp
-			cuckoo/src/cuckaroo/graph.hpp
-			cuckoo/src/threads/barrier.hpp
-			cuckoo/src/crypto/siphash.hpp
-			cuckoo/src/cuckaroo/mean.hpp
-			cuckoo/src/cuckaroo/mean.cpp
-			${BLAKE_2B})
-
-### AR CPU TARGETS #########################################
-
-build_cpu_target("${AR_CPU_SRC}" cuckaroo_cpu_compat_19 "-DXBITS=2 -DNSIPHASH=1 -DEDGEBITS=19 -DSAVEEDGES")
-build_cpu_target("${AR_CPU_SRC}" cuckaroo_cpu_avx2_19 "-mavx2 -DXBITS=2 -DNSIPHASH=8 -DEDGEBITS=19 -DSAVEEDGES")
-build_cpu_target("${AR_CPU_SRC}" cuckaroo_cpu_compat_29 "-mno-avx2 -DNSIPHASH=4 -DEDGEBITS=29 -DSAVEEDGES")
-build_cpu_target("${AR_CPU_SRC}" cuckaroo_cpu_avx2_29 "-mavx2 -DNSIPHASH=8 -DEDGEBITS=29 -DSAVEEDGES")
-
-### AR CUDA TARGETS #########################################
-
-set (AR_CUDA_SRC cuckoo/src/cuckaroo/mean.cu ${BLAKE_2B} )
-
-build_cuda_target("${AR_CUDA_SRC}" cuckaroo_cuda_19 "-DEPS_A=4 -DEPS_B=3 -DIDXSHIFT=2 -DEDGEBITS=19")
-build_cuda_target("${AR_CUDA_SRC}" cuckaroo_cuda_29 "-DEDGEBITS=29")
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/error/error.rs grin-miner-copy/cuckoo-miner/src/error/error.rs
--- grin-miner-1.0.2/cuckoo-miner/src/error/error.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/error/error.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,70 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Common error type used by all cuckoo-miner modules, as well as any exernal
-//! consumers of the cuckoo-miner crate.
-
-use std::io;
-use std::string;
-
-/// #Description
-///
-/// Top level enum for all errors that the cuckoo-miner crate can return.
-///
-
-#[derive(Debug)]
-pub enum CuckooMinerError {
-	/// Occurs when trying to call a plugin function when a
-	/// mining plugin is not loaded.
-	PluginNotLoadedError(String),
-
-	/// Occurs when trying to load plugin function that doesn't exist
-	PluginSymbolNotFoundError(String),
-
-	/// Occurs when attempting to load a plugin that doesn't exist
-	PluginNotFoundError(String),
-
-	/// Occurs when trying to load a plugin directory that doesn't
-	/// contain any plugins
-	NoPluginsFoundError(String),
-
-	/// Unexpected return code from a plugin
-	UnexpectedResultError(u32),
-
-	/// Error setting a parameter
-	ParameterError(String),
-
-	/// IO Error
-	PluginIOError(String),
-
-	/// Plugin processing can't start
-	PluginProcessingError(String),
-
-	/// Error getting stats or stats not implemented
-	StatsError(String),
-}
-
-impl From<io::Error> for CuckooMinerError {
-	fn from(error: io::Error) -> Self {
-		CuckooMinerError::PluginIOError(String::from(format!("Error loading plugin: {}", error)))
-	}
-}
-
-impl From<string::FromUtf8Error> for CuckooMinerError {
-	fn from(error: string::FromUtf8Error) -> Self {
-		CuckooMinerError::PluginIOError(String::from(
-			format!("Error loading plugin description: {}", error),
-		))
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/error/mod.rs grin-miner-copy/cuckoo-miner/src/error/mod.rs
--- grin-miner-1.0.2/cuckoo-miner/src/error/mod.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/error/mod.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Simple crate which just contains cuckoo-miner's error enum, used by
-//! all other internal crates.
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-pub mod error;
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/lib.rs grin-miner-copy/cuckoo-miner/src/lib.rs
--- grin-miner-1.0.2/cuckoo-miner/src/lib.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/lib.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,60 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! # Overview
-//!
-//! <b>cuckoo-miner</b> is a Rust wrapper around John Tromp's Cuckoo Miner
-//! C implementations, intended primarily for use in the Grin MimbleWimble
-//! blockhain development project. However, it is also suitable for use as
-//! a standalone miner or by any other project needing to use the
-//! cuckoo cycle proof of work. cuckoo-miner is plugin based, and provides
-//! a high level interface to load and work with C mining implementations.
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-extern crate grin_miner_plugin as plugin;
-extern crate grin_miner_util as util;
-
-extern crate serde;
-#[macro_use]
-extern crate serde_derive;
-extern crate serde_json;
-
-extern crate blake2_rfc as blake2;
-extern crate byteorder;
-extern crate crypto;
-extern crate rand;
-extern crate regex;
-
-extern crate libc;
-extern crate libloading as libloading;
-
-#[macro_use]
-extern crate slog;
-
-extern crate glob;
-
-mod config;
-mod cuckoo_sys;
-mod error;
-mod miner;
-
-pub use config::types::PluginConfig;
-pub use cuckoo_sys::ffi::PluginLibrary;
-pub use error::error::CuckooMinerError;
-pub use miner::miner::CuckooMiner;
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/miner/consensus.rs grin-miner-copy/cuckoo-miner/src/miner/consensus.rs
--- grin-miner-1.0.2/cuckoo-miner/src/miner/consensus.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/miner/consensus.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,285 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-/// Difficulty calculation as from Grin
-
-use blake2::blake2b::Blake2b;
-use std::cmp::{max, min};
-use std::fmt;
-use byteorder::{BigEndian, ByteOrder};
-
-// constants from grin
-const DEFAULT_MIN_EDGE_BITS: u8 = 31;
-const SECOND_POW_EDGE_BITS: u8 = 29;
-const PROOF_SIZE: usize = 42;
-const BLOCK_TIME_SEC: u64 = 60;
-
-const HOUR_HEIGHT: u64 = 3600 / BLOCK_TIME_SEC;
-const DAY_HEIGHT: u64 = 24 * HOUR_HEIGHT;
-const WEEK_HEIGHT: u64 = 7 * DAY_HEIGHT;
-const YEAR_HEIGHT: u64 = 52 * WEEK_HEIGHT;
-
-const BASE_EDGE_BITS: u8 = 24;
-
-/// Compute weight of a graph as number of siphash bits defining the graph
-/// Must be made dependent on height to phase out smaller size over the years
-/// This can wait until end of 2019 at latest
-pub fn graph_weight(height: u64, edge_bits: u8) -> u64 {
-	let mut xpr_edge_bits = edge_bits as u64;
-
-	let bits_over_min = edge_bits.saturating_sub(DEFAULT_MIN_EDGE_BITS);
-	let expiry_height = (1 << bits_over_min) * YEAR_HEIGHT;
-	if height >= expiry_height {
-		xpr_edge_bits = xpr_edge_bits.saturating_sub(1 + (height - expiry_height) / WEEK_HEIGHT);
-	}
-
-	(2 << (edge_bits - BASE_EDGE_BITS) as u64) * xpr_edge_bits
-}
-
-/// The difficulty is defined as the maximum target divided by the block hash.
-#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord)]
-pub struct Difficulty {
-	num: u64,
-}
-
-impl Difficulty {
-	/// Convert a `u32` into a `Difficulty`
-	pub fn from_num(num: u64) -> Difficulty {
-		// can't have difficulty lower than 1
-		Difficulty { num: max(num, 1) }
-	}
-
-	/// Computes the difficulty from a hash. Divides the maximum target by the
-	/// provided hash and applies the Cuck(at)oo size adjustment factor (see
-	/// https://lists.launchpad.net/mimblewimble/msg00494.html).
-	fn from_proof_adjusted(height: u64, proof: &Proof) -> Difficulty {
-		// scale with natural scaling factor
-		Difficulty::from_num(proof.scaled_difficulty(graph_weight(height, proof.edge_bits)))
-	}
-
-	/// unscaled proof
-	fn from_proof_unscaled(proof: &Proof) -> Difficulty {
-		Difficulty::from_num(proof.scaled_difficulty(1u64))
-	}
-
-	/// Same as `from_proof_adjusted` but instead of an adjustment based on
-	/// cycle size, scales based on a provided factor. Used by dual PoW system
-	/// to scale one PoW against the other.
-	fn from_proof_scaled(proof: &Proof, scaling: u32) -> Difficulty {
-		// Scaling between 2 proof of work algos
-		Difficulty::from_num(proof.scaled_difficulty(scaling as u64))
-	}
-
-	/// Converts the difficulty into a u64
-	pub fn to_num(&self) -> u64 {
-		self.num
-	}
-}
-
-impl fmt::Display for Difficulty {
-	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-		write!(f, "{}", self.num)
-	}
-}
-
-/// A Cuck(at)oo Cycle proof of work, consisting of the edge_bits to get the graph
-/// size (i.e. the 2-log of the number of edges) and the nonces
-/// of the graph solution. While being expressed as u64 for simplicity,
-/// nonces a.k.a. edge indices range from 0 to (1 << edge_bits) - 1
-///
-/// The hash of the `Proof` is the hash of its packed nonces when serializing
-/// them at their exact bit size. The resulting bit sequence is padded to be
-/// byte-aligned.
-
-#[derive(Clone, PartialOrd, PartialEq)]
-pub struct Proof {
-	/// Power of 2 used for the size of the cuckoo graph
-	pub edge_bits: u8,
-	/// The nonces
-	pub nonces: Vec<u64>,
-}
-
-impl fmt::Debug for Proof {
-	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-		write!(f, "Cuckoo{}(", self.edge_bits)?;
-		for (i, val) in self.nonces[..].iter().enumerate() {
-			write!(f, "{:x}", val)?;
-			if i < self.nonces.len() - 1 {
-				write!(f, " ")?;
-			}
-		}
-		write!(f, ")")
-	}
-}
-
-impl Eq for Proof {}
-
-impl Proof {
-	/// Builds a proof with provided nonces at default edge_bits
-	pub fn new(mut in_nonces: Vec<u64>, edge_bits: u8) -> Proof {
-		in_nonces.sort();
-		Proof {
-			edge_bits: edge_bits,
-			nonces: in_nonces,
-		}
-	}
-
-	/// Difficulty achieved by this proof with given scaling factor
-	fn scaled_difficulty(&self, scale: u64) -> u64 {
-		let diff = ((scale as u128) << 64) / (max(1, self.hash().to_u64()) as u128);
-		min(diff, <u64>::max_value() as u128) as u64
-	}
-
-	/// Hash, as in Grin
-	fn hash(&self) -> Hash {
-		let nonce_bits = self.edge_bits as usize;
-		let mut bitvec = BitVec::new(nonce_bits * PROOF_SIZE);
-		for (n, nonce) in self.nonces.iter().enumerate() {
-			for bit in 0..nonce_bits {
-				if nonce & (1 << bit) != 0 {
-					bitvec.set_bit_at(n * nonce_bits + (bit as usize))
-				}
-			}
-		}
-		let mut blake2b = Blake2b::new(32);
-		blake2b.update(&bitvec.bits);
-		let mut ret = [0; 32];
-		ret.copy_from_slice(blake2b.finalize().as_bytes());
-		Hash(ret)
-	}
-
-	/// Maximum difficulty this proof of work can achieve
-	pub fn to_difficulty(&self, height: u64, sec_scaling: u32) -> Difficulty {
-		// 2 proof of works, Cuckoo29 (for now) and Cuckoo30+, which are scaled
-		// differently (scaling not controlled for now)
-		if self.edge_bits == SECOND_POW_EDGE_BITS {
-			Difficulty::from_proof_scaled(&self, sec_scaling)
-		} else {
-			Difficulty::from_proof_adjusted(height, &self)
-		}
-	}
-
-	/// unscaled difficulty
-	pub fn to_difficulty_unscaled(&self) -> Difficulty {
-		Difficulty::from_proof_unscaled(&self)
-	}
-}
-
-struct BitVec {
-	bits: Vec<u8>,
-}
-
-impl BitVec {
-	/// Number of bytes required to store the provided number of bits
-	fn bytes_len(bits_len: usize) -> usize {
-		(bits_len + 7) / 8
-	}
-
-	fn new(bits_len: usize) -> BitVec {
-		BitVec {
-			bits: vec![0; BitVec::bytes_len(bits_len)],
-		}
-	}
-
-	fn set_bit_at(&mut self, pos: usize) {
-		self.bits[pos / 8] |= 1 << (pos % 8) as u8;
-	}
-}
-
-impl Hash {
-	/// to u64
-	pub fn to_u64(&self) -> u64 {
-		BigEndian::read_u64(&self.0)
-	}
-
-	/// to hex
-	pub fn to_hex(&self) -> String {
-		util::to_hex(self.0.to_vec())
-	}
-}
-
-/// A hash to uniquely (or close enough) identify one of the main blockchain
-/// constructs. Used pervasively for blocks, transactions and outputs.
-#[derive(Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Serialize, Deserialize)]
-pub struct Hash([u8; 32]);
-
-impl fmt::Debug for Hash {
-	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-		let hash_hex = self.to_hex();
-		const NUM_SHOW: usize = 12;
-
-		write!(f, "{}", &hash_hex[..NUM_SHOW])
-	}
-}
-
-impl fmt::Display for Hash {
-	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-		fmt::Debug::fmt(self, f)
-	}
-}
-
-
-#[cfg(test)]
-mod tests {
-	use super::*;
-
-	#[test]
-	fn proof_hash() {
-		let mut in_nonces: Vec<u64> = [0u64; 42].to_vec(); 
-		let proof = Proof::new(in_nonces.clone(), DEFAULT_MIN_EDGE_BITS);
-		let hash_str = format!("{}", proof.hash());
-		println!("Hash is: {}", hash_str);
-		assert_eq!(&hash_str, "5fa5af8a4c86");
-
-		in_nonces[41] = 23402320128419283;
-		in_nonces[11] = 81239481234781924;
-		let proof = Proof::new(in_nonces.clone(), DEFAULT_MIN_EDGE_BITS);
-		let hash_str = format!("{}", proof.hash());
-		println!("Hash is: {}", hash_str);
-		assert_eq!(&hash_str, "378594bac9a4");
-
-		for i in in_nonces.iter_mut() {
-			*i = std::u64::MAX;
-		}
-		let proof = Proof::new(in_nonces.clone(), DEFAULT_MIN_EDGE_BITS);
-		let hash_str = format!("{}", proof.hash());
-		println!("Hash is: {}", hash_str);
-		assert_eq!(&hash_str, "99f04aafcbc1");
-	}
-
-	#[test]
-	fn proof_difficulty() {
-		let mut in_nonces: Vec<u64> = [0u64; 42].to_vec();
-		let proof = Proof::new(in_nonces.clone(), DEFAULT_MIN_EDGE_BITS);
-		let difficulty = proof.to_difficulty(20, 1);
-		println!("Diff is: {}", difficulty);
-		assert_eq!(difficulty, Difficulty::from_num(21240));
-
-		in_nonces[41] = 23402320128419283;
-		in_nonces[11] = 81239481234781924;
-		let proof = Proof::new(in_nonces.clone(), 31);
-		let difficulty = proof.to_difficulty(120000, 32348);
-		println!("Diff is: {}", difficulty);
-		assert_eq!(difficulty, Difficulty::from_num(36591));
-
-		for i in in_nonces.iter_mut() {
-			*i = std::u64::MAX;
-		}
-		let proof = Proof::new(in_nonces.clone(), 35);
-		let difficulty = proof.to_difficulty(1300000, 92348);
-		println!("Diff is: {}", difficulty);
-		assert_eq!(difficulty, Difficulty::from_num(296303));
-	}
-}
-
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/miner/miner.rs grin-miner-copy/cuckoo-miner/src/miner/miner.rs
--- grin-miner-1.0.2/cuckoo-miner/src/miner/miner.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/miner/miner.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,353 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Main interface for callers into cuckoo-miner. Provides functionality
-//! to load a mining plugin, send it a Cuckoo Cycle POW problem, and
-//! return any resulting solutions.
-
-use std::ptr::NonNull;
-use std::sync::{mpsc, Arc, RwLock};
-use std::{thread, time};
-use util::LOGGER;
-
-use config::types::PluginConfig;
-use miner::types::{JobSharedData, JobSharedDataType, SolverInstance};
-
-use miner::util;
-use miner::consensus::Proof;
-use plugin::{SolverCtxWrapper, SolverSolutions, Solution, SolverStats};
-use {CuckooMinerError, PluginLibrary};
-
-/// Miner control Messages
-#[derive(Debug)]
-enum ControlMessage {
-	/// Stop everything, pull down, exis
-	Stop,
-	/// Stop current mining iteration, set solver threads to paused
-	Pause,
-	/// Resume
-	Resume,
-	/// Solver reporting stopped
-	SolverStopped(usize),
-}
-
-/// An instance of a miner, which loads a cuckoo-miner plugin
-/// and calls its mine function according to the provided configuration
-
-pub struct CuckooMiner {
-	/// Configurations
-	configs: Vec<PluginConfig>,
-
-	/// Data shared across threads
-	pub shared_data: Arc<RwLock<JobSharedData>>,
-
-	/// Job control tx
-	control_txs: Vec<mpsc::Sender<ControlMessage>>,
-
-	/// solver loop tx
-	solver_loop_txs: Vec<mpsc::Sender<ControlMessage>>,
-
-	/// Solver has stopped and cleanly shutdown
-	solver_stopped_rxs: Vec<mpsc::Receiver<ControlMessage>>,
-}
-
-impl CuckooMiner {
-	/// Creates a new instance of a CuckooMiner with the given configuration.
-	/// One PluginConfig per device
-
-	pub fn new(configs: Vec<PluginConfig>) -> CuckooMiner {
-		let len = configs.len();
-		CuckooMiner {
-			configs: configs,
-			shared_data: Arc::new(RwLock::new(JobSharedData::new(len))),
-			control_txs: vec![],
-			solver_loop_txs: vec![],
-			solver_stopped_rxs: vec![],
-		}
-	}
-
-	/// Solver's instance of a thread
-	fn solver_thread(
-		mut solver: SolverInstance,
-		instance: usize,
-		shared_data: JobSharedDataType,
-		control_rx: mpsc::Receiver<ControlMessage>,
-		solver_loop_rx: mpsc::Receiver<ControlMessage>,
-		solver_stopped_tx: mpsc::Sender<ControlMessage>,
-	) {
-		{
-			let mut s = shared_data.write().unwrap();
-			s.stats[instance].set_plugin_name(&solver.config.name);
-		}
-		// "Detach" a stop function from the solver, to let us keep a control thread going
-		let ctx = solver.lib.create_solver_ctx(&mut solver.config.params);
-		let control_ctx = SolverCtxWrapper(NonNull::new(ctx).unwrap());
-
-		let stop_fn = solver.lib.get_stop_solver_instance();
-
-		// monitor whether to send a stop signal to the solver, which should
-		// end the current solve attempt below
-		let stop_handle = thread::spawn(move || loop {
-			let ctx_ptr = control_ctx.0.as_ptr();
-			while let Some(message) = control_rx.iter().next() {
-				match message {
-					ControlMessage::Stop => {
-						PluginLibrary::stop_solver_from_instance(stop_fn.clone(), ctx_ptr);
-						return;
-					}
-					ControlMessage::Pause => {
-						PluginLibrary::stop_solver_from_instance(stop_fn.clone(), ctx_ptr);
-					}
-					_ => {}
-				};
-			}
-		});
-
-		let mut iter_count = 0;
-		let mut paused = true;
-		loop {
-			if let Some(message) = solver_loop_rx.try_iter().next() {
-				debug!(LOGGER, "solver_thread - solver_loop_rx got msg: {:?}", message);
-				match message {
-					ControlMessage::Stop => break,
-					ControlMessage::Pause => paused = true,
-					ControlMessage::Resume => paused = false,
-					_ => {}
-				}
-			}
-			if paused {
-				thread::sleep(time::Duration::from_micros(100));
-				continue;
-			}
-			{
-				let mut s = shared_data.write().unwrap();
-				s.stats[instance].set_plugin_name(&solver.config.name);
-			}
-			let header_pre = { shared_data.read().unwrap().pre_nonce.clone() };
-			let header_post = { shared_data.read().unwrap().post_nonce.clone() };
-			let height = { shared_data.read().unwrap().height.clone() };
-			let job_id = { shared_data.read().unwrap().job_id.clone() };
-			let target_difficulty = { shared_data.read().unwrap().difficulty.clone() };
-			let header = util::get_next_header_data(&header_pre, &header_post);
-			let nonce = header.0;
-			//let sec_scaling = header.2;
-			solver.lib.run_solver(
-				ctx,
-				header.1,
-				0,
-				1,
-				&mut solver.solutions,
-				&mut solver.stats,
-			);
-			iter_count += 1;
-			let still_valid = { height == shared_data.read().unwrap().height };
-			if still_valid {
-				let mut s = shared_data.write().unwrap();
-				s.stats[instance] = solver.stats.clone();
-				s.stats[instance].iterations = iter_count;
-				if solver.solutions.num_sols > 0 {
-					// Filter solutions that don't meet difficulty check
-					let mut filtered_sols:Vec<Solution> = vec![];
-					for i in 0..solver.solutions.num_sols {
-						filtered_sols.push(solver.solutions.sols[i as usize]);
-					}
-					let mut filtered_sols: Vec<Solution> = filtered_sols.iter()
-						.filter(|s| {
-							let proof = Proof {
-								edge_bits: solver.solutions.edge_bits as u8,
-								nonces: s.proof.to_vec(),
-							};
-							proof.to_difficulty_unscaled().to_num() >= target_difficulty
-						})
-						.map(|s| {
-							s.clone()
-						})
-						.collect();
-					for mut ss in filtered_sols.iter_mut() {
-						ss.nonce = nonce;
-						ss.id = job_id as u64;
-					}
-					solver.solutions.num_sols = filtered_sols.len() as u32;
-					for i in 0..solver.solutions.num_sols as usize {
-						solver.solutions.sols[i] = filtered_sols[i];
-					}
-					s.solutions.push(solver.solutions.clone());
-				}
-				if s.stats[instance].has_errored {
-					s.stats[instance].set_plugin_name(&solver.config.name);
-					error!(
-						LOGGER,
-						"Plugin {} has errored, device: {}. Reason: {}",
-						s.stats[instance].get_plugin_name(),
-						s.stats[instance].get_device_name(),
-						s.stats[instance].get_error_reason(),
-					);
-					break;
-				}
-			}
-			solver.solutions = SolverSolutions::default();
-			thread::sleep(time::Duration::from_micros(100));
-		}
-
-		let _ = stop_handle.join();
-		solver.lib.destroy_solver_ctx(ctx);
-		solver.unload();
-		let _ = solver_stopped_tx.send(ControlMessage::SolverStopped(instance));
-	}
-
-	/// Starts solvers, ready for jobs via job control
-	pub fn start_solvers(&mut self) -> Result<(), CuckooMinerError> {
-		let mut solvers = Vec::new();
-		for c in self.configs.clone() {
-			solvers.push(SolverInstance::new(c)?);
-		}
-		let mut i = 0;
-		for s in solvers {
-			let sd = self.shared_data.clone();
-			let (control_tx, control_rx) = mpsc::channel::<ControlMessage>();
-			let (solver_tx, solver_rx) = mpsc::channel::<ControlMessage>();
-			let (solver_stopped_tx, solver_stopped_rx) = mpsc::channel::<ControlMessage>();
-			self.control_txs.push(control_tx);
-			self.solver_loop_txs.push(solver_tx);
-			self.solver_stopped_rxs.push(solver_stopped_rx);
-			thread::spawn(move || {
-				let _ =
-					CuckooMiner::solver_thread(s, i, sd, control_rx, solver_rx, solver_stopped_tx);
-			});
-			i += 1;
-		}
-		Ok(())
-	}
-
-	/// An asynchronous -esque version of the plugin miner, which takes
-	/// parts of the header and the target difficulty as input, and begins
-	/// asyncronous processing to find a solution. The loaded plugin is
-	/// responsible
-	/// for how it wishes to manage processing or distribute the load. Once
-	/// called
-	/// this function will continue to find solutions over the target difficulty
-	/// for the given inputs and place them into its output queue until
-	/// instructed to stop.
-
-	pub fn notify(
-		&mut self,
-		job_id: u32,      // Job id
-		height: u64,      // Job height
-		pre_nonce: &str,  // Pre-nonce portion of header
-		post_nonce: &str, // Post-nonce portion of header
-		difficulty: u64,  /* The target difficulty, only sols greater than this difficulty will
-		                   * be returned. */
-	) -> Result<(), CuckooMinerError> {
-		let mut sd = self.shared_data.write().unwrap();
-		let mut paused = false;
-		if height != sd.height {
-			// stop/pause any existing jobs if job is for a new
-			// height
-			self.pause_solvers();
-			paused = true;
-		}
-		sd.job_id = job_id;
-		sd.height = height;
-		sd.pre_nonce = pre_nonce.to_owned();
-		sd.post_nonce = post_nonce.to_owned();
-		sd.difficulty = difficulty;
-		if paused {
-			self.resume_solvers();
-		}
-		Ok(())
-	}
-
-	/// Returns solutions if currently waiting.
-
-	pub fn get_solutions(&self) -> Option<SolverSolutions> {
-		// just to prevent endless needless locking of this
-		// when using fast test miners, in real cuckoo30 terms
-		// this shouldn't be an issue
-		// TODO: Make this less blocky
-		// let time_pre_lock=Instant::now();
-		{
-			let mut s = self.shared_data.write().unwrap();
-			// let time_elapsed=Instant::now()-time_pre_lock;
-			// println!("Get_solution Time spent waiting for lock: {}",
-			// time_elapsed.as_secs()*1000 +(time_elapsed.subsec_nanos()/1_000_000)as u64);
-			if s.solutions.len() > 0 {
-				let sol = s.solutions.pop().unwrap();
-				return Some(sol);
-			}
-		}
-		None
-	}
-
-	/// get stats for all running solvers
-	pub fn get_stats(&self) -> Result<Vec<SolverStats>, CuckooMinerError> {
-		let s = self.shared_data.read().unwrap();
-		Ok(s.stats.clone())
-	}
-
-	/// #Description
-	///
-	/// Stops the current job, and signals for the loaded plugin to stop
-	/// processing and perform any cleanup it needs to do.
-	///
-	/// #Returns
-	///
-	/// Nothing
-
-	pub fn stop_solvers(&self) {
-		for t in self.control_txs.iter() {
-			let _ = t.send(ControlMessage::Stop);
-		}
-		for t in self.solver_loop_txs.iter() {
-			let _ = t.send(ControlMessage::Stop);
-		}
-		debug!(LOGGER, "Stop message sent");
-	}
-
-	/// Tells current solvers to stop and wait
-	pub fn pause_solvers(&self) {
-		for t in self.control_txs.iter() {
-			let _ = t.send(ControlMessage::Pause);
-		}
-		for t in self.solver_loop_txs.iter() {
-			let _ = t.send(ControlMessage::Pause);
-		}
-		debug!(LOGGER, "Pause message sent");
-	}
-
-	/// Tells current solvers to stop and wait
-	pub fn resume_solvers(&self) {
-		for t in self.control_txs.iter() {
-			let _ = t.send(ControlMessage::Resume);
-		}
-		for t in self.solver_loop_txs.iter() {
-			let _ = t.send(ControlMessage::Resume);
-		}
-		debug!(LOGGER, "Resume message sent");
-	}
-
-	/// block until solvers have all exited
-	pub fn wait_for_solver_shutdown(&self) {
-		for r in self.solver_stopped_rxs.iter() {
-			while let Some(message) = r.iter().next() {
-				match message {
-					ControlMessage::SolverStopped(i) => {
-						debug!(LOGGER, "Solver stopped: {}", i);
-						break;
-					}
-					_ => {}
-				}
-			}
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/miner/mod.rs grin-miner-copy/cuckoo-miner/src/miner/mod.rs
--- grin-miner-1.0.2/cuckoo-miner/src/miner/mod.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/miner/mod.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! The main miner module of cuckoo-miner, which provides an interface
-//! for loading a mining plugin and performing a cuckoo mining call.
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-pub mod miner;
-pub mod types;
-pub mod util;
-pub mod consensus;
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/miner/types.rs grin-miner-copy/cuckoo-miner/src/miner/types.rs
--- grin-miner-1.0.2/cuckoo-miner/src/miner/types.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/miner/types.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,107 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Miner types
-use std::sync::{Arc, RwLock};
-
-use plugin::{SolverSolutions, SolverStats};
-use CuckooMinerError;
-use {PluginConfig, PluginLibrary};
-
-pub type JobSharedDataType = Arc<RwLock<JobSharedData>>;
-
-/// Holds a loaded lib + config + stats
-/// 1 instance = 1 device on 1 controlling thread
-pub struct SolverInstance {
-	/// The loaded plugin
-	pub lib: PluginLibrary,
-	/// Associated config
-	pub config: PluginConfig,
-	/// Last stats output
-	pub stats: SolverStats,
-	/// Last solution output
-	pub solutions: SolverSolutions,
-}
-
-impl SolverInstance {
-	/// Create a new solver instance with the given config
-	pub fn new(config: PluginConfig) -> Result<SolverInstance, CuckooMinerError> {
-		let l = PluginLibrary::new(&config.file)?;
-		Ok(SolverInstance {
-			lib: l,
-			config: config,
-			stats: SolverStats::default(),
-			solutions: SolverSolutions::default(),
-		})
-	}
-
-	/// Release the lib
-	pub fn unload(&mut self) {
-		self.lib.unload();
-	}
-}
-
-/// Data intended to be shared across threads
-pub struct JobSharedData {
-	/// ID of the current running job (not currently used)
-	pub job_id: u32,
-
-	/// block height of current running job
-	pub height: u64,
-
-	/// The part of the header before the nonce, which this
-	/// module will mutate in search of a solution
-	pub pre_nonce: String,
-
-	/// The part of the header after the nonce
-	pub post_nonce: String,
-
-	/// The target difficulty. Only solutions >= this
-	/// target will be put into the output queue
-	pub difficulty: u64,
-
-	/// Output solutions
-	pub solutions: Vec<SolverSolutions>,
-
-	/// Current stats
-	pub stats: Vec<SolverStats>,
-}
-
-impl Default for JobSharedData {
-	fn default() -> JobSharedData {
-		JobSharedData {
-			job_id: 0,
-			height: 0,
-			pre_nonce: String::from(""),
-			post_nonce: String::from(""),
-			difficulty: 0,
-			solutions: Vec::new(),
-			stats: vec![],
-		}
-	}
-}
-
-impl JobSharedData {
-	pub fn new(num_solvers: usize) -> JobSharedData {
-		JobSharedData {
-			job_id: 0,
-			height: 0,
-			pre_nonce: String::from(""),
-			post_nonce: String::from(""),
-			difficulty: 1,
-			solutions: Vec::new(),
-			stats: vec![SolverStats::default(); num_solvers],
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/miner/util.rs grin-miner-copy/cuckoo-miner/src/miner/util.rs
--- grin-miner-1.0.2/cuckoo-miner/src/miner/util.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/miner/util.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,56 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! header manipulation utility functions
-
-use byteorder::{BigEndian, ByteOrder};
-use rand::{self, Rng};
-
-pub fn header_data(pre_nonce: &str, post_nonce: &str, nonce: u64) -> (Vec<u8>, u32) {
-	// Turn input strings into vectors
-	let mut pre_vec = from_hex_string(pre_nonce);
-	let mut post_vec = from_hex_string(post_nonce);
-
-	let sec_scaling_bytes = &pre_vec.clone()[pre_vec.len()-4..pre_vec.len()];
-	let sec_scaling = BigEndian::read_u32(&sec_scaling_bytes);
-
-	let mut nonce_bytes = [0; 8];
-	BigEndian::write_u64(&mut nonce_bytes, nonce);
-	let mut nonce_vec = nonce_bytes.to_vec();
-
-	// Generate new header
-	pre_vec.append(&mut nonce_vec);
-	pre_vec.append(&mut post_vec);
-
-	(pre_vec, sec_scaling)
-}
-
-pub fn get_next_header_data(pre_nonce: &str, post_nonce: &str) -> (u64, Vec<u8>, u32) {
-	let nonce: u64 = rand::OsRng::new().unwrap().gen();
-	let (hd, sec_scaling) = header_data(pre_nonce, post_nonce, nonce);
-	(nonce, hd, sec_scaling)
-}
-
-/// Helper to convert a hex string
-pub fn from_hex_string(in_str: &str) -> Vec<u8> {
-	let mut bytes = Vec::new();
-	for i in 0..(in_str.len() / 2) {
-		let res = u8::from_str_radix(&in_str[2 * i..2 * i + 2], 16);
-		match res {
-			Ok(v) => bytes.push(v),
-			Err(e) => println!("Problem with hex: {}", e),
-		}
-	}
-	bytes
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/src/sanity.rs grin-miner-copy/cuckoo-miner/src/sanity.rs
--- grin-miner-1.0.2/cuckoo-miner/src/sanity.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/src/sanity.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,222 +0,0 @@
-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT
-// file at the top-level directory of this distribution and at
-// http://rust-lang.org/COPYRIGHT.
-//
-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
-// option. This file may not be copied, modified, or distributed
-// except according to those terms.
-
-//! Sanity check for environment before attempting to run cmake build
-//! shamelessly adapted from:
-//! https://raw.githubusercontent.
-//! com/rust-lang/rust/master/src/bootstrap/sanity.rs
-//! more of this will be adapted later
-
-use std::collections::HashMap;
-use std::env;
-use std::ffi::{OsString, OsStr};
-// use std::fs;
-// use std::process::Command;
-use std::path::PathBuf;
-
-// use build_helper::output;
-
-// use Build;
-
-pub struct Finder {
-	cache: HashMap<OsString, Option<PathBuf>>,
-	path: OsString,
-}
-
-impl Finder {
-	pub fn new() -> Self {
-		Self {
-			cache: HashMap::new(),
-			path: env::var_os("PATH").unwrap_or_default(),
-		}
-	}
-
-	pub fn maybe_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> Option<PathBuf> {
-		let cmd: OsString = cmd.as_ref().into();
-		let path = self.path.clone();
-		self.cache
-			.entry(cmd.clone())
-			.or_insert_with(|| {
-				for path in env::split_paths(&path) {
-					let target = path.join(&cmd);
-					let mut cmd_alt = cmd.clone();
-					cmd_alt.push(".exe");
-					if target.is_file() || // some/path/git
-                target.with_extension("exe").exists() || // some/path/git.exe
-                target.join(&cmd_alt).exists()
-					{
-						// some/path/git/git.exe
-						return Some(target);
-					}
-				}
-				None
-			})
-			.clone()
-	}
-
-	/*pub fn must_have<S: AsRef<OsStr>>(&mut self, cmd: S) -> PathBuf {
-        self.maybe_have(&cmd).unwrap_or_else(|| {
-            panic!("\n\ncouldn't find required command: {:?}\n\n", cmd.as_ref());
-        })
-    }*/
-}
-
-// Just use finder for now
-
-/*pub fn check(build: &mut Build) {
-    let path = env::var_os("PATH").unwrap_or_default();
-    // On Windows, quotes are invalid characters for filename paths, and if
-    // one is present as part of the PATH then that can lead to the system
-    // being unable to identify the files properly. See
-    // https://github.com/rust-lang/rust/issues/34959 for more details.
-    if cfg!(windows) && path.to_string_lossy().contains("\"") {
-        panic!("PATH contains invalid character '\"'");
-    }
-
-    let mut cmd_finder = Finder::new();
-    // If we've got a git directory we're gona need git to update
-    // submodules and learn about various other aspects.
-    if build.rust_info.is_git() {
-        cmd_finder.must_have("git");
-    }
-
-    // We need cmake, but only if we're actually building LLVM or sanitizers.
-    let building_llvm = build.hosts.iter()
-        .filter_map(|host| build.config.target_config.get(host))
-        .any(|config| config.llvm_config.is_none());
-    if building_llvm || build.config.sanitizers {
-        cmd_finder.must_have("cmake");
-    }
-
-    // Ninja is currently only used for LLVM itself.
-    // Some Linux distros rename `ninja` to `ninja-build`.
-    // CMake can work with either binary name.
-    if building_llvm && build.config.ninja && cmd_finder.maybe_have("ninja-build").is_none() {
-        cmd_finder.must_have("ninja");
-    }
-
-    build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))
-        .or_else(|| env::var_os("BOOTSTRAP_PYTHON").map(PathBuf::from)) // set by bootstrap.py
-        .or_else(|| cmd_finder.maybe_have("python2.7"))
-        .or_else(|| cmd_finder.maybe_have("python2"))
-        .or_else(|| Some(cmd_finder.must_have("python")));
-
-    build.config.nodejs = build.config.nodejs.take().map(|p| cmd_finder.must_have(p))
-        .or_else(|| cmd_finder.maybe_have("node"))
-        .or_else(|| cmd_finder.maybe_have("nodejs"));
-
-    build.config.gdb = build.config.gdb.take().map(|p| cmd_finder.must_have(p))
-        .or_else(|| cmd_finder.maybe_have("gdb"));
-
-    // We're gonna build some custom C code here and there, host triples
-    // also build some C++ shims for LLVM so we need a C++ compiler.
-    for target in &build.targets {
-        // On emscripten we don't actually need the C compiler to just
-        // build the target artifacts, only for testing. For the sake
-        // of easier bot configuration, just skip detection.
-        if target.contains("emscripten") {
-            continue;
-        }
-
-        cmd_finder.must_have(build.cc(*target));
-        if let Some(ar) = build.ar(*target) {
-            cmd_finder.must_have(ar);
-        }
-    }
-
-    for host in &build.hosts {
-        cmd_finder.must_have(build.cxx(*host).unwrap());
-
-        // The msvc hosts don't use jemalloc, turn it off globally to
-        // avoid packaging the dummy liballoc_jemalloc on that platform.
-        if host.contains("msvc") {
-            build.config.use_jemalloc = false;
-        }
-    }
-
-    // Externally configured LLVM requires FileCheck to exist
-    let filecheck = build.llvm_filecheck(build.build);
-    if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {
-        panic!("FileCheck executable {:?} does not exist", filecheck);
-    }
-
-    for target in &build.targets {
-        // Can't compile for iOS unless we're on macOS
-        if target.contains("apple-ios") &&
-           !build.build.contains("apple-darwin") {
-            panic!("the iOS target is only supported on macOS");
-        }
-
-        // Make sure musl-root is valid
-        if target.contains("musl") && !target.contains("mips") {
-            // If this is a native target (host is also musl) and no musl-root is given,
-            // fall back to the system toolchain in /usr before giving up
-            if build.musl_root(*target).is_none() && build.config.build == *target {
-                let target = build.config.target_config.entry(target.clone())
-                                 .or_insert(Default::default());
-                target.musl_root = Some("/usr".into());
-            }
-            match build.musl_root(*target) {
-                Some(root) => {
-                    if fs::metadata(root.join("lib/libc.a")).is_err() {
-                        panic!("couldn't find libc.a in musl dir: {}",
-                               root.join("lib").display());
-                    }
-                    if fs::metadata(root.join("lib/libunwind.a")).is_err() {
-                        panic!("couldn't find libunwind.a in musl dir: {}",
-                               root.join("lib").display());
-                    }
-                }
-                None => {
-                    panic!("when targeting MUSL either the rust.musl-root \
-                            option or the target.$TARGET.musl-root option must \
-                            be specified in config.toml")
-                }
-            }
-        }
-
-        if target.contains("msvc") {
-            // There are three builds of cmake on windows: MSVC, MinGW, and
-            // Cygwin. The Cygwin build does not have generators for Visual
-            // Studio, so detect that here and error.
-            let out = output(Command::new("cmake").arg("--help"));
-            if !out.contains("Visual Studio") {
-                panic!("
-cmake does not support Visual Studio generators.
-
-This is likely due to it being an msys/cygwin build of cmake,
-rather than the required windows version, built using MinGW
-or Visual Studio.
-
-If you are building under msys2 try installing the mingw-w64-x86_64-cmake
-package instead of cmake:
-
-$ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake
-");
-            }
-        }
-    }
-
-    let run = |cmd: &mut Command| {
-        cmd.output().map(|output| {
-            String::from_utf8_lossy(&output.stdout)
-                   .lines().next().unwrap()
-                   .to_string()
-        })
-    };
-    build.lldb_version = run(Command::new("lldb").arg("--version")).ok();
-    if build.lldb_version.is_some() {
-        build.lldb_python_dir = run(Command::new("lldb").arg("-P")).ok();
-    }
-
-    if let Some(ref s) = build.config.ccache {
-        cmd_finder.must_have(s);
-    }
-}*/
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/tests/common/mod.rs grin-miner-copy/cuckoo-miner/tests/common/mod.rs
--- grin-miner-1.0.2/cuckoo-miner/tests/common/mod.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/tests/common/mod.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,141 +0,0 @@
-
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-//! Common values and functions that can be used in all mining tests
-
-extern crate cuckoo_miner as cuckoo;
-extern crate time;
-
-use std;
-use std::env;
-use std::path::PathBuf;
-use self::cuckoo::{CuckooMiner, PluginConfig};
-
-/// Values from T4 genesis that should be validated
-pub const T4_GENESIS_PREPOW:&str = "00010000000000000000000000005bc794c0fffffffff\
-fffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000\
-00000000000000000000000000000000000000000000000000000000000000000000000000000\
-00000000000000000000000000000000000000000000000000000000000000000000000000000\
-00000000000000000000000000000000000000000000000000000000000000000000000000000\
-00000000000000000000000000000000000000000000000000000000000000000000000000000\
-000000000000000000000000000000001c5200000007407784d410a210b1ba";
-
-pub const _T4_GENESIS_NONCE:u64 = 8612241555342799290;
-pub const T4_GENESIS_PROOF:[u64; 42] = [
-0x46f3b4, 0x1135f8c, 0x1a1596f, 0x1e10f71, 0x41c03ea, 0x63fe8e7, 0x65af34f,
-0x73c16d3, 0x8216dc3, 0x9bc75d0, 0xae7d9ad, 0xc1cb12b, 0xc65e957, 0xf67a152,
-0xfac6559, 0x100c3d71, 0x11eea08b, 0x1225dfbb, 0x124d61a1, 0x132a14b4, 0x13f4ec38,
-0x1542d236, 0x155f2df0, 0x1577394e, 0x163c3513, 0x19349845, 0x19d46953, 0x19f65ed4,
-0x1a0411b9, 0x1a2fa039, 0x1a72a06c, 0x1b02ddd2, 0x1b594d59, 0x1b7bffd3, 0x1befe12e,
-0x1c82e4cd, 0x1d492478, 0x1de132a5, 0x1e578b3c, 0x1ed96855, 0x1f222896, 0x1fea0da6];
-
-// Helper function, derives the plugin directory for mining tests
-pub fn mining_plugin_dir_for_tests() -> PathBuf {
-	env::current_exe()
-		.map(|mut env_path| {
-			env_path.pop();
-			// cargo test exes are a directory further down
-			if env_path.ends_with("deps") {
-				env_path.pop();
-			}
-			env_path.push("plugins");
-			env_path
-		})
-		.unwrap()
-}
-
-// Helper function, tests a particular miner implementation against a known set
-pub fn mine_async_for_duration(configs: &Vec<PluginConfig>, duration_in_seconds: i64) {
-	let stat_check_interval = 3;
-	let mut deadline = time::get_time().sec + duration_in_seconds;
-	let mut next_stat_check = time::get_time().sec + stat_check_interval;
-	let mut stats_updated = false;
-
-	//for CI testing on slower servers
-	//if we're trying to quit and there are no stats yet, keep going for a bit
-	let mut extra_time=false;
-	let extra_time_value=600;
-
-	// these always get consumed after a notify
-	let mut miner = CuckooMiner::new(configs.clone());
-	let _ = miner.start_solvers();
-
-	while time::get_time().sec < deadline {
-
-		println!("Test mining for {} seconds, looking for difficulty >= 0", duration_in_seconds);
-		let mut i=0;
-		for c in configs.clone().into_iter(){
-			println!("Plugin {}: {}", i, c.name);
-			i+=1;
-		}
-
-		miner.notify(1, 1, T4_GENESIS_PREPOW,  "", 0).unwrap();
-
-		loop {
-			if let Some(solutions) = miner.get_solutions() {
-				for i in 0..solutions.num_sols {
-					println!("Sol found: {}", solutions.sols[i as usize]);
-					continue;
-				}
-			}
-			if time::get_time().sec >= next_stat_check {
-				let mut sps_total=0.0;
-				let stats_vec=miner.get_stats();
-				for s in stats_vec.unwrap().into_iter() {
-					let last_solution_time_secs = s.last_solution_time as f64 / 1000000000.0;
-					let last_hashes_per_sec = 1.0 / last_solution_time_secs;
-					let status = match s.has_errored {
-						false => "OK",
-						_ => "ERRORED",
-					};
-					println!("Plugin 0 - Device {} ({}) (Cuck(at)oo{}) - Status: {} - Last Graph time: {}; Graphs per second: {:.*} \
-					- Total Attempts: {}",
-					s.device_id, s.get_device_name(), s.edge_bits, status, last_solution_time_secs, 3, last_hashes_per_sec, s.iterations);
-					if last_hashes_per_sec.is_finite() {
-						sps_total+=last_hashes_per_sec;
-					}
-					if last_solution_time_secs > 0.0 {
-						stats_updated = true;
-					}
-					i+=1;
-				}
-				println!("Total solutions per second: {}", sps_total);
-				next_stat_check = time::get_time().sec + stat_check_interval;
-			}
-			if time::get_time().sec > deadline {
-				if !stats_updated && !extra_time {
-					extra_time=true;
-					deadline+=extra_time_value;
-					println!("More time needed");
-				} else {
-					println!("Stopping jobs and waiting for cleanup");
-					miner.stop_solvers();
-					break;
-				}
-			}
-			if stats_updated && extra_time {
-				miner.stop_solvers();
-				return;
-			}
-			//avoid busy wait
-			let sleep_dur = std::time::Duration::from_millis(100);
-			std::thread::sleep(sleep_dur);
-			if stats_updated && extra_time {
-				break;
-			}
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/tests/miner.rs grin-miner-copy/cuckoo-miner/tests/miner.rs
--- grin-miner-1.0.2/cuckoo-miner/tests/miner.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/tests/miner.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,153 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-/// Tests exercising the loading and unloading of plugins, as well as the
-/// existence and correct functionality of each plugin function
-mod common;
-
-extern crate rand;
-extern crate cuckoo_miner as cuckoo;
-
-use cuckoo::{PluginConfig};
-use common::{mining_plugin_dir_for_tests, mine_async_for_duration};
-
-// AT LEAN ///////////////
-#[test]
-fn mine_cuckatoo_lean_compat_cpu_19() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_lean_cpu_compat_19").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[ignore]
-#[test]
-fn mine_cuckatoo_lean_compat_cpu_31() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_lean_cpu_compat_31").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[ignore]
-#[cfg(feature="test-avx2")]
-#[test]
-fn mine_cuckatoo_lean_avx2_cpu_31() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_lean_cpu_avx2_31").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-// AT MEAN ///////////////
-
-#[test]
-fn mine_cuckatoo_mean_cpu_compat_19() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_mean_cpu_compat_19").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[cfg(feature="test-avx2")]
-fn mine_cuckatoo_mean_avx2_cpu_19() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_mean_cpu_avx2_19").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[ignore]
-#[test]
-fn mine_cuckatoo_mean_compat_cpu_31() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_mean_cpu_compat_31").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[ignore]
-#[cfg(feature="test-avx2")]
-#[test]
-fn mine_cuckatoo_mean_avx2_cpu_31() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_mean_cpu_avx2_31").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-// AT MEAN CUDA ///////////////
-#[cfg(feature="build-cuda-plugins")]
-#[test]
-fn mine_cuckatoo_mean_cuda_19() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_mean_cuda_19").unwrap();
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[ignore]
-#[cfg(feature="build-cuda-plugins")]
-#[test]
-fn mine_cuckatoo_mean_cuda_31() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_mean_cuda_31").unwrap();
-	mine_async_for_duration(&vec![config], 20);
-}
-
-// AT LEAN CUDA ///////////////
-#[cfg(feature="build-cuda-plugins")]
-#[test]
-fn mine_cuckatoo_lean_cuda_19() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_lean_cuda_19").unwrap();
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[ignore]
-#[cfg(feature="build-cuda-plugins")]
-#[test]
-fn mine_cuckatoo_lean_cuda_31() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_lean_cuda_31").unwrap();
-	mine_async_for_duration(&vec![config], 20);
-}
-
-// AR CPU //////////////////////////
-#[ignore]
-#[test]
-fn mine_cuckaroo_mean_cpu_compat_19() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckaroo_cpu_compat_19").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[ignore]
-#[cfg(feature="test-avx2")]
-#[test]
-fn mine_cuckaroo_mean_cpu_avx2_29() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckaroo_cpu_avx_19").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[test]
-fn mine_cuckaroo_mean_cpu_compat_29() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckaroo_cpu_compat_29").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[cfg(feature="test-avx2")]
-#[test]
-fn mine_cuckaroo_mean_cpu_avx2_29() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckaroo_cpu_avx_29").unwrap();
-	config.params.nthreads = 4;
-	mine_async_for_duration(&vec![config], 20);
-}
-
-#[cfg(feature="build-cuda-plugins")]
-#[test]
-fn mine_cuckaroo_cuda_29() {
-	let mut config = PluginConfig::new(mining_plugin_dir_for_tests(), "cuckatoo_cuda_29").unwrap();
-	mine_async_for_duration(&vec![config], 20);
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/cuckoo-miner/tests/plugins.rs grin-miner-copy/cuckoo-miner/tests/plugins.rs
--- grin-miner-1.0.2/cuckoo-miner/tests/plugins.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/cuckoo-miner/tests/plugins.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,243 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-/// Tests exercising the loading and unloading of plugins, as well as the
-/// existence and correct functionality of each plugin function
-mod common;
-
-extern crate cuckoo_miner as cuckoo;
-extern crate grin_miner_plugin as plugin;
-extern crate rand;
-
-use common::{T4_GENESIS_PREPOW, T4_GENESIS_PROOF};
-use std::env;
-
-use cuckoo::{CuckooMinerError, PluginLibrary};
-use plugin::{SolverParams, SolverSolutions, SolverStats};
-
-static SO_SUFFIX: &str = ".cuckooplugin";
-
-/// Solution for 80 length header with nonce 0
-const CUCKATOO_29_SOL: [u64; 42] = [
-	0x48a9e2, 0x9cf043, 0x155ca30, 0x18f4783, 0x248f86c, 0x2629a64, 0x5bad752, 0x72e3569,
-	0x93db760, 0x97d3b37, 0x9e05670, 0xa315d5a, 0xa3571a1, 0xa48db46, 0xa7796b6, 0xac43611,
-	0xb64912f, 0xbb6c71e, 0xbcc8be1, 0xc38a43a, 0xd4faa99, 0xe018a66, 0xe37e49c, 0xfa975fa,
-	0x11786035, 0x1243b60a, 0x12892da0, 0x141b5453, 0x1483c3a0, 0x1505525e, 0x1607352c, 0x16181fe3,
-	0x17e3a1da, 0x180b651e, 0x1899d678, 0x1931b0bb, 0x19606448, 0x1b041655, 0x1b2c20ad, 0x1bd7a83c,
-	0x1c05d5b0, 0x1c0b9caa,
-];
-
-const TEST_PLUGIN_LIBS_CORE: [&str; 6] = [
-	"cuckatoo_mean_cpu_compat_19",
-	"cuckatoo_mean_cpu_compat_31",
-	"cuckatoo_lean_cpu_compat_19",
-	"cuckatoo_lean_cpu_compat_31",
-	"cuckaroo_cpu_compat_19",
-	"cuckaroo_cpu_compat_29",
-];
-
-const TEST_PLUGIN_LIBS_OPTIONAL: [&str; 1] = ["cuckaroo_mean_cuda_29"];
-
-//Helper to convert from hex string
-fn from_hex_string(in_str: &str) -> Vec<u8> {
-	let mut bytes = Vec::new();
-	for i in 0..(in_str.len() / 2) {
-		let res = u8::from_str_radix(&in_str[2 * i..2 * i + 2], 16);
-		match res {
-			Ok(v) => bytes.push(v),
-			Err(e) => println!("Problem with hex: {}", e),
-		}
-	}
-	bytes
-}
-
-//Helper to load a plugin library
-fn load_plugin_lib(plugin: &str) -> Result<PluginLibrary, CuckooMinerError> {
-	let mut p_path = env::current_exe().unwrap();
-	p_path.pop();
-	p_path.pop();
-	p_path.push("plugins");
-	p_path.push(format!("{}{}", plugin, SO_SUFFIX).as_str());
-	PluginLibrary::new(p_path.to_str().unwrap())
-}
-
-//Helper to load all plugin libraries specified above
-fn load_all_plugins() -> Vec<PluginLibrary> {
-	let mut plugin_libs: Vec<PluginLibrary> = Vec::new();
-	for p in TEST_PLUGIN_LIBS_CORE.into_iter() {
-		plugin_libs.push(load_plugin_lib(p).unwrap());
-	}
-	for p in TEST_PLUGIN_LIBS_OPTIONAL.into_iter() {
-		let pl = load_plugin_lib(p);
-		if let Ok(p) = pl {
-			plugin_libs.push(p);
-		}
-	}
-	plugin_libs
-}
-
-//loads and unloads a plugin many times
-#[test]
-fn on_commit_plugin_loading() {
-	//core plugins should be built on all systems, fail if they don't exist
-	for _ in 0..100 {
-		for p in TEST_PLUGIN_LIBS_CORE.into_iter() {
-			let pl = load_plugin_lib(p).unwrap();
-			pl.unload();
-		}
-	}
-	//only test these if they do exist (cuda, etc)
-	for _ in 0..100 {
-		for p in TEST_PLUGIN_LIBS_OPTIONAL.into_iter() {
-			let pl = load_plugin_lib(p);
-			if let Err(_) = pl {
-				break;
-			}
-			pl.unwrap().unload();
-		}
-	}
-}
-
-//Loads all plugins at once
-#[test]
-fn plugin_multiple_loading() {
-	let _p = load_all_plugins();
-}
-
-// check that output is consistent with command line
-fn test_mutating(pl: &PluginLibrary, mut params: SolverParams) {
-	let mut sols = SolverSolutions::default();
-	let mut stats = SolverStats::default();
-	// to be consistent with command line solver operation
-	params.mutate_nonce = true;
-	let ctx = pl.create_solver_ctx(&mut params);
-	let test_header = [0u8; 80].to_vec();
-	let _ = pl.run_solver(ctx, test_header, 20, 1, &mut sols, &mut stats);
-	assert_eq!(sols.num_sols, 1);
-	assert_eq!(sols.edge_bits, 29);
-	assert_eq!(stats.edge_bits, 29);
-	for i in 0..42 {
-		assert_eq!(sols.sols[0].proof[i], CUCKATOO_29_SOL[i]);
-	}
-	println!("We're here");
-	pl.destroy_solver_ctx(ctx);
-	pl.unload();
-}
-
-// check that output is consistent with grin T4 Genesis
-fn test_t4_genesis(pl: &PluginLibrary, mut params: SolverParams) {
-	let mut sols = SolverSolutions::default();
-	let mut stats = SolverStats::default();
-	params.mutate_nonce = false;
-	let ctx = pl.create_solver_ctx(&mut params);
-	let test_header = from_hex_string(T4_GENESIS_PREPOW);
-	let _ = pl.run_solver(ctx, test_header, 0, 1, &mut sols, &mut stats);
-	assert_eq!(sols.num_sols, 1);
-	assert_eq!(sols.edge_bits, 29);
-	assert_eq!(sols.edge_bits, 29);
-	assert_eq!(stats.edge_bits, 29);
-	for i in 0..42 {
-		assert_eq!(sols.sols[0].proof[i], T4_GENESIS_PROOF[i]);
-	}
-	pl.destroy_solver_ctx(ctx);
-	pl.unload();
-}
-fn run_solver(pl: &PluginLibrary, params: SolverParams) {
-	//test_mutating(pl, params.clone());
-	//test_t4_genesis(pl, params.clone());
-}
-
-#[test]
-fn sanity_cuckaroo_mean_compat_cpu_29() {
-	let pl = load_plugin_lib("cuckaroo_cpu_compat_29").unwrap();
-	let mut params = pl.get_default_params();
-	params.nthreads = 4;
-	run_solver(&pl, params);
-}
-
-#[cfg(feature = "test-avx2")]
-#[test]
-fn sanity_cuckaroo_mean_avx2_cpu_29() {
-	let pl = load_plugin_lib("cuckaroo_cpu_avx2_29").unwrap();
-	let mut params = pl.get_default_params();
-	params.nthreads = 4;
-	run_solver(&pl, params);
-}
-
-#[ignore]
-#[test]
-fn sanity_cuckatoo_mean_compat_cpu_31() {
-	let pl = load_plugin_lib("cuckatoo_mean_cpu_compat_31").unwrap();
-	let mut params = pl.get_default_params();
-	params.nthreads = 4;
-	run_solver(&pl, params);
-}
-
-#[ignore]
-#[cfg(feature = "test-avx2")]
-#[test]
-fn sanity_cuckatoo_mean_avx2_cpu_31() {
-	let pl = load_plugin_lib("cuckatoo_mean_cpu_avx2_31").unwrap();
-	let mut params = pl.get_default_params();
-	params.nthreads = 4;
-	run_solver(&pl, params);
-}
-
-#[ignore]
-#[test]
-fn sanity_cuckatoo_lean_cpu_31() {
-	let pl = load_plugin_lib("cuckatoo_lean_cpu_compat_31").unwrap();
-	let mut params = pl.get_default_params();
-	params.expand = 1;
-	params.nthreads = 4;
-	run_solver(&pl, params);
-}
-
-#[ignore]
-#[cfg(feature = "test-avx2")]
-#[test]
-fn sanity_cuckatoo_lean_avx2_cpu_31() {
-	let pl = load_plugin_lib("cuckatoo_lean_cpu_avx2_31").unwrap();
-	let mut params = pl.get_default_params();
-	params.nthreads = 4;
-	run_solver(&pl, params);
-}
-
-#[ignore]
-#[cfg(feature = "build-cuda-plugins")]
-#[test]
-fn sanity_cuckatoo_mean_cuda_31() {
-	let pl = load_plugin_lib("cuckatoo_mean_cuda_31").unwrap();
-	let mut params = pl.get_default_params();
-	params.expand = 1;
-	run_solver(&pl, params);
-}
-
-#[ignore]
-#[cfg(feature = "build-cuda-plugins")]
-#[test]
-fn sanity_cuckatoo_lean_cuda_31() {
-	let pl = load_plugin_lib("cuckatoo_lean_cuda_31").unwrap();
-	let params = pl.get_default_params();
-	run_solver(&pl, params);
-}
-
-#[ignore]
-#[test]
-fn sanity_ocl_cuckatoo() {
-	let pl = load_plugin_lib("ocl_cuckatoo").unwrap();
-	let mut params = pl.get_default_params();
-	params.nthreads = 4;
-	run_solver(&pl, params);
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/Dockerfile grin-miner-copy/Dockerfile
--- grin-miner-1.0.2/Dockerfile	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/Dockerfile	1969-12-31 19:00:00.000000000 -0500
@@ -1,52 +0,0 @@
-# Multistage docker build, requires docker 17.05
-
-# builder stage
-FROM nvidia/cuda:10.0-devel as builder
-
-RUN set -ex && \
-    apt-get update && \
-    apt-get --no-install-recommends --yes install \
-        libncurses5-dev \
-        libncursesw5-dev \
-        cmake \
-        git \
-        curl \
-        libssl-dev \
-        pkg-config
-
-RUN curl https://sh.rustup.rs -sSf | sh -s -- -y
-
-RUN git clone https://github.com/mimblewimble/grin-miner && cd grin-miner && git submodule update --init
-
-RUN cd grin-miner && sed -i '/^cuckoo_miner = {/s/^/#/' Cargo.toml && sed -i '/^#.*build-cuda-plugins"]/s/^#//' Cargo.toml
-
-RUN cd grin-miner && $HOME/.cargo/bin/cargo build --release
-
-# runtime stage
-FROM nvidia/cuda:10.0-base
-
-RUN set -ex && \
-    apt-get update && \
-    apt-get --no-install-recommends --yes install \
-    libncurses5 \
-    libncursesw5
-
-COPY --from=builder /grin-miner/target/release/grin-miner /grin-miner/target/release/grin-miner
-COPY --from=builder /grin-miner/target/release/plugins/* /grin-miner/target/release/plugins/
-COPY --from=builder /grin-miner/grin-miner.toml /grin-miner/grin-miner.toml
-
-WORKDIR /grin-miner
-
-RUN sed -i -e 's/run_tui = true/run_tui = false/' grin-miner.toml
-
-RUN echo '#!/bin/bash\n\
-if [ $# -eq 1 ]\n\
-   then\n\
-sed -i -e 's/127.0.0.1/\$1/g' grin-miner.toml\n\
-fi\n\
-./target/release/grin-miner' > run.sh
-
-# If the grin server is not at 127.0.0.1 provide the ip or hostname to the container
-# by command line (i.e. docker run --name miner1 --rm -i -t miner_image 1.2.3.4)
-
-ENTRYPOINT ["sh", "run.sh"]
diff -urN '--exclude=.git' grin-miner-1.0.2/etc/crate-release.sh grin-miner-copy/etc/crate-release.sh
--- grin-miner-1.0.2/etc/crate-release.sh	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/etc/crate-release.sh	1969-12-31 19:00:00.000000000 -0500
@@ -1,33 +0,0 @@
-#!/usr/bin/env bash
-
-# check we're in the grin root
-if [ ! -f "LICENSE" ] ; then
-	echo "Script must be run from Grin-miner's root directory"
-	exit 1
-fi
-
-echo "Going to package and publish each crate, if you're not logged in crates.io (missing ~/.cargo/credentials, this will fail."
-
-read -p "Continue? " -n 1 -r
-if [[ ! $REPLY =~ ^[Yy]$ ]]
-then
-	printf "\nbye\n"
-	exit 1
-fi
-
-echo
-crates=( config cuckoo-miner plugin util )
-
-for crate in "${crates[@]}"
-do
-	echo "** Publishing $crate"
-	cd $crate
-	cargo package
-	cargo publish
-	cd ..
-done
-
-cargo package
-cargo publish
-
-echo "Done."
diff -urN '--exclude=.git' grin-miner-1.0.2/.gitignore grin-miner-copy/.gitignore
--- grin-miner-1.0.2/.gitignore	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/.gitignore	1969-12-31 19:00:00.000000000 -0500
@@ -1,7 +0,0 @@
-*.swp
-.DS_Store
-.grin*
-node*
-target
-*.iml
-grin-miner.log
diff -urN '--exclude=.git' grin-miner-1.0.2/.gitmodules grin-miner-copy/.gitmodules
--- grin-miner-1.0.2/.gitmodules	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/.gitmodules	1969-12-31 19:00:00.000000000 -0500
@@ -1,3 +0,0 @@
-[submodule "cuckoo-miner/src/cuckoo_sys/plugins/cuckoo"]
-	path = cuckoo-miner/src/cuckoo_sys/plugins/cuckoo
-	url = https://github.com/tromp/cuckoo.git
diff -urN '--exclude=.git' grin-miner-1.0.2/grin-miner.toml grin-miner-copy/grin-miner.toml
--- grin-miner-1.0.2/grin-miner.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/grin-miner.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,220 +0,0 @@
-# Sample Server Configuration File for Grin-Miner
-#
-# Grin-Miner will look for this file in these places: in the following
-# order:
-#
-# -The working directory
-# -The directory in which the executable resides
-
-#########################################
-### LOGGING CONFIGURATION             ###
-#########################################
-
-[logging]
-
-# Whether to log to stdout
-log_to_stdout = true
-
-# Log level for stdout: Critical, Error, Warning, Info, Debug, Trace
-stdout_log_level = "Info"
-
-# Whether to log to a file
-log_to_file = true
-
-# Log level for file: Critical, Error, Warning, Info, Debug, Trace
-file_log_level = "Debug"
-
-# Log file path
-log_file_path = "grin-miner.log"
-
-# Whether to append to the log file (true), or replace it on every run (false)
-log_file_append = true
-
-#########################################
-### MINING CLIENT CONFIGURATION       ###
-#########################################
-
-[mining]
-
-# whether to run the tui
-run_tui = true
-
-# listening grin stratum server url
-stratum_server_addr = "127.0.0.1:3416"
-
-# login for the stratum server (if required)
-#stratum_server_login = "http://192.168.1.100:3415"
-
-# password for the stratum server (if required)
-#stratum_server_password = "x"
-
-# whether tls is enabled for the stratum server
-stratum_server_tls_enabled = false
-
-#The directory in which mining plugins are installed
-#if not specified, grin miner will look in the directory /deps relative
-#to the executable
-
-#miner_plugin_dir = "target/debug/plugins"
-
-###############################################################
-### CUCKAROO (i.e. GPU-Friendly) MINER PLUGIN CONFIGURATION ###
-###############################################################
-
-# Multiple plugins can be specified, (e.g. a cpu
-# miner and a gpu miner running in parallel)
-# Use a single plugin instance per device, as
-# demonstrated below.
-
-# Multiple instances of the same plugin can be loaded
-# and used with different devices. On CPU plugins
-# you'll likely only be using a single instance
-# but in CUDA plugins the device number can be set
-# corresponding to the device ID. (use nvidia-smi to find this)
-
-### CUCKAROO CPU SOLVERS (Asic Resist, or GPU-Friendly)
-
-# The fastest cpu algorithm, but consumes the most memory
-
-[[mining.miner_plugin_config]]
-plugin_name = "cuckaroo_cpu_avx2_29"
-[mining.miner_plugin_config.parameters]
-nthreads = 4
-
-# As above, but for processors supporting avx2
-
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckaroo_cpu_avx2_29"
-#[mining.miner_plugin_config.parameters]
-#nthreads = 4
-
-# CUCKAROO CUDA SOLVER
-#
-# CUDA plugins are not built by default. To build:
-#1) Ensure the latest cuda toolkit is installed
-#   (nvcc should be in your PATH)
-#   Wrong gcc? install gcc-5 g++-5; export CC=`which gcc-5`; # then build
-#2) Ensure the 'build-cuda-plugin' feature is included in Cargo.toml, e.g:
-#   cuckoo_miner = { path = "./cuckoo-miner", features = ["build-cuda-plugins"]}
-#
-# Parameters can be set individually for each device by using multiple
-# instance of each plugin.  device 0 is used by default
-#
-
-# currently requires 5.5GB+ GPU memory
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckaroo_cuda_29"
-#[mining.miner_plugin_config.parameters]
-#device = 0
-#cpuload = 1
-#ntrims = 176
-#genablocks = 4096
-#genatpb = 128
-#genbtpb = 128
-#trimtpb = 512
-#tailtpb = 1024
-#recoverblocks = 1024
-#recovertpb = 1024
-
-# e.g. To enable multiple devices (copy params from above as needed)
-
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckaroo_cuda_29"
-#[mining.miner_plugin_config.parameters]
-#device = 1
-
-
-# mean OpenCL supports both NVidia and AMD
-# to install run ./install_ocl_plugins.sh script
-#[[mining.miner_plugin_config]]
-#plugin_name = "ocl_cuckaroo"
-#[mining.miner_plugin_config.parameters]
-# 0 for default, 1 for AMD, 2 for NVidia, specify if you have
-# cards from both vendors
-#platform = 0
-# ID withing the platform
-#device = 0
-
-###############################################################
-### CUCKATOO (i.e. ASIC-Friendly) MINER PLUGIN CONFIGURATION ##
-###############################################################
-
-#mean cpu
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckatoo_mean_cpu_compat_31"
-#[mining.miner_plugin_config.parameters]
-#nthreads = 4
-
-#mean cpu avx2
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckatoo_mean_cpu_avx2_31"
-#[mining.miner_plugin_config.parameters]
-
-#mean cuda, will work on a 1080TI with expand rounds set to 2
-#memory requirements are tight, don't drive a display
-#off the same card while trying to mine with an 11GB card
-
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckatoo_mean_cuda_gtx_31"
-#[mining.miner_plugin_config.parameters]
-#device = 0
-#expand = 2
-#cpuload = 1
-#ntrims = 176
-#genablocks = 4096
-#genatpb = 128
-#genbtpb = 128
-#trimtpb = 512
-#tailtpb = 1024
-#recoverblocks = 1024
-#recovertpb = 1024
-
-#mean cuda optimised to use slightly less memory,
-#will work on a 2080TI with expand rounds set to 2
-#as above, memory requirements are tight, don't drive a display
-#off the same card while trying to mine with an 11GB card
-
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckatoo_mean_cuda_rtx_31"
-#[mining.miner_plugin_config.parameters]
-#device = 0
-#expand = 2
-#cpuload = 1
-#ntrims = 176
-#genablocks = 4096
-#genatpb = 128
-#genbtpb = 128
-#trimtpb = 512
-#tailtpb = 1024
-#recoverblocks = 1024
-#recovertpb = 1024
-
-#lean cuda
-#[[mining.miner_plugin_config]]
-#plugin_name = "cuckatoo_lean_cuda_31"
-#[mining.miner_plugin_config.parameters]
-#expand = 0
-#device = 0
-#cpuload = 1
-#ntrims = 176
-#genablocks = 4096
-#genatpb = 128
-#genbtpb = 128
-#trimtpb = 512
-#tailtpb = 1024
-#recoverblocks = 1024
-#recovertpb = 1024
-
-# lean OpenCL supports both NVidia and AMD
-# very slow but requires ~ 3GB of RAM
-# to install run ./install_ocl_plugins.sh script
-#[[mining.miner_plugin_config]]
-#plugin_name = "ocl_cuckatoo"
-#[mining.miner_plugin_config.parameters]
-# 0 for default, 1 for AMD, 2 for NVidia, specify if you have
-# cards from both vendors
-#platform = 0
-# ID withing the platform
-#device = 0
-#edge_bits = 31
-
diff -urN '--exclude=.git' grin-miner-1.0.2/install_ocl_plugins.sh grin-miner-copy/install_ocl_plugins.sh
--- grin-miner-1.0.2/install_ocl_plugins.sh	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/install_ocl_plugins.sh	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-plugins_dir=$(egrep '^miner_plugin_dir' grin-miner.toml | awk '{ print $NF }' | xargs echo)
-if [ -z "$plugins_dir" ]; then
-	plugins_dir="target/debug/plugins"
-fi
-mkdir -p "$plugins_dir";
-
-# Install ocl_cuckatoo
-cd ocl_cuckatoo
-cargo build --release
-cd ..
-if [ "$(uname)" == "Darwin" ]; then
-	cp target/release/libocl_cuckatoo.dylib $plugins_dir/ocl_cuckatoo.cuckooplugin
-else
-	cp target/release/libocl_cuckatoo.so $plugins_dir/ocl_cuckatoo.cuckooplugin
-fi
-
-# Install ocl_cuckaroo
-cd ocl_cuckaroo
-cargo build --release
-cd ..
-if [ "$(uname)" == "Darwin" ]; then
-	cp target/release/libocl_cuckaroo.dylib $plugins_dir/ocl_cuckaroo.cuckooplugin
-else
-	cp target/release/libocl_cuckaroo.so $plugins_dir/ocl_cuckaroo.cuckooplugin
-fi
diff -urN '--exclude=.git' grin-miner-1.0.2/LICENSE grin-miner-copy/LICENSE
--- grin-miner-1.0.2/LICENSE	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,201 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckaroo/Cargo.toml grin-miner-copy/ocl_cuckaroo/Cargo.toml
--- grin-miner-1.0.2/ocl_cuckaroo/Cargo.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckaroo/Cargo.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,22 +0,0 @@
-[package]
-name = "ocl_cuckaroo"
-version = "1.0.2"
-workspace = ".."
-edition = "2018"
-
-[features]
-profile = []
-
-
-[dependencies]
-grin_miner_plugin = { path = "../plugin", version = "1.0.2" }
-ocl = "0.19"
-hashbrown = "0.1"
-libc = "0.2.24"
-blake2-rfc = "0.2"
-byteorder = "1"
-
-
-[lib]
-name = "ocl_cuckaroo"
-crate-type = ["cdylib", "rlib"]
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckaroo/.gitignore grin-miner-copy/ocl_cuckaroo/.gitignore
--- grin-miner-1.0.2/ocl_cuckaroo/.gitignore	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckaroo/.gitignore	1969-12-31 19:00:00.000000000 -0500
@@ -1,3 +0,0 @@
-/target
-**/*.rs.bk
-Cargo.lock
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckaroo/src/finder.rs grin-miner-copy/ocl_cuckaroo/src/finder.rs
--- grin-miner-1.0.2/ocl_cuckaroo/src/finder.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckaroo/src/finder.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,200 +0,0 @@
-use hashbrown::HashMap;
-
-#[derive(Clone)]
-pub struct Solution {
-	pub nodes: Vec<u32>,
-}
-
-pub struct Graph {
-	adj_index: HashMap<u32, usize>,
-	adj_store: Vec<AdjNode>,
-}
-
-struct Search {
-	path: Vec<u32>,
-	solutions: Vec<Solution>,
-
-	state: HashMap<u32, NodeState>,
-	node_visited: usize,
-}
-
-#[derive(Clone, Copy)]
-enum NodeState {
-	NotVisited,
-	Visited,
-}
-
-impl Search {
-	fn new(node_count: usize) -> Search {
-		Search {
-			path: Vec::with_capacity(node_count),
-			solutions: vec![],
-			state: HashMap::with_capacity_and_hasher(node_count, Default::default()),
-			node_visited: 0,
-		}
-	}
-
-	#[inline]
-	fn visit(&mut self, node: u32) {
-		self.state.insert(node, NodeState::Visited);
-		self.path.push(node);
-		self.node_visited += 1;
-	}
-
-	#[inline]
-	fn leave(&mut self, node: u32) {
-		self.path.pop();
-		self.state.insert(node, NodeState::NotVisited);
-	}
-
-	#[inline]
-	fn state(&self, node: u32) -> NodeState {
-		match self.state.get(&node) {
-			None => NodeState::NotVisited,
-			Some(state) => *state,
-		}
-	}
-
-	#[inline]
-	fn is_visited(&self, node: u32) -> bool {
-		match self.state(node) {
-			NodeState::NotVisited => false,
-			_ => true,
-		}
-	}
-}
-
-struct AdjNode {
-	value: u32,
-	next: Option<usize>,
-}
-
-impl AdjNode {
-	#[inline]
-	fn first(value: u32) -> AdjNode {
-		AdjNode { value, next: None }
-	}
-
-	#[inline]
-	fn next(value: u32, next: usize) -> AdjNode {
-		AdjNode {
-			value,
-			next: Some(next),
-		}
-	}
-}
-
-struct AdjList<'a> {
-	current: Option<&'a AdjNode>,
-	adj_store: &'a Vec<AdjNode>,
-}
-
-impl<'a> AdjList<'a> {
-	#[inline]
-	pub fn new(current: Option<&'a AdjNode>, adj_store: &'a Vec<AdjNode>) -> AdjList<'a> {
-		AdjList { current, adj_store }
-	}
-}
-
-impl<'a> Iterator for AdjList<'a> {
-	type Item = u32;
-
-	fn next(&mut self) -> Option<Self::Item> {
-		match self.current {
-			None => None,
-			Some(node) => {
-				let val = node.value;
-				match node.next {
-					None => self.current = None,
-					Some(next_index) => self.current = Some(&self.adj_store[next_index]),
-				}
-				Some(val)
-			}
-		}
-	}
-}
-
-impl Graph {
-	pub fn search(nodes: &[u32]) -> Result<Vec<Solution>, String> {
-		let edge_count = nodes.len() / 2;
-		let mut g = Graph {
-			adj_index: HashMap::with_capacity_and_hasher(nodes.len(), Default::default()),
-			adj_store: Vec::with_capacity(nodes.len()),
-		};
-		let mut search = Search::new(nodes.len());
-		const STEP: usize = 2;
-		for i in 0..edge_count {
-			let n1 = nodes[i * STEP];
-			let n2 = nodes[i * STEP + 1];
-			g.walk_graph(n1, n2, &mut search)?;
-			g.add_edge(n1, n2);
-		}
-
-		Ok(search.solutions.clone())
-	}
-
-	#[inline]
-	pub fn node_count(&self) -> usize {
-		self.adj_index.len()
-	}
-
-	#[inline]
-	pub fn edge_count(&self) -> usize {
-		self.adj_store.len() / 2
-	}
-
-	#[inline]
-	fn add_edge(&mut self, node1: u32, node2: u32) {
-		self.add_half_edge(node1, node2);
-		self.add_half_edge(node2, node1);
-	}
-
-	fn add_half_edge(&mut self, from: u32, to: u32) {
-		if let Some(index) = self.adj_index.get(&from) {
-			self.adj_store.push(AdjNode::next(to, *index));
-		} else {
-			self.adj_store.push(AdjNode::first(to));
-		}
-		self.adj_index.insert(from, self.adj_store.len() - 1);
-	}
-
-	fn neighbors(&self, node: u32) -> Option<impl Iterator<Item = u32> + '_> {
-		let node = match self.adj_index.get(&node) {
-			Some(index) => Some(&self.adj_store[*index]),
-			None => return None,
-		};
-		Some(AdjList::new(node, &self.adj_store))
-	}
-
-	#[inline]
-	fn nodes(&self) -> impl Iterator<Item = &u32> {
-		self.adj_index.keys()
-	}
-
-	fn walk_graph(&self, current: u32, target: u32, search: &mut Search) -> Result<(), String> {
-		if search.path.len() > 41 {
-			return Ok(());
-		}
-
-		let neighbors = match self.neighbors(current) {
-			None => return Ok(()),
-			Some(it) => it,
-		};
-		search.visit(current);
-		for ns in neighbors {
-			if ns == target && search.path.len() == 41 {
-				search.path.push(ns);
-				search.solutions.push(Solution {
-					nodes: search.path.clone(),
-				});
-				search.leave(current);
-				return Ok(());
-			}
-			if !search.is_visited(ns) {
-				self.walk_graph(ns, target, search)?;
-			}
-		}
-		search.leave(current);
-		Ok(())
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckaroo/src/lib.rs grin-miner-copy/ocl_cuckaroo/src/lib.rs
--- grin-miner-1.0.2/ocl_cuckaroo/src/lib.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckaroo/src/lib.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,179 +0,0 @@
-extern crate blake2_rfc;
-extern crate byteorder;
-extern crate grin_miner_plugin as plugin;
-extern crate hashbrown;
-extern crate libc;
-extern crate ocl;
-
-use blake2_rfc::blake2b::blake2b;
-use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
-use libc::*;
-use plugin::*;
-use std::io::Cursor;
-use std::io::Error;
-use std::mem;
-use std::ptr;
-use std::time::{Duration, SystemTime};
-
-pub use self::finder::Graph;
-pub use self::trimmer::Trimmer;
-
-mod finder;
-mod trimmer;
-
-#[repr(C)]
-struct Solver {
-	trimmer: Trimmer,
-	graph: Option<Graph>,
-	mutate_nonce: bool,
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn create_solver_ctx(params: *mut SolverParams) -> *mut SolverCtx {
-	let platform = match (*params).platform {
-		1 => Some("AMD"),
-		2 => Some("NVIDIA"),
-		_ => None,
-	};
-	let device_id = Some((*params).device as usize);
-
-	let trimmer = Trimmer::build(platform, device_id).expect("can't build trimmer");
-	let solver = Solver {
-		trimmer: trimmer,
-		graph: None,
-		mutate_nonce: (*params).mutate_nonce,
-	};
-	let solver_box = Box::new(solver);
-	let solver_ref = Box::leak(solver_box);
-	mem::transmute::<&mut Solver, *mut SolverCtx>(solver_ref)
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn destroy_solver_ctx(solver_ctx_ptr: *mut SolverCtx) {
-	// create box to clear memory
-	let solver_ptr = mem::transmute::<*mut SolverCtx, *mut Solver>(solver_ctx_ptr);
-	let _solver_box = Box::from_raw(solver_ptr);
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn stop_solver(_solver_ctx_ptr: *mut SolverCtx) {}
-
-#[no_mangle]
-pub unsafe extern "C" fn fill_default_params(params: *mut SolverParams) {
-	(*params).device = 0;
-	(*params).platform = 0;
-	(*params).edge_bits = 29;
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn run_solver(
-	ctx: *mut SolverCtx,
-	header_ptr: *const c_uchar,
-	header_length: uint32_t,
-	nonce: uint64_t,
-	_range: uint32_t,
-	solutions: *mut SolverSolutions,
-	stats: *mut SolverStats,
-) -> uint32_t {
-	let start = SystemTime::now();
-	let solver_ptr = mem::transmute::<*mut SolverCtx, *mut Solver>(ctx);
-	let solver = &*solver_ptr;
-	let mut header = Vec::with_capacity(header_length as usize + 32);
-	let r_ptr = header.as_mut_ptr();
-	ptr::copy_nonoverlapping(header_ptr, r_ptr, header_length as usize);
-	header.set_len(header_length as usize);
-	let n = nonce as u64;
-	let k = match set_header_nonce(&header, Some(n), solver.mutate_nonce) {
-		Err(_e) => {
-			return 2;
-		}
-		Ok(v) => v,
-	};
-	let res = solver.trimmer.run(&k).unwrap();
-
-	let sols = Graph::search(&res).unwrap();
-	let mut i = 0;
-	(*solutions).edge_bits = 29;
-	for sol in sols {
-		let (nonces_cand, valid) = solver.trimmer.recover(sol.nodes, &k).unwrap();
-		if valid {
-			let nonces = nonces_cand
-				.into_iter()
-				.map(|v| v as u64)
-				.collect::<Vec<u64>>();
-			(*solutions).sols[i].nonce = nonce;
-			(*solutions).sols[i].proof.copy_from_slice(&nonces[..]);
-			i += 1;
-		}
-	}
-	(*solutions).num_sols = i as u32;
-	let end = SystemTime::now();
-	let elapsed = end.duration_since(start).unwrap();
-	(*stats).edge_bits = 29;
-	(*stats).device_id = solver.trimmer.device_id as u32;
-	let name_bytes = solver.trimmer.device_name.as_bytes();
-	let n = std::cmp::min((*stats).device_name.len(), name_bytes.len());
-	(*stats).device_name[..n].copy_from_slice(&solver.trimmer.device_name.as_bytes()[..n]);
-	(*stats).last_solution_time = duration_to_u64(elapsed);
-	(*stats).last_start_time =
-		duration_to_u64(start.duration_since(SystemTime::UNIX_EPOCH).unwrap());
-	(*stats).last_end_time = duration_to_u64(end.duration_since(SystemTime::UNIX_EPOCH).unwrap());
-	0
-}
-
-fn duration_to_u64(elapsed: Duration) -> u64 {
-	elapsed.as_secs() * 1_000_000_000 + elapsed.subsec_nanos() as u64
-}
-
-pub fn set_header_nonce(
-	header: &[u8],
-	nonce: Option<u64>,
-	mutate_nonce: bool,
-) -> Result<[u64; 4], Error> {
-	if let Some(n) = nonce {
-		let len = header.len();
-		let mut header = header.to_owned();
-		if mutate_nonce {
-			header.truncate(len - 4);
-			header.write_u32::<LittleEndian>(n as u32)?;
-		}
-		create_siphash_keys(&header)
-	} else {
-		create_siphash_keys(&header)
-	}
-}
-
-pub fn create_siphash_keys(header: &[u8]) -> Result<[u64; 4], Error> {
-	let h = blake2b(32, &[], &header);
-	let hb = h.as_bytes();
-	let mut rdr = Cursor::new(hb);
-	Ok([
-		rdr.read_u64::<LittleEndian>()?,
-		rdr.read_u64::<LittleEndian>()?,
-		rdr.read_u64::<LittleEndian>()?,
-		rdr.read_u64::<LittleEndian>()?,
-	])
-}
-
-#[cfg(test)]
-mod tests {
-	use super::*;
-	#[test]
-	fn test_solve() {
-		let trimmer = Trimmer::build(None, None).expect("can't build trimmer");
-		let k = [
-			0x27580576fe290177,
-			0xf9ea9b2031f4e76e,
-			0x1663308c8607868f,
-			0xb88839b0fa180d0e,
-		];
-
-		unsafe {
-			let res = trimmer.run(&k).unwrap();
-			println!("Trimmed to {}", res.len());
-
-			let sols = Graph::search(&res).unwrap();
-			assert_eq!(1, sols.len());
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckaroo/src/main.rs grin-miner-copy/ocl_cuckaroo/src/main.rs
--- grin-miner-1.0.2/ocl_cuckaroo/src/main.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckaroo/src/main.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,44 +0,0 @@
-extern crate ocl_cuckaroo;
-
-use ocl_cuckaroo::{Graph, Trimmer};
-use std::time::SystemTime;
-
-fn main() -> Result<(), String> {
-	let trimmer = Trimmer::build(None, None).expect("can't build trimmer");
-	let k = [
-		0xf4956dc403730b01,
-		0xe6d45de39c2a5a3e,
-		0xcbf626a8afee35f6,
-		0x4307b94b1a0c9980,
-	];
-
-	unsafe {
-		let mut start = SystemTime::now();
-		let res = trimmer.run(&k).unwrap();
-		let mut end = SystemTime::now();
-		let elapsed = end.duration_since(start).unwrap();
-		println!("Time: {:?}", elapsed);
-		println!("Trimmed to {}", res.len());
-
-		start = SystemTime::now();
-		let sols = Graph::search(&res).unwrap();
-		end = SystemTime::now();
-		let elapsed = end.duration_since(start).unwrap();
-		println!("Finder: {:?}", elapsed);
-		for sol in sols {
-			println!("Solution: {:x?}", sol.nodes);
-			let mut start = SystemTime::now();
-			let (nonces_c, valid) = trimmer.recover(sol.nodes.clone(), &k).unwrap();
-			if valid {
-				let nonces = nonces_c.into_iter().map(|v| v as u64).collect::<Vec<u64>>();
-				let mut end = SystemTime::now();
-				let elapsed = end.duration_since(start).unwrap();
-				println!("Recovering: {:?}", elapsed);
-				println!("Nonces: {:?}", nonces);
-			} else {
-				println!("Not valid");
-			}
-		}
-	}
-	Ok(())
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckaroo/src/trimmer.rs grin-miner-copy/ocl_cuckaroo/src/trimmer.rs
--- grin-miner-1.0.2/ocl_cuckaroo/src/trimmer.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckaroo/src/trimmer.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,1094 +0,0 @@
-use ocl;
-use ocl::enums::{ArgVal, ProfilingInfo};
-use ocl::flags::CommandQueueProperties;
-use ocl::prm::{Uint2, Ulong4};
-use ocl::{
-	Buffer, Context, Device, Event, EventList, Kernel, Platform, Program, Queue, SpatialDims,
-};
-use std::env;
-
-const DUCK_SIZE_A: usize = 129; // AMD 126 + 3
-const DUCK_SIZE_B: usize = 83;
-const BUFFER_SIZE_A1: usize = DUCK_SIZE_A * 1024 * (4096 - 128) * 2;
-const BUFFER_SIZE_A2: usize = DUCK_SIZE_A * 1024 * 256 * 2;
-const BUFFER_SIZE_B: usize = DUCK_SIZE_B * 1024 * 4096 * 2;
-const INDEX_SIZE: usize = 256 * 256 * 4;
-
-pub struct Trimmer {
-	q: Queue,
-	program: Program,
-	buffer_a1: Buffer<u32>,
-	buffer_a2: Buffer<u32>,
-	buffer_b: Buffer<u32>,
-	buffer_i1: Buffer<u32>,
-	buffer_i2: Buffer<u32>,
-	buffer_r: Buffer<u32>,
-	buffer_nonces: Buffer<u32>,
-	pub device_name: String,
-	pub device_id: usize,
-	is_nvidia: bool,
-}
-
-macro_rules! clear_buffer (
-	($buf:expr) => (
-		$buf.cmd().fill(0, None).enq()?;
-	));
-
-macro_rules! kernel_enq(
-	($kernel:expr, $event_list:expr, $names:expr, $msg:expr) => (
-		#[cfg(feature = "profile")]
-		{
-		$kernel.cmd().enew(&mut $event_list).enq()?;
-		$names.push($msg);
-		}
-		#[cfg(not(feature = "profile"))]
-		{
-		$kernel.cmd().enq()?;
-		}
-	));
-
-#[cfg(feature = "profile")]
-fn queue_props() -> Option<CommandQueueProperties> {
-	Some(CommandQueueProperties::PROFILING_ENABLE)
-}
-
-#[cfg(not(feature = "profile"))]
-fn queue_props() -> Option<CommandQueueProperties> {
-	None
-}
-
-macro_rules! kernel_builder(
-	($obj: expr, $kernel: expr, $global_works_size: expr) => (
-			 Kernel::builder()
-			.name($kernel)
-			.program(&$obj.program)
-			.queue($obj.q.clone())
-			.global_work_size($global_works_size)
-));
-
-impl Trimmer {
-	pub fn build(platform_name: Option<&str>, device_id: Option<usize>) -> ocl::Result<Trimmer> {
-		env::set_var("GPU_MAX_HEAP_SIZE", "100");
-		env::set_var("GPU_USE_SYNC_OBJECTS", "1");
-		env::set_var("GPU_MAX_ALLOC_PERCENT", "100");
-		env::set_var("GPU_SINGLE_ALLOC_PERCENT", "100");
-		env::set_var("GPU_64BIT_ATOMICS", "1");
-		env::set_var("GPU_MAX_WORKGROUP_SIZE", "1024");
-		let platform = find_paltform(platform_name)
-			.ok_or::<ocl::Error>("Can't find OpenCL platform".into())?;
-		let p_name = platform.name()?;
-		let device = find_device(&platform, device_id)?;
-
-		let context = Context::builder()
-			.platform(platform)
-			.devices(device)
-			.build()?;
-
-		let q = Queue::new(&context, device, queue_props())?;
-
-		let program = Program::builder()
-			.devices(device)
-			.src(SRC)
-			.build(&context)?;
-
-		let buffer_a1 = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(BUFFER_SIZE_A1)
-			.fill_val(0)
-			.build()?;
-
-		let buffer_a2 = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(BUFFER_SIZE_A2)
-			.fill_val(0)
-			.build()?;
-
-		let buffer_b = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(BUFFER_SIZE_B)
-			.fill_val(0)
-			.build()?;
-
-		let buffer_i1 = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(INDEX_SIZE)
-			.fill_val(0)
-			.build()?;
-
-		let buffer_i2 = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(INDEX_SIZE)
-			.fill_val(0)
-			.build()?;
-
-		let buffer_r = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(42 * 2)
-			.flags(ocl::flags::MemFlags::READ_ONLY)
-			.fill_val(0)
-			.build()?;
-
-		let buffer_nonces = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(INDEX_SIZE)
-			.fill_val(0)
-			.build()?;
-
-		Ok(Trimmer {
-			q,
-			program,
-			buffer_a1,
-			buffer_a2,
-			buffer_b,
-			buffer_i1,
-			buffer_i2,
-			buffer_r,
-			buffer_nonces,
-			device_name: device.name()?,
-			device_id: device_id.unwrap_or(0),
-			is_nvidia: p_name.to_lowercase().contains("nvidia"),
-		})
-	}
-
-	pub unsafe fn recover(
-		&self,
-		mut nodes: Vec<u32>,
-		k: &[u64; 4],
-	) -> ocl::Result<(Vec<u32>, bool)> {
-		let mut event_list = EventList::new();
-		let mut names = vec![];
-
-		let mut kernel_recovery = kernel_builder!(self, "FluffyRecovery", 2048 * 256)
-			.arg(k[0])
-			.arg(k[1])
-			.arg(k[2])
-			.arg(k[3])
-			.arg(None::<&Buffer<u64>>)
-			.arg(None::<&Buffer<i32>>)
-			.build()?;
-
-		if self.is_nvidia {
-			kernel_recovery.set_default_local_work_size(SpatialDims::One(256));
-		}
-
-		kernel_recovery.set_arg_unchecked(4, ArgVal::mem(&self.buffer_r))?;
-		kernel_recovery.set_arg_unchecked(5, ArgVal::mem(&self.buffer_nonces))?;
-
-		nodes.push(nodes[0]);
-
-		let edges = nodes.windows(2).flatten().map(|v| *v).collect::<Vec<u32>>();
-		self.buffer_r.cmd().write(edges.as_slice()).enq()?;
-		self.buffer_nonces.cmd().fill(0, None).enq()?;
-		kernel_enq!(kernel_recovery, event_list, names, "recovery");
-		let mut nonces: Vec<u32> = vec![0; 42];
-
-		self.buffer_nonces.cmd().read(&mut nonces).enq()?;
-		self.q.finish()?;
-		for i in 0..names.len() {
-			print_event(names[i], &event_list[i]);
-		}
-		nonces.sort();
-		let valid = nonces.windows(2).all(|entry| match entry {
-			[p, n] => p < n,
-			_ => true,
-		});
-		Ok((nonces, valid))
-	}
-
-	pub unsafe fn run(&self, k: &[u64; 4]) -> ocl::Result<Vec<u32>> {
-		let mut kernel_seed_a = kernel_builder!(self, "FluffySeed2A", 2048 * 128)
-			.arg(k[0])
-			.arg(k[1])
-			.arg(k[2])
-			.arg(k[3])
-			.arg(None::<&Buffer<Ulong4>>)
-			.arg(None::<&Buffer<Ulong4>>)
-			.arg(None::<&Buffer<u32>>)
-			.build()?;
-		if self.is_nvidia {
-			kernel_seed_a.set_default_local_work_size(SpatialDims::One(128));
-		}
-		kernel_seed_a.set_arg_unchecked(4, ArgVal::mem(&self.buffer_b))?;
-		kernel_seed_a.set_arg_unchecked(5, ArgVal::mem(&self.buffer_a1))?;
-		kernel_seed_a.set_arg_unchecked(6, ArgVal::mem(&self.buffer_i1))?;
-
-		let mut kernel_seed_b1 = kernel_builder!(self, "FluffySeed2B", 1024 * 128)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Ulong4>>)
-			.arg(None::<&Buffer<Ulong4>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(32)
-			.build()?;
-		if self.is_nvidia {
-			kernel_seed_b1.set_default_local_work_size(SpatialDims::One(128));
-		}
-		kernel_seed_b1.set_arg_unchecked(0, ArgVal::mem(&self.buffer_a1))?;
-		kernel_seed_b1.set_arg_unchecked(1, ArgVal::mem(&self.buffer_a1))?;
-		kernel_seed_b1.set_arg_unchecked(2, ArgVal::mem(&self.buffer_a2))?;
-		kernel_seed_b1.set_arg_unchecked(3, ArgVal::mem(&self.buffer_i1))?;
-		kernel_seed_b1.set_arg_unchecked(4, ArgVal::mem(&self.buffer_i2))?;
-
-		let mut kernel_seed_b2 = kernel_builder!(self, "FluffySeed2B", 1024 * 128)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Ulong4>>)
-			.arg(None::<&Buffer<Ulong4>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(0)
-			.build()?;
-		if self.is_nvidia {
-			kernel_seed_b2.set_default_local_work_size(SpatialDims::One(128));
-		}
-
-		kernel_seed_b2.set_arg_unchecked(0, ArgVal::mem(&self.buffer_b))?;
-		kernel_seed_b2.set_arg_unchecked(1, ArgVal::mem(&self.buffer_a1))?;
-		kernel_seed_b2.set_arg_unchecked(2, ArgVal::mem(&self.buffer_a2))?;
-		kernel_seed_b2.set_arg_unchecked(3, ArgVal::mem(&self.buffer_i1))?;
-		kernel_seed_b2.set_arg_unchecked(4, ArgVal::mem(&self.buffer_i2))?;
-
-		let mut kernel_round1 = kernel_builder!(self, "FluffyRound1", 4096 * 1024)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg((DUCK_SIZE_A * 1024) as i32)
-			.arg((DUCK_SIZE_B * 1024) as i32)
-			.build()?;
-		if self.is_nvidia {
-			kernel_round1.set_default_local_work_size(SpatialDims::One(1024));
-		}
-
-		kernel_round1.set_arg_unchecked(0, ArgVal::mem(&self.buffer_a1))?;
-		kernel_round1.set_arg_unchecked(1, ArgVal::mem(&self.buffer_a2))?;
-		kernel_round1.set_arg_unchecked(2, ArgVal::mem(&self.buffer_b))?;
-		kernel_round1.set_arg_unchecked(3, ArgVal::mem(&self.buffer_i2))?;
-		kernel_round1.set_arg_unchecked(4, ArgVal::mem(&self.buffer_i1))?;
-
-		let mut kernel_round0 = kernel_builder!(self, "FluffyRoundNO1", 4096 * 1024)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(None::<&Buffer<i32>>)
-			.build()?;
-		if self.is_nvidia {
-			kernel_round0.set_default_local_work_size(SpatialDims::One(1024));
-		}
-		kernel_round0.set_arg_unchecked(0, ArgVal::mem(&self.buffer_b))?;
-		kernel_round0.set_arg_unchecked(1, ArgVal::mem(&self.buffer_a1))?;
-		kernel_round0.set_arg_unchecked(2, ArgVal::mem(&self.buffer_i1))?;
-		kernel_round0.set_arg_unchecked(3, ArgVal::mem(&self.buffer_i2))?;
-
-		let mut kernel_round_na = kernel_builder!(self, "FluffyRoundNON", 4096 * 1024)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(None::<&Buffer<i32>>)
-			.build()?;
-		if self.is_nvidia {
-			kernel_round_na.set_default_local_work_size(SpatialDims::One(1024));
-		}
-		kernel_round_na.set_arg_unchecked(0, ArgVal::mem(&self.buffer_b))?;
-		kernel_round_na.set_arg_unchecked(1, ArgVal::mem(&self.buffer_a1))?;
-		kernel_round_na.set_arg_unchecked(2, ArgVal::mem(&self.buffer_i1))?;
-		kernel_round_na.set_arg_unchecked(3, ArgVal::mem(&self.buffer_i2))?;
-
-		let mut kernel_round_nb = kernel_builder!(self, "FluffyRoundNON", 4096 * 1024)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(None::<&Buffer<i32>>)
-			.build()?;
-		if self.is_nvidia {
-			kernel_round_nb.set_default_local_work_size(SpatialDims::One(1024));
-		}
-		kernel_round_nb.set_arg_unchecked(0, ArgVal::mem(&self.buffer_a1))?;
-		kernel_round_nb.set_arg_unchecked(1, ArgVal::mem(&self.buffer_b))?;
-		kernel_round_nb.set_arg_unchecked(2, ArgVal::mem(&self.buffer_i2))?;
-		kernel_round_nb.set_arg_unchecked(3, ArgVal::mem(&self.buffer_i1))?;
-
-		let mut kernel_tail = kernel_builder!(self, "FluffyTailO", 4096 * 1024)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<Uint2>>)
-			.arg(None::<&Buffer<i32>>)
-			.arg(None::<&Buffer<i32>>)
-			.build()?;
-		if self.is_nvidia {
-			kernel_tail.set_default_local_work_size(SpatialDims::One(1024));
-		}
-		kernel_tail.set_arg_unchecked(0, ArgVal::mem(&self.buffer_b))?;
-		kernel_tail.set_arg_unchecked(1, ArgVal::mem(&self.buffer_a1))?;
-		kernel_tail.set_arg_unchecked(2, ArgVal::mem(&self.buffer_i1))?;
-		kernel_tail.set_arg_unchecked(3, ArgVal::mem(&self.buffer_i2))?;
-
-		let mut event_list = EventList::new();
-		let mut names = vec![];
-
-		let mut edges_count: Vec<u32> = vec![0; 1];
-		clear_buffer!(self.buffer_i1);
-		clear_buffer!(self.buffer_i2);
-		kernel_enq!(kernel_seed_a, event_list, names, "seedA");
-		kernel_enq!(kernel_seed_b1, event_list, names, "seedB1");
-		kernel_enq!(kernel_seed_b2, event_list, names, "seedB2");
-		clear_buffer!(self.buffer_i1);
-		kernel_enq!(kernel_round1, event_list, names, "round1");
-		clear_buffer!(self.buffer_i2);
-		kernel_enq!(kernel_round0, event_list, names, "roundN0");
-		clear_buffer!(self.buffer_i1);
-		kernel_enq!(kernel_round_nb, event_list, names, "roundNB");
-		for _ in 0..120 {
-			clear_buffer!(self.buffer_i2);
-			kernel_enq!(kernel_round_na, event_list, names, "roundNA");
-			clear_buffer!(self.buffer_i1);
-			kernel_enq!(kernel_round_nb, event_list, names, "roundNB");
-		}
-		clear_buffer!(self.buffer_i2);
-		kernel_enq!(kernel_tail, event_list, names, "tail");
-
-		self.buffer_i2.cmd().read(&mut edges_count).enq()?;
-
-		let mut edges_left: Vec<u32> = vec![0; (edges_count[0] * 2) as usize];
-
-		self.buffer_a1.cmd().read(&mut edges_left).enq()?;
-		self.q.finish()?;
-		for i in 0..names.len() {
-			print_event(names[i], &event_list[i]);
-		}
-		clear_buffer!(self.buffer_i1);
-		clear_buffer!(self.buffer_i2);
-		self.q.finish()?;
-		Ok(edges_left)
-	}
-}
-
-#[cfg(feature = "profile")]
-fn print_event(name: &str, ev: &Event) {
-	let submit = ev
-		.profiling_info(ProfilingInfo::Submit)
-		.unwrap()
-		.time()
-		.unwrap();
-	let queued = ev
-		.profiling_info(ProfilingInfo::Queued)
-		.unwrap()
-		.time()
-		.unwrap();
-	let start = ev
-		.profiling_info(ProfilingInfo::Start)
-		.unwrap()
-		.time()
-		.unwrap();
-	let end = ev
-		.profiling_info(ProfilingInfo::End)
-		.unwrap()
-		.time()
-		.unwrap();
-	println!(
-		"{}\t total {}ms \t queued->submit {}mc \t submit->start {}ms \t start->end {}ms",
-		name,
-		(end - queued) / 1_000_000,
-		(submit - queued) / 1_000,
-		(start - submit) / 1_000_000,
-		(end - start) / 1_000_000
-	);
-}
-
-#[cfg(not(feature = "profile"))]
-fn print_event(_name: &str, _ev: &Event) {}
-
-fn find_paltform(selector: Option<&str>) -> Option<Platform> {
-	match selector {
-		None => Some(Platform::default()),
-		Some(sel) => Platform::list().into_iter().find(|p| {
-			if let Ok(vendor) = p.name() {
-				vendor.contains(sel)
-			} else {
-				false
-			}
-		}),
-	}
-}
-
-fn find_device(platform: &Platform, selector: Option<usize>) -> ocl::Result<Device> {
-	match selector {
-		None => Device::first(platform),
-		Some(index) => Device::by_idx_wrap(platform, index),
-	}
-}
-
-const SRC: &str = r#"
-// Cuckaroo Cycle, a memory-hard proof-of-work by John Tromp and team Grin
-// Copyright (c) 2018 Jiri Photon Vadura and John Tromp
-// This GGM miner file is covered by the FAIR MINING license
-
-#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable
-#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable
-
-typedef uint8 u8;
-typedef uint16 u16;
-typedef uint u32;
-typedef ulong u64;
-
-typedef u32 node_t;
-typedef u64 nonce_t;
-
-
-#define DUCK_SIZE_A 129L
-#define DUCK_SIZE_B 83L
-
-#define DUCK_A_EDGES (DUCK_SIZE_A * 1024L)
-#define DUCK_A_EDGES_64 (DUCK_A_EDGES * 64L)
-
-#define DUCK_B_EDGES (DUCK_SIZE_B * 1024L)
-#define DUCK_B_EDGES_64 (DUCK_B_EDGES * 64L)
-
-#define EDGE_BLOCK_SIZE (64)
-#define EDGE_BLOCK_MASK (EDGE_BLOCK_SIZE - 1)
-
-#define EDGEBITS 29
-// number of edges
-#define NEDGES ((node_t)1 << EDGEBITS)
-// used to mask siphash output
-#define EDGEMASK (NEDGES - 1)
-
-#define CTHREADS 1024
-#define BKTMASK4K (4096-1)
-#define BKTGRAN 32
-
-#define SIPROUND \
-  do { \
-    v0 += v1; v2 += v3; v1 = rotate(v1,(ulong)13); \
-    v3 = rotate(v3,(ulong)16); v1 ^= v0; v3 ^= v2; \
-    v0 = rotate(v0,(ulong)32); v2 += v1; v0 += v3; \
-    v1 = rotate(v1,(ulong)17);   v3 = rotate(v3,(ulong)21); \
-    v1 ^= v2; v3 ^= v0; v2 = rotate(v2,(ulong)32); \
-  } while(0)
-
-
-void Increase2bCounter(__local u32 * ecounters, const int bucket)
-{
-	int word = bucket >> 5;
-	unsigned char bit = bucket & 0x1F;
-	u32 mask = 1 << bit;
-
-	u32 old = atomic_or(ecounters + word, mask) & mask;
-
-	if (old > 0)
-		atomic_or(ecounters + word + 4096, mask);
-}
-
-bool Read2bCounter(__local u32 * ecounters, const int bucket)
-{
-	int word = bucket >> 5;
-	unsigned char bit = bucket & 0x1F;
-	u32 mask = 1 << bit;
-
-	return (ecounters[word + 4096] & mask) > 0;
-}
-
-__attribute__((reqd_work_group_size(128, 1, 1)))
-__kernel  void FluffySeed2A(const u64 v0i, const u64 v1i, const u64 v2i, const u64 v3i, __global ulong4 * bufferA, __global ulong4 * bufferB, __global u32 * indexes)
-{
-	const int gid = get_global_id(0);
-	const short lid = get_local_id(0);
-
-	__global ulong4 * buffer;
-	__local u64 tmp[64][16];
-	__local u32 counters[64];
-	u64 sipblock[64];
-
-	u64 v0;
-	u64 v1;
-	u64 v2;
-	u64 v3;
-
-	if (lid < 64)
-		counters[lid] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < 1024 * 2; i += EDGE_BLOCK_SIZE)
-	{
-		u64 blockNonce = gid * (1024 * 2) + i;
-
-		v0 = v0i;
-		v1 = v1i;
-		v2 = v2i;
-		v3 = v3i;
-
-		for (u32 b = 0; b < EDGE_BLOCK_SIZE; b++)
-		{
-			v3 ^= blockNonce + b;
-			for (int r = 0; r < 2; r++)
-				SIPROUND;
-			v0 ^= blockNonce + b;
-			v2 ^= 0xff;
-			for (int r = 0; r < 4; r++)
-				SIPROUND;
-
-			sipblock[b] = (v0 ^ v1) ^ (v2  ^ v3);
-
-		}
-		u64 last = sipblock[EDGE_BLOCK_MASK];
-
-		for (short s = 0; s < EDGE_BLOCK_SIZE; s++)
-		{
-			u64 lookup = s == EDGE_BLOCK_MASK ? last : sipblock[s] ^ last;
-			uint2 hash = (uint2)(lookup & EDGEMASK, (lookup >> 32) & EDGEMASK);
-			int bucket = hash.x & 63;
-
-			barrier(CLK_LOCAL_MEM_FENCE);
-
-			int counter = atomic_add(counters + bucket, (u32)1);
-			int counterLocal = counter % 16;
-			tmp[bucket][counterLocal] = hash.x | ((u64)hash.y << 32);
-
-			barrier(CLK_LOCAL_MEM_FENCE);
-
-			if ((counter > 0) && (counterLocal == 0 || counterLocal == 8))
-			{
-				int cnt = min((int)atomic_add(indexes + bucket, 8), (int)(DUCK_A_EDGES_64 - 8));
-				int idx = ((bucket < 32 ? bucket : bucket - 32) * DUCK_A_EDGES_64 + cnt) / 4;
-				buffer = bucket < 32 ? bufferA : bufferB;
-
-				buffer[idx] = (ulong4)(
-					atom_xchg(&tmp[bucket][8 - counterLocal], (u64)0),
-					atom_xchg(&tmp[bucket][9 - counterLocal], (u64)0),
-					atom_xchg(&tmp[bucket][10 - counterLocal], (u64)0),
-					atom_xchg(&tmp[bucket][11 - counterLocal], (u64)0)
-				);
-				buffer[idx + 1] = (ulong4)(
-					atom_xchg(&tmp[bucket][12 - counterLocal], (u64)0),
-					atom_xchg(&tmp[bucket][13 - counterLocal], (u64)0),
-					atom_xchg(&tmp[bucket][14 - counterLocal], (u64)0),
-					atom_xchg(&tmp[bucket][15 - counterLocal], (u64)0)
-				);
-			}
-
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	if (lid < 64)
-	{
-		int counter = counters[lid];
-		int counterBase = (counter % 16) >= 8 ? 8 : 0;
-		int counterCount = (counter % 8);
-		for (int i = 0; i < (8 - counterCount); i++)
-			tmp[lid][counterBase + counterCount + i] = 0;
-		int cnt = min((int)atomic_add(indexes + lid, 8), (int)(DUCK_A_EDGES_64 - 8));
-		int idx = ( (lid < 32 ? lid : lid - 32) * DUCK_A_EDGES_64 + cnt) / 4;
-		buffer = lid < 32 ? bufferA : bufferB;
-		buffer[idx] = (ulong4)(tmp[lid][counterBase], tmp[lid][counterBase + 1], tmp[lid][counterBase + 2], tmp[lid][counterBase + 3]);
-		buffer[idx + 1] = (ulong4)(tmp[lid][counterBase + 4], tmp[lid][counterBase + 5], tmp[lid][counterBase + 6], tmp[lid][counterBase + 7]);
-	}
-
-}
-
-__attribute__((reqd_work_group_size(128, 1, 1)))
-__kernel  void FluffySeed2B(const __global uint2 * source, __global ulong4 * destination1, __global ulong4 * destination2, const __global int * sourceIndexes, __global int * destinationIndexes, int startBlock)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	__global ulong4 * destination = destination1;
-	__local u64 tmp[64][16];
-	__local int counters[64];
-
-	if (lid < 64)
-		counters[lid] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	int offsetMem = startBlock * DUCK_A_EDGES_64;
-	int offsetBucket = 0;
-	const int myBucket = group / BKTGRAN;
-	const int microBlockNo = group % BKTGRAN;
-	const int bucketEdges = min(sourceIndexes[myBucket + startBlock], (int)(DUCK_A_EDGES_64));
-	const int microBlockEdgesCount = (DUCK_A_EDGES_64 / BKTGRAN);
-	const int loops = (microBlockEdgesCount / 128);
-
-	if ((startBlock == 32) && (myBucket >= 30))
-	{
-		offsetMem = 0;
-		destination = destination2;
-		offsetBucket = 30;
-	}
-
-	for (int i = 0; i < loops; i++)
-	{
-		int edgeIndex = (microBlockNo * microBlockEdgesCount) + (128 * i) + lid;
-
-		{
-			uint2 edge = source[/*offsetMem + */(myBucket * DUCK_A_EDGES_64) + edgeIndex];
-			bool skip = (edgeIndex >= bucketEdges) || (edge.x == 0 && edge.y == 0);
-
-			int bucket = (edge.x >> 6) & (64 - 1);
-
-			barrier(CLK_LOCAL_MEM_FENCE);
-
-			int counter = 0;
-			int counterLocal = 0;
-
-			if (!skip)
-			{
-				counter = atomic_add(counters + bucket, (u32)1);
-				counterLocal = counter % 16;
-				tmp[bucket][counterLocal] = edge.x | ((u64)edge.y << 32);
-			}
-
-			barrier(CLK_LOCAL_MEM_FENCE);
-
-			if ((counter > 0) && (counterLocal == 0 || counterLocal == 8))
-			{
-				int cnt = min((int)atomic_add(destinationIndexes + startBlock * 64 + myBucket * 64 + bucket, 8), (int)(DUCK_A_EDGES - 8));
-				int idx = (offsetMem + (((myBucket - offsetBucket) * 64 + bucket) * DUCK_A_EDGES + cnt)) / 4;
-
-				destination[idx] = (ulong4)(
-					atom_xchg(&tmp[bucket][8 - counterLocal], 0),
-					atom_xchg(&tmp[bucket][9 - counterLocal], 0),
-					atom_xchg(&tmp[bucket][10 - counterLocal], 0),
-					atom_xchg(&tmp[bucket][11 - counterLocal], 0)
-				);
-				destination[idx + 1] = (ulong4)(
-					atom_xchg(&tmp[bucket][12 - counterLocal], 0),
-					atom_xchg(&tmp[bucket][13 - counterLocal], 0),
-					atom_xchg(&tmp[bucket][14 - counterLocal], 0),
-					atom_xchg(&tmp[bucket][15 - counterLocal], 0)
-				);
-			}
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	if (lid < 64)
-	{
-		int counter = counters[lid];
-		int counterBase = (counter % 16) >= 8 ? 8 : 0;
-		int cnt = min((int)atomic_add(destinationIndexes + startBlock * 64 + myBucket * 64 + lid, 8), (int)(DUCK_A_EDGES - 8));
-		int idx = (offsetMem + (((myBucket - offsetBucket) * 64 + lid) * DUCK_A_EDGES + cnt)) / 4;
-		destination[idx] = (ulong4)(tmp[lid][counterBase], tmp[lid][counterBase + 1], tmp[lid][counterBase + 2], tmp[lid][counterBase + 3]);
-		destination[idx + 1] = (ulong4)(tmp[lid][counterBase + 4], tmp[lid][counterBase + 5], tmp[lid][counterBase + 6], tmp[lid][counterBase + 7]);
-	}
-}
-
-__attribute__((reqd_work_group_size(1024, 1, 1)))
-__kernel   void FluffyRound1(const __global uint2 * source1, const __global uint2 * source2, __global uint2 * destination, const __global int * sourceIndexes, __global int * destinationIndexes, const int bktInSize, const int bktOutSize)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	const __global uint2 * source = group < (62 * 64) ? source1 : source2;
-	int groupRead                 = group < (62 * 64) ? group : group - (62 * 64);
-
-	__local u32 ecounters[8192];
-
-	const int edgesInBucket = min(sourceIndexes[group], bktInSize);
-	const int loops = (edgesInBucket + CTHREADS) / CTHREADS;
-
-	for (int i = 0; i < 8; i++)
-		ecounters[lid + (1024 * i)] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-
-			const int index = (bktInSize * groupRead) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			Increase2bCounter(ecounters, (edge.x & EDGEMASK) >> 12);
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-			const int index = (bktInSize * groupRead) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			if (Read2bCounter(ecounters, (edge.x & EDGEMASK) >> 12))
-			{
-				const int bucket = edge.y & BKTMASK4K;
-				const int bktIdx = min(atomic_add(destinationIndexes + bucket, 1), bktOutSize - 1);
-				destination[(bucket * bktOutSize) + bktIdx] = (uint2)(edge.y, edge.x);
-			}
-		}
-	}
-
-}
-
-__attribute__((reqd_work_group_size(1024, 1, 1)))
-__kernel   void FluffyRoundN(const __global uint2 * source, __global uint2 * destination, const __global int * sourceIndexes, __global int * destinationIndexes)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	const int bktInSize = DUCK_B_EDGES;
-	const int bktOutSize = DUCK_B_EDGES;
-
-	__local u32 ecounters[8192];
-
-	const int edgesInBucket = min(sourceIndexes[group], bktInSize);
-	const int loops = (edgesInBucket + CTHREADS) / CTHREADS;
-
-	for (int i = 0; i < 8; i++)
-		ecounters[lid + (1024 * i)] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-
-			const int index = (bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			Increase2bCounter(ecounters, (edge.x & EDGEMASK) >> 12);
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-			const int index = (bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			if (Read2bCounter(ecounters, (edge.x & EDGEMASK) >> 12))
-			{
-				const int bucket = edge.y & BKTMASK4K;
-				const int bktIdx = min(atomic_add(destinationIndexes + bucket, 1), bktOutSize - 1);
-				destination[(bucket * bktOutSize) + bktIdx] = (uint2)(edge.y, edge.x);
-			}
-		}
-	}
-
-}
-
-__attribute__((reqd_work_group_size(64, 1, 1)))
-__kernel   void FluffyRoundN_64(const __global uint2 * source, __global uint2 * destination, const __global int * sourceIndexes, __global int * destinationIndexes)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	const int bktInSize = DUCK_B_EDGES;
-	const int bktOutSize = DUCK_B_EDGES;
-
-	__local u32 ecounters[8192];
-
-	const int edgesInBucket = min(sourceIndexes[group], bktInSize);
-	const int loops = (edgesInBucket + 64) / 64;
-
-	for (int i = 0; i < 8*16; i++)
-		ecounters[lid + (64 * i)] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * 64) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-
-			const int index = (bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			Increase2bCounter(ecounters, (edge.x & EDGEMASK) >> 12);
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * 64) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-			const int index = (bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			if (Read2bCounter(ecounters, (edge.x & EDGEMASK) >> 12))
-			{
-				const int bucket = edge.y & BKTMASK4K;
-				const int bktIdx = min(atomic_add(destinationIndexes + bucket, 1), bktOutSize - 1);
-				destination[(bucket * bktOutSize) + bktIdx] = (uint2)(edge.y, edge.x);
-			}
-		}
-	}
-
-}
-
-__attribute__((reqd_work_group_size(1024, 1, 1)))
-__kernel void FluffyTail(const __global uint2 * source, __global uint2 * destination, const __global int * sourceIndexes, __global int * destinationIndexes)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	int myEdges = sourceIndexes[group];
-	__local int destIdx;
-
-	if (lid == 0)
-		destIdx = atomic_add(destinationIndexes, myEdges);
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	if (lid < myEdges)
-	{
-		destination[destIdx + lid] = source[group * DUCK_B_EDGES + lid];
-	}
-}
-
-__attribute__((reqd_work_group_size(256, 1, 1)))
-__kernel   void FluffyRecovery(const u64 v0i, const u64 v1i, const u64 v2i, const u64 v3i, const __constant u64 * recovery, __global int * indexes)
-{
-	const int gid = get_global_id(0);
-	const short lid = get_local_id(0);
-
-	__local u32 nonces[42];
-	u64 sipblock[64];
-
-	u64 v0;
-	u64 v1;
-	u64 v2;
-	u64 v3;
-
-	if (lid < 42) nonces[lid] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < 1024; i += EDGE_BLOCK_SIZE)
-	{
-		u64 blockNonce = gid * 1024 + i;
-
-		v0 = v0i;
-		v1 = v1i;
-		v2 = v2i;
-		v3 = v3i;
-
-		for (u32 b = 0; b < EDGE_BLOCK_SIZE; b++)
-		{
-			v3 ^= blockNonce + b;
-			SIPROUND; SIPROUND;
-			v0 ^= blockNonce + b;
-			v2 ^= 0xff;
-			SIPROUND; SIPROUND; SIPROUND; SIPROUND;
-
-			sipblock[b] = (v0 ^ v1) ^ (v2  ^ v3);
-
-		}
-		const u64 last = sipblock[EDGE_BLOCK_MASK];
-
-		for (short s = EDGE_BLOCK_MASK; s >= 0; s--)
-		{
-			u64 lookup = s == EDGE_BLOCK_MASK ? last : sipblock[s] ^ last;
-			u64 u = lookup & EDGEMASK;
-			u64 v = (lookup >> 32) & EDGEMASK;
-
-			u64 a = u | (v << 32);
-			u64 b = v | (u << 32);
-
-			for (int i = 0; i < 42; i++)
-			{
-				if ((recovery[i] == a) || (recovery[i] == b))
-					nonces[i] = blockNonce + s;
-			}
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	if (lid < 42)
-	{
-		if (nonces[lid] > 0)
-			indexes[lid] = nonces[lid];
-	}
-}
-
-
-
-// ---------------
-#define BKT_OFFSET 255
-#define BKT_STEP 32
-__attribute__((reqd_work_group_size(1024, 1, 1)))
-__kernel   void FluffyRoundNO1(const __global uint2 * source, __global uint2 * destination, const __global int * sourceIndexes, __global int * destinationIndexes)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	const int bktInSize = DUCK_B_EDGES;
-	const int bktOutSize = DUCK_B_EDGES;
-
-	__local u32 ecounters[8192];
-
-	const int edgesInBucket = min(sourceIndexes[group], bktInSize);
-	const int loops = (edgesInBucket + CTHREADS) / CTHREADS;
-
-	for (int i = 0; i < 8; i++)
-		ecounters[lid + (1024 * i)] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-
-			const int index =(bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			Increase2bCounter(ecounters, (edge.x & EDGEMASK) >> 12);
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-			const int index = (bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			if (Read2bCounter(ecounters, (edge.x & EDGEMASK) >> 12))
-			{
-				const int bucket = edge.y & BKTMASK4K;
-				const int bktIdx = min(atomic_add(destinationIndexes + bucket, 1), bktOutSize - 1 - ((bucket & BKT_OFFSET) * BKT_STEP));
-				destination[((bucket & BKT_OFFSET) * BKT_STEP) + (bucket * bktOutSize) + bktIdx] = (uint2)(edge.y, edge.x);
-			}
-		}
-	}
-
-}
-
-__attribute__((reqd_work_group_size(1024, 1, 1)))
-__kernel   void FluffyRoundNON(const __global uint2 * source, __global uint2 * destination, const __global int * sourceIndexes, __global int * destinationIndexes)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	const int bktInSize = DUCK_B_EDGES;
-	const int bktOutSize = DUCK_B_EDGES;
-
-	__local u32 ecounters[8192];
-
-	const int edgesInBucket = min(sourceIndexes[group], bktInSize);
-	const int loops = (edgesInBucket + CTHREADS) / CTHREADS;
-
-	for (int i = 0; i < 8; i++)
-		ecounters[lid + (1024 * i)] = 0;
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-
-			const int index = ((group & BKT_OFFSET) * BKT_STEP) + (bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			Increase2bCounter(ecounters, (edge.x & EDGEMASK) >> 12);
-		}
-	}
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	for (int i = 0; i < loops; i++)
-	{
-		const int lindex = (i * CTHREADS) + lid;
-
-		if (lindex < edgesInBucket)
-		{
-			const int index = ((group & BKT_OFFSET) * BKT_STEP) + (bktInSize * group) + lindex;
-
-			uint2 edge = source[index];
-
-			if (edge.x == 0 && edge.y == 0) continue;
-
-			if (Read2bCounter(ecounters, (edge.x & EDGEMASK) >> 12))
-			{
-				const int bucket = edge.y & BKTMASK4K;
-				const int bktIdx = min(atomic_add(destinationIndexes + bucket, 1), bktOutSize - 1 - ((bucket & BKT_OFFSET) * BKT_STEP));
-				destination[((bucket & BKT_OFFSET) * BKT_STEP) + (bucket * bktOutSize) + bktIdx] = (uint2)(edge.y, edge.x);
-			}
-		}
-	}
-
-}
-
-__attribute__((reqd_work_group_size(1024, 1, 1)))
-__kernel void FluffyTailO(const __global uint2 * source, __global uint2 * destination, const __global int * sourceIndexes, __global int * destinationIndexes)
-{
-	const int lid = get_local_id(0);
-	const int group = get_group_id(0);
-
-	int myEdges = sourceIndexes[group];
-	__local int destIdx;
-
-	if (lid == 0)
-		destIdx = atomic_add(destinationIndexes, myEdges);
-
-	barrier(CLK_LOCAL_MEM_FENCE);
-
-	if (lid < myEdges)
-	{
-		destination[destIdx + lid] = source[((group & BKT_OFFSET) * BKT_STEP) + group * DUCK_B_EDGES + lid];
-	}
-}
-
-"#;
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckatoo/Cargo.toml grin-miner-copy/ocl_cuckatoo/Cargo.toml
--- grin-miner-1.0.2/ocl_cuckatoo/Cargo.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckatoo/Cargo.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-[package]
-name = "ocl_cuckatoo"
-version = "1.0.2"
-workspace = ".."
-
-[dependencies]
-grin_miner_plugin = { path = "../plugin", version = "1.0.2" }
-ocl = "0.19"
-hashbrown = "0.1"
-libc = "0.2.24"
-blake2-rfc = "0.2"
-byteorder = "1"
-
-[lib]
-name = "ocl_cuckatoo"
-crate-type = ["cdylib", "rlib"]
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckatoo/.gitignore grin-miner-copy/ocl_cuckatoo/.gitignore
--- grin-miner-1.0.2/ocl_cuckatoo/.gitignore	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckatoo/.gitignore	1969-12-31 19:00:00.000000000 -0500
@@ -1,3 +0,0 @@
-/target
-**/*.rs.bk
-Cargo.lock
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckatoo/src/finder.rs grin-miner-copy/ocl_cuckatoo/src/finder.rs
--- grin-miner-1.0.2/ocl_cuckatoo/src/finder.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckatoo/src/finder.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,278 +0,0 @@
-use hashbrown::HashMap;
-
-#[derive(Clone)]
-pub struct Solution {
-	pub nonces: Vec<u64>,
-}
-
-pub struct Graph {
-	adj_index: HashMap<u32, usize>,
-	adj_store: Vec<AdjNode>,
-	nonces: HashMap<(u32, u32), u32>,
-}
-
-struct Search {
-	length: usize,
-	path: Vec<u32>,
-	solutions: Vec<Solution>,
-
-	state: HashMap<u32, NodeState>,
-	node_visited: usize,
-	node_explored: usize,
-}
-
-#[derive(Clone, Copy)]
-enum NodeState {
-	NotVisited,
-	Visited,
-	Explored,
-}
-
-impl Search {
-	fn new(node_count: usize, length: usize) -> Search {
-		Search {
-			path: Vec::with_capacity(node_count),
-			solutions: vec![],
-			length: length * 2,
-			state: HashMap::with_capacity_and_hasher(node_count, Default::default()),
-			node_visited: 0,
-			node_explored: 0,
-		}
-	}
-
-	#[inline]
-	fn visit(&mut self, node: u32) {
-		self.state.insert(node, NodeState::Visited);
-		self.path.push(node);
-		self.node_visited += 1;
-	}
-
-	#[inline]
-	fn explore(&mut self, node: u32) {
-		self.state.insert(node, NodeState::Explored);
-		self.path.push(node);
-		self.node_explored += 1;
-	}
-
-	#[inline]
-	fn leave(&mut self, node: u32) {
-		self.path.pop();
-		self.state.insert(node, NodeState::NotVisited);
-	}
-
-	#[inline]
-	fn state(&self, node: u32) -> NodeState {
-		match self.state.get(&node) {
-			None => NodeState::NotVisited,
-			Some(state) => *state,
-		}
-	}
-
-	#[inline]
-	fn is_visited(&self, node: u32) -> bool {
-		match self.state(node) {
-			NodeState::NotVisited => false,
-			_ => true,
-		}
-	}
-
-	#[inline]
-	fn is_explored(&self, node: u32) -> bool {
-		match self.state(node) {
-			NodeState::Explored => true,
-			_ => false,
-		}
-	}
-
-	fn is_cycle(&mut self, node: u32, is_first: bool) -> bool {
-		let res =
-			self.path.len() > self.length - 1 && self.path[self.path.len() - self.length] == node;
-		if res && !is_first {
-			self.path.push(node);
-		}
-		res
-	}
-}
-
-struct AdjNode {
-	value: u32,
-	next: Option<usize>,
-}
-
-impl AdjNode {
-	#[inline]
-	fn first(value: u32) -> AdjNode {
-		AdjNode { value, next: None }
-	}
-
-	#[inline]
-	fn next(value: u32, next: usize) -> AdjNode {
-		AdjNode {
-			value,
-			next: Some(next),
-		}
-	}
-}
-
-struct AdjList<'a> {
-	current: Option<&'a AdjNode>,
-	adj_store: &'a Vec<AdjNode>,
-}
-
-impl<'a> AdjList<'a> {
-	#[inline]
-	pub fn new(current: Option<&'a AdjNode>, adj_store: &'a Vec<AdjNode>) -> AdjList<'a> {
-		AdjList { current, adj_store }
-	}
-}
-
-impl<'a> Iterator for AdjList<'a> {
-	type Item = u32;
-
-	fn next(&mut self) -> Option<Self::Item> {
-		match self.current {
-			None => None,
-			Some(node) => {
-				let val = node.value;
-				match node.next {
-					None => self.current = None,
-					Some(next_index) => self.current = Some(&self.adj_store[next_index]),
-				}
-				Some(val)
-			}
-		}
-	}
-}
-
-fn nonce_key(node1: u32, node2: u32) -> (u32, u32) {
-	if node1 < node2 {
-		(node1, node2)
-	} else {
-		(node2, node1)
-	}
-}
-
-impl Graph {
-	pub fn search(edges: &[u32]) -> Result<Vec<Solution>, String> {
-		let edge_count = edges[1] as usize;
-		let mut g = Graph {
-			adj_index: HashMap::with_capacity_and_hasher(edge_count * 2, Default::default()),
-			nonces: HashMap::with_capacity_and_hasher(edge_count, Default::default()),
-			adj_store: Vec::with_capacity(edge_count * 2),
-		};
-		let mut search = Search::new(edge_count * 2, 42);
-		const STEP: usize = 4;
-		for i in 1..=edge_count {
-			let n1 = edges[i * STEP];
-			let n2 = edges[i * STEP + 1];
-			let nonce = edges[i * STEP + 2];
-			g.add_edge(n1, n2);
-			g.nonces.insert(nonce_key(n1, n2), nonce);
-			g.check_pair(n1, n2, &mut search)?;
-		}
-
-		//	for i in 1..=edge_count {
-		//		let n1 = edges[i * STEP];
-		//		let n2 = edges[i * STEP + 1];
-		//	}
-		Ok(search.solutions.clone())
-	}
-
-	fn get_nonce(&self, node1: u32, node2: u32) -> Result<u64, String> {
-		match self.nonces.get(&nonce_key(node1, node2)) {
-			None => Err(format!("can not find  a nonce for {}:{}", node1, node2)),
-			Some(v) => Ok(*v as u64),
-		}
-	}
-
-	#[inline]
-	pub fn node_count(&self) -> usize {
-		self.adj_index.len()
-	}
-
-	#[inline]
-	pub fn edge_count(&self) -> usize {
-		self.adj_store.len() / 2
-	}
-
-	#[inline]
-	fn add_edge(&mut self, node1: u32, node2: u32) {
-		self.add_half_edge(node1, node2);
-		self.add_half_edge(node2, node1);
-	}
-
-	fn add_half_edge(&mut self, from: u32, to: u32) {
-		if let Some(index) = self.adj_index.get(&from) {
-			self.adj_store.push(AdjNode::next(to, *index));
-		} else {
-			self.adj_store.push(AdjNode::first(to));
-		}
-		self.adj_index.insert(from, self.adj_store.len() - 1);
-	}
-
-	fn neighbors(&self, node: u32) -> Option<impl Iterator<Item = u32> + '_> {
-		let node = match self.adj_index.get(&node) {
-			Some(index) => Some(&self.adj_store[*index]),
-			None => return None,
-		};
-		Some(AdjList::new(node, &self.adj_store))
-	}
-
-	#[inline]
-	fn nodes(&self) -> impl Iterator<Item = &u32> {
-		self.adj_index.keys()
-	}
-
-	fn check_pair(&self, u: u32, _v: u32, search: &mut Search) -> Result<(), String> {
-		self.walk_graph(u, search)
-		//self.walk_graph(v, search)
-	}
-
-	fn add_solution(&self, s: &mut Search) -> Result<(), String> {
-		let res: Result<Vec<_>, _> = s.path[s.path.len() - s.length..]
-			.chunks(2)
-			.map(|pair| match pair {
-				&[n1, n2] => self.get_nonce(n1, n2),
-				_ => Err("not an edge".to_string()),
-			})
-			.collect();
-		let mut nonces = match res {
-			Ok(v) => v,
-			Err(e) => {
-				return Err(format!("Failed to get nonce {:?}", e));
-			}
-		};
-		nonces.sort();
-		let sol = Solution { nonces };
-		s.solutions.push(sol);
-		Ok(())
-	}
-
-	fn walk_graph(&self, current: u32, search: &mut Search) -> Result<(), String> {
-		if search.is_explored(current) || search.path.len() > 84 {
-			if search.is_cycle(current, true) {
-				self.add_solution(search)?;
-			}
-			return Ok(());
-		}
-
-		let neighbors = match self.neighbors(current) {
-			None => return Ok(()),
-			Some(it) => it,
-		};
-		search.explore(current);
-		for ns in neighbors {
-			if !search.is_visited(ns) {
-				search.visit(ns);
-				self.walk_graph(ns ^ 1, search)?;
-				search.leave(ns);
-			} else {
-				if search.is_cycle(ns, false) {
-					self.add_solution(search)?;
-				}
-			}
-		}
-		search.leave(current);
-		Ok(())
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckatoo/src/lib.rs grin-miner-copy/ocl_cuckatoo/src/lib.rs
--- grin-miner-1.0.2/ocl_cuckatoo/src/lib.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckatoo/src/lib.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,178 +0,0 @@
-extern crate blake2_rfc;
-extern crate byteorder;
-extern crate grin_miner_plugin as plugin;
-extern crate hashbrown;
-extern crate libc;
-extern crate ocl;
-
-use blake2_rfc::blake2b::blake2b;
-use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
-use libc::*;
-use plugin::*;
-use std::io::Cursor;
-use std::io::Error;
-use std::mem;
-use std::ptr;
-use std::time::{Duration, SystemTime};
-
-pub use self::finder::Graph;
-pub use self::trimmer::Trimmer;
-
-mod finder;
-mod trimmer;
-
-#[repr(C)]
-struct Solver {
-	trimmer: Trimmer,
-	graph: Option<Graph>,
-	mutate_nonce: bool,
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn create_solver_ctx(params: *mut SolverParams) -> *mut SolverCtx {
-	let platform = match (*params).platform {
-		1 => Some("AMD"),
-		2 => Some("NVIDIA"),
-		_ => None,
-	};
-	let device_id = Some((*params).device as usize);
-	let mut edge_bits = (*params).edge_bits as u8;
-	if edge_bits < 31 || edge_bits > 64 {
-		edge_bits = 31;
-	}
-	let trimmer = Trimmer::build(platform, device_id, edge_bits).expect("can't build trimmer");
-	let solver = Solver {
-		trimmer: trimmer,
-		graph: None,
-		mutate_nonce: (*params).mutate_nonce,
-	};
-	let solver_box = Box::new(solver);
-	let solver_ref = Box::leak(solver_box);
-	mem::transmute::<&mut Solver, *mut SolverCtx>(solver_ref)
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn destroy_solver_ctx(solver_ctx_ptr: *mut SolverCtx) {
-	// create box to clear memory
-	let solver_ptr = mem::transmute::<*mut SolverCtx, *mut Solver>(solver_ctx_ptr);
-	let _solver_box = Box::from_raw(solver_ptr);
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn stop_solver(_solver_ctx_ptr: *mut SolverCtx) {}
-
-#[no_mangle]
-pub unsafe extern "C" fn fill_default_params(params: *mut SolverParams) {
-	(*params).device = 0;
-	(*params).platform = 0;
-	(*params).edge_bits = 31;
-}
-
-#[no_mangle]
-pub unsafe extern "C" fn run_solver(
-	ctx: *mut SolverCtx,
-	header_ptr: *const c_uchar,
-	header_length: uint32_t,
-	nonce: uint64_t,
-	_range: uint32_t,
-	solutions: *mut SolverSolutions,
-	stats: *mut SolverStats,
-) -> uint32_t {
-	let start = SystemTime::now();
-	let solver_ptr = mem::transmute::<*mut SolverCtx, *mut Solver>(ctx);
-	let solver = &*solver_ptr;
-	let mut header = Vec::with_capacity(header_length as usize);
-	let r_ptr = header.as_mut_ptr();
-	ptr::copy_nonoverlapping(header_ptr, r_ptr, header_length as usize);
-	header.set_len(header_length as usize);
-	let n = nonce as u32;
-	let k = match set_header_nonce(&header, Some(n), solver.mutate_nonce) {
-		Err(_e) => {
-			return 2;
-		}
-		Ok(v) => v,
-	};
-	let res = solver.trimmer.run(&k).unwrap();
-
-	let sols = Graph::search(&res).unwrap();
-	let end = SystemTime::now();
-	let elapsed = end.duration_since(start).unwrap();
-	let mut i = 0;
-	(*solutions).edge_bits = 31;
-	(*solutions).num_sols = sols.len() as u32;
-	for sol in sols {
-		(*solutions).sols[i].nonce = nonce;
-		(*solutions).sols[i]
-			.proof
-			.copy_from_slice(&sol.nonces[..sol.nonces.len()]);
-		i += 1;
-	}
-	(*stats).edge_bits = 31;
-	(*stats).device_id = solver.trimmer.device_id as u32;
-	let name_bytes = solver.trimmer.device_name.as_bytes();
-	let n = std::cmp::min((*stats).device_name.len(), name_bytes.len());
-	(*stats).device_name[..n].copy_from_slice(&solver.trimmer.device_name.as_bytes()[..n]);
-	(*stats).last_solution_time = duration_to_u64(elapsed);
-	(*stats).last_start_time =
-		duration_to_u64(start.duration_since(SystemTime::UNIX_EPOCH).unwrap());
-	(*stats).last_end_time = duration_to_u64(end.duration_since(SystemTime::UNIX_EPOCH).unwrap());
-	0
-}
-
-fn duration_to_u64(elapsed: Duration) -> u64 {
-	elapsed.as_secs() * 1_000_000_000 + elapsed.subsec_nanos() as u64
-}
-
-pub fn set_header_nonce(
-	header: &[u8],
-	nonce: Option<u32>,
-	mutate_nonce: bool,
-) -> Result<[u64; 4], Error> {
-	if let Some(n) = nonce {
-		let len = header.len();
-		let mut header = header.to_owned();
-		if mutate_nonce {
-			header.truncate(len - 4);
-			header.write_u32::<LittleEndian>(n)?;
-		}
-		create_siphash_keys(&header)
-	} else {
-		create_siphash_keys(&header)
-	}
-}
-
-pub fn create_siphash_keys(header: &[u8]) -> Result<[u64; 4], Error> {
-	let h = blake2b(32, &[], &header);
-	let hb = h.as_bytes();
-	let mut rdr = Cursor::new(hb);
-	Ok([
-		rdr.read_u64::<LittleEndian>()?,
-		rdr.read_u64::<LittleEndian>()?,
-		rdr.read_u64::<LittleEndian>()?,
-		rdr.read_u64::<LittleEndian>()?,
-	])
-}
-
-#[cfg(test)]
-mod tests {
-	use super::*;
-	#[test]
-	fn test_solve() {
-		let trimmer = Trimmer::build(None, None, 29).expect("can't build trimmer");
-		let k = [
-			0x27580576fe290177,
-			0xf9ea9b2031f4e76e,
-			0x1663308c8607868f,
-			0xb88839b0fa180d0e,
-		];
-
-		let res = trimmer.run(&k).unwrap();
-		println!("Trimmed to {}", res.len());
-
-		let sols = Graph::search(&res).unwrap();
-		assert_eq!(1, sols.len());
-		for sol in sols {
-			println!("Solution: {:x?}", sol.nonces);
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/ocl_cuckatoo/src/trimmer.rs grin-miner-copy/ocl_cuckatoo/src/trimmer.rs
--- grin-miner-1.0.2/ocl_cuckatoo/src/trimmer.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/ocl_cuckatoo/src/trimmer.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,327 +0,0 @@
-use ocl;
-use ocl::{Buffer, Context, Device, Kernel, Platform, Program, Queue, SpatialDims};
-
-const RES_BUFFER_SIZE: usize = 4_000_000;
-const LOCAL_WORK_SIZE: usize = 256;
-const GLOBAL_WORK_SIZE: usize = 1024 * LOCAL_WORK_SIZE;
-
-enum Mode {
-	SetCnt = 1,
-	Trim = 2,
-	Extract = 3,
-}
-
-pub struct Trimmer {
-	edge_bits: u8,
-	q: Queue,
-	program: Program,
-	edges: Buffer<u32>,
-	counters: Buffer<u32>,
-	result: Buffer<u32>,
-	res_buf: Vec<u32>,
-	pub device_name: String,
-	pub device_id: usize,
-}
-
-impl Trimmer {
-	pub fn build(
-		platform_name: Option<&str>,
-		device_id: Option<usize>,
-		edge_bits: u8,
-	) -> ocl::Result<Trimmer> {
-		let platform = find_paltform(platform_name)
-			.ok_or::<ocl::Error>("Can't find OpenCL platform".into())?;
-		let device = find_device(&platform, device_id)?;
-
-		let el_count = (1024 * 1024 * 16) << (edge_bits - 29);
-		let res_buf: Vec<u32> = vec![0; RES_BUFFER_SIZE];
-
-		let context = Context::builder()
-			.platform(platform)
-			.devices(device)
-			.build()?;
-
-		let q = Queue::new(&context, device, None)?;
-
-		let program = Program::builder()
-			.devices(device)
-			.src(SRC)
-			.cmplr_def("EDGEBITS", edge_bits as i32)
-			.build(&context)?;
-
-		let edges = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(el_count)
-			.fill_val(0xFFFFFFFF)
-			.build()?;
-		let counters = Buffer::<u32>::builder()
-			.queue(q.clone())
-			.len(el_count)
-			.fill_val(0)
-			.build()?;
-		let result = unsafe {
-			Buffer::<u32>::builder()
-				.queue(q.clone())
-				.len(RES_BUFFER_SIZE)
-				.fill_val(0)
-				.use_host_slice(&res_buf[..])
-				.build()?
-		};
-
-		Ok(Trimmer {
-			edge_bits,
-			q,
-			program,
-			edges,
-			counters,
-			result,
-			res_buf,
-			device_name: device.name()?,
-			device_id: device_id.unwrap_or(0),
-		})
-	}
-
-	pub fn run(&self, k: &[u64; 4]) -> ocl::Result<Vec<u32>> {
-		let mut current_mode = Mode::SetCnt;
-		let mut current_uorv: u32 = 0;
-		let trims = if self.edge_bits >= 29 { 128 } else { 256 };
-		let enqs = 8 << (self.edge_bits - 29);
-
-		let mut kernel = Kernel::builder()
-			.name("LeanRound")
-			.program(&self.program)
-			.queue(self.q.clone())
-			.global_work_size(GLOBAL_WORK_SIZE)
-			.local_work_size(SpatialDims::One(LOCAL_WORK_SIZE))
-			.arg(k[0])
-			.arg(k[1])
-			.arg(k[2])
-			.arg(k[3])
-			.arg(&self.edges)
-			.arg(&self.counters)
-			.arg(&self.result)
-			.arg(current_mode as u32)
-			.arg(current_uorv)
-			.build()?;
-
-		let mut offset;
-
-		macro_rules! kernel_enq (
-        ($num:expr) => (
-        for i in 0..$num {
-            offset = i * GLOBAL_WORK_SIZE;
-            unsafe {
-                kernel
-                    .set_default_global_work_offset(SpatialDims::One(offset))
-                    .enq()?;
-            }
-        }
-        ));
-
-		for l in 0..trims {
-			current_uorv = l & 1 as u32;
-			current_mode = Mode::SetCnt;
-			kernel.set_arg(7, current_mode as u32)?;
-			kernel.set_arg(8, current_uorv)?;
-			kernel_enq!(enqs);
-
-			current_mode = if l == (trims - 1) {
-				Mode::Extract
-			} else {
-				Mode::Trim
-			};
-			kernel.set_arg(7, current_mode as u32)?;
-			kernel_enq!(enqs);
-			// prepare for the next round
-			self.counters.cmd().fill(0, None).enq()?;
-		}
-		unsafe {
-			self.result.map().enq()?;
-		}
-		self.q.finish()?;
-		let ret = self.res_buf.clone();
-		self.edges.cmd().fill(0xFFFFFFFF, None).enq()?;
-		self.result.cmd().fill(0, None).enq()?;
-		self.q.finish()?;
-		Ok(ret)
-	}
-}
-
-fn find_paltform(selector: Option<&str>) -> Option<Platform> {
-	match selector {
-		None => Some(Platform::default()),
-		Some(sel) => Platform::list().into_iter().find(|p| {
-			if let Ok(vendor) = p.name() {
-				vendor.contains(sel)
-			} else {
-				false
-			}
-		}),
-	}
-}
-
-fn find_device(platform: &Platform, selector: Option<usize>) -> ocl::Result<Device> {
-	match selector {
-		None => Device::first(platform),
-		Some(index) => Device::by_idx_wrap(platform, index),
-	}
-}
-
-const SRC: &str = r#"
-typedef uint8 u8;
-typedef uint16 u16;
-typedef uint u32;
-typedef ulong u64;
-typedef u32 node_t;
-typedef u64 nonce_t;
-
-#define DEBUG 0
-
-// number of edges
-#define NEDGES ((u64)1 << EDGEBITS)
-// used to mask siphash output
-#define EDGEMASK (NEDGES - 1)
-
-#define SIPROUND \
-  do { \
-    v0 += v1; v2 += v3; v1 = rotate(v1,(ulong)13); \
-    v3 = rotate(v3,(ulong)16); v1 ^= v0; v3 ^= v2; \
-    v0 = rotate(v0,(ulong)32); v2 += v1; v0 += v3; \
-    v1 = rotate(v1,(ulong)17);   v3 = rotate(v3,(ulong)21); \
-    v1 ^= v2; v3 ^= v0; v2 = rotate(v2,(ulong)32); \
-  } while(0)
-
-u64 dipnode(ulong v0i, ulong v1i, ulong v2i, ulong v3i, u64 nce, uint uorv) {
-	ulong nonce = 2 * nce + uorv;
-	ulong v0 = v0i, v1 = v1i, v2 = v2i, v3 = v3i ^ nonce;
-	SIPROUND; SIPROUND;
-	v0 ^= nonce;
-	v2 ^= 0xff;
-	SIPROUND; SIPROUND; SIPROUND; SIPROUND;
-	return (v0 ^ v1 ^ v2  ^ v3) & EDGEMASK;
-}
-
-#define MODE_SETCNT 1
-#define MODE_TRIM 2
-#define MODE_EXTRACT 3
-
-// Minimalistic cuckatoo lean trimmer
-// This implementation is not optimal!
-//
-// 8 global kernel executions (hardcoded ATM)
-// 1024 thread blocks, 256 threads each, 256 edges for each thread
-// 8*1024*256*256 = 536 870 912 edges = cuckatoo29
-__attribute__((reqd_work_group_size(256, 1, 1)))
-__kernel  void LeanRound(const u64 v0i, const u64 v1i, const u64 v2i, const u64 v3i, __global uint8 * edges, __global uint * counters, __global u32 * aux, const u32 mode, const u32 uorv)
-{
-	const int blocks = NEDGES / 32;
-	const int gid = get_global_id(0);
-	const int lid = get_local_id(0);
-
-	{
-		__local u32 el[256][8];
-		int lCount = 0;
-		// what 256 nit block of edges are we processing
-		u64 index = gid;
-		u64 start = index * 256;
-		// load all 256 bits (edges) to registers
-		uint8 load = edges[index];
-		// map to an array for easier indexing (depends on compiler/GPU, could be pushed out to cache)
-		el[lid][0] = load.s0;
-		el[lid][1] = load.s1;
-		el[lid][2] = load.s2;
-		el[lid][3] = load.s3;
-		el[lid][4] = load.s4;
-		el[lid][5] = load.s5;
-		el[lid][6] = load.s6;
-		el[lid][7] = load.s7;
-		
-		// process as 8 x 32bit segment, GPUs have 32bit ALUs 
-		for (short i = 0; i < 8; i++)
-		{
-			// shortcut to current 32bit value
-			uint ee = el[lid][i];
-			// how many edges we process in the block
-			short lEdges = popcount(ee);
-			// whole warp will always execute worst case scenario, but it will help in the long run (not benched)
-			
-			// now a loop for every single living edge in current 32 edge block
-			for (short e = 0; e < lEdges; e++)
-			{
-				// bit position of next living edge
-				short pos = clz(ee);
-				// position in the 256 edge block
-				int subPos = (i * 32) + pos;
-				// reconstruct value of noce for this edge
-				int nonce = start + subPos;
-				// calculate siphash24 for either U or V (host device control)
-				u32 hash = dipnode(v0i, v1i, v2i, v3i, nonce, uorv);
-				
-				// this time we set edge bit counters - PASS 1
-				if (mode == MODE_SETCNT)
-				{
-					// what global memory 32bit block we need to access
-					int block = hash / 32;
-					// what bit in the block we need to set
-					u32 bit = hash % 32;
-					// create a bitmask from that bit
-					u32 mask = (u32)1 << bit;
-					// global atomic or (set bit to 1 no matter what it was)
-					atomic_or(&counters[block], mask);
-				}
-				// this time counters are already set so need to figure out if the edge lives - PASS 2
-				else if ((mode == MODE_TRIM) || (mode == MODE_EXTRACT))
-				{
-					// cuckatoo XOR thing
-					hash = hash ^ 1;
-					// what global memory 32bit block we need to read
-					int block = hash / 32;
-					// what bit in the block we need to read
-					u32 bit = hash % 32;
-					// create a bitmask from that bit
-					u32 mask = (u32)1 << bit;
-					// does the edge live or not
-					bool lives = ((counters[block]) & mask) > 0;
-					// if edge is not alive, kill it (locally in registers)
-					if (!lives)
-					{
-						el[lid][i] ^= ((u32)1<<31) >> pos; // 1 XOR 1 is 0
-					}
-					else
-					{
-						// debug counter of alive edges
-						if (DEBUG)
-							lCount++;
-
-						// if this is last lean round we do, store all edges in one long list
-						if (mode == MODE_EXTRACT) // PASS N_rounds
-						{
-							// obtain global pointer to final edge list
-							int edgePos = atomic_inc(aux+1);
-							// position in output array as multiple of 128bits (32bits will be empty)
-							int auxIndex = 4 + (edgePos * 4);
-							// debug failsafe
-							//if (!(DEBUG && (auxIndex > (1024 * 1024))))
-							{
-								// store all information to global memory
-								aux[auxIndex + 0] = dipnode(v0i, v1i, v2i, v3i, nonce, 0);
-								aux[auxIndex + 1] = dipnode(v0i, v1i, v2i, v3i, nonce, 1);
-								aux[auxIndex + 2] = nonce;
-								aux[auxIndex + 3] = 0; // for clarity, competely useless operation
-							}
-						}
-					}
-				}
-				// clear current edge position so that we can skip it in next run of ctz()
-				ee ^= ((u32)1<<31) >> pos; // 1 XOR 1 is 0
-			}
-		}
-		// return edge bits back to global memory if we are in second stage
-		if (mode == MODE_TRIM)
-			edges[index] = (uint8)(el[lid][0], el[lid][1], el[lid][2], el[lid][3], el[lid][4], el[lid][5], el[lid][6], el[lid][7]);
-		// debug only, use aux buffer to count alive edges in this round
-		if (DEBUG)
-			atomic_add(aux, lCount);
-	}
-}
-"#;
diff -urN '--exclude=.git' grin-miner-1.0.2/plugin/Cargo.toml grin-miner-copy/plugin/Cargo.toml
--- grin-miner-1.0.2/plugin/Cargo.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/plugin/Cargo.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-[package]
-name = "grin_miner_plugin"
-version = "1.0.2"
-authors = ["Grin Developers <mimblewimble@lists.launchpad.net>"]
-repository = "https://github.com/mimblewimble/grin-miner"
-description = "Device specific plugins for the grin miner"
-license = "Apache-2.0"
-workspace = ".."
-
-[dependencies]
-byteorder = "^0.5"
-blake2-rfc = "~0.2.17"
-serde = "~1.0.8"
-serde_derive = "~1.0.8"
-serde_json = "~1.0.2"
-libc = "0.2.24"
diff -urN '--exclude=.git' grin-miner-1.0.2/plugin/src/lib.rs grin-miner-copy/plugin/src/lib.rs
--- grin-miner-1.0.2/plugin/src/lib.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/plugin/src/lib.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,329 +0,0 @@
-// Copyright 2017 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Crate wrapping up the Grin miner plugins
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-extern crate serde;
-#[macro_use]
-extern crate serde_derive;
-extern crate blake2_rfc as blake2;
-extern crate byteorder;
-extern crate libc;
-extern crate serde_json;
-
-use libc::*;
-use std::ffi::CString;
-use std::ptr::NonNull;
-use std::{cmp, fmt, marker};
-
-use blake2::blake2b::Blake2b;
-use byteorder::{BigEndian, ByteOrder};
-
-/// Size of proof
-pub const PROOFSIZE: usize = 42;
-/// Maximin length of plugin name w
-pub const MAX_NAME_LEN: usize = 256;
-/// Maximum number of solutions
-pub const MAX_SOLS: usize = 4;
-
-// Type definitions corresponding to each function that the plugin/solver implements
-/// Create solver function
-pub type CuckooCreateSolverCtx = unsafe extern "C" fn(*mut SolverParams) -> *mut SolverCtx;
-/// Destroy solver function
-pub type CuckooDestroySolverCtx = unsafe extern "C" fn(*mut SolverCtx);
-/// Run solver function
-pub type CuckooRunSolver = unsafe extern "C" fn(
-	*mut SolverCtx,       // Solver context
-	*const c_uchar,       // header
-	uint32_t,             // header length
-	uint64_t,             // nonce
-	uint32_t,             // range
-	*mut SolverSolutions, // reference to any found solutions
-	*mut SolverStats,     // solver stats
-) -> uint32_t;
-/// Stop solver function
-pub type CuckooStopSolver = unsafe extern "C" fn(*mut SolverCtx);
-/// Fill default params of solver
-pub type CuckooFillDefaultParams = unsafe extern "C" fn(*mut SolverParams);
-
-/// A solver context, opaque reference to C++ type underneath
-#[derive(Copy, Clone, Debug)]
-pub enum SolverCtx {}
-/// wrap ctx to send across threads
-pub struct SolverCtxWrapper(pub NonNull<SolverCtx>);
-unsafe impl marker::Send for SolverCtxWrapper {}
-
-/// Common parameters for a solver
-#[derive(Clone, Debug, Serialize, Deserialize)]
-#[repr(C)]
-pub struct SolverParams {
-	/// threads
-	pub nthreads: uint32_t,
-	/// trims
-	pub ntrims: uint32_t,
-	/// Whether to show cycle (should be true to get solutions)
-	pub showcycle: bool,
-	/// allrounds
-	pub allrounds: bool,
-	/// whether to apply the nonce to the header, or leave as is,
-	/// letting caller mutate nonce
-	pub mutate_nonce: bool,
-	/// reduce cpuload
-	pub cpuload: bool,
-
-	/// Common Cuda params
-	pub device: u32,
-
-	/// Lean cuda params
-	pub blocks: u32,
-	///
-	pub tpb: u32,
-
-	/// Mean cuda params
-	pub expand: u32,
-	///
-	pub genablocks: u32,
-	///
-	pub genatpb: u32,
-	///
-	pub genbtpb: u32,
-	///
-	pub trimtpb: u32,
-	///
-	pub tailtpb: u32,
-	///
-	pub recoverblocks: u32,
-	///
-	pub recovertpb: u32,
-	/// OCL platform ID, 0 - default, 1 - AMD, 2 - NVIDIA
-	pub platform: u32,
-	/// edge bits for OCL plugins
-	pub edge_bits: u32,
-}
-
-impl Default for SolverParams {
-	fn default() -> SolverParams {
-		SolverParams {
-			nthreads: 0,
-			ntrims: 0,
-			showcycle: true,
-			allrounds: false,
-			mutate_nonce: false,
-			cpuload: true,
-			device: 0,
-			blocks: 0,
-			tpb: 0,
-			expand: 0,
-			genablocks: 0,
-			genatpb: 0,
-			genbtpb: 0,
-			trimtpb: 0,
-			tailtpb: 0,
-			recoverblocks: 0,
-			recovertpb: 0,
-			platform: 0,
-			edge_bits: 31,
-		}
-	}
-}
-
-/// Common stats collected by solvers
-#[derive(Clone)]
-#[repr(C)]
-pub struct SolverStats {
-	/// device Id
-	pub device_id: uint32_t,
-	/// graph size
-	pub edge_bits: uint32_t,
-	/// plugin name
-	pub plugin_name: [c_uchar; MAX_NAME_LEN],
-	/// device name
-	pub device_name: [c_uchar; MAX_NAME_LEN],
-	/// whether device has reported an error
-	pub has_errored: bool,
-	/// reason for error
-	pub error_reason: [c_uchar; MAX_NAME_LEN],
-	/// number of searched completed by device
-	pub iterations: uint32_t,
-	/// last solution start time
-	pub last_start_time: uint64_t,
-	/// last solution end time
-	pub last_end_time: uint64_t,
-	/// last solution elapsed time
-	pub last_solution_time: uint64_t,
-}
-
-impl Default for SolverStats {
-	fn default() -> SolverStats {
-		SolverStats {
-			device_id: 0,
-			edge_bits: 0,
-			plugin_name: [0; MAX_NAME_LEN],
-			device_name: [0; MAX_NAME_LEN],
-			has_errored: false,
-			error_reason: [0; MAX_NAME_LEN],
-			iterations: 0,
-			last_start_time: 0,
-			last_end_time: 0,
-			last_solution_time: 0,
-		}
-	}
-}
-
-impl SolverStats {
-	fn get_name(&self, c_str: &[u8; MAX_NAME_LEN]) -> String {
-		// remove all null zeroes
-		let v = c_str.clone().to_vec();
-		let mut i = 0;
-		for j in 0..v.len() {
-			if v.get(j) == Some(&0) {
-				i = j;
-				break;
-			}
-		}
-		let v = v.split_at(i).0;
-		match CString::new(v) {
-			Ok(s) => s.to_str().unwrap().to_owned(),
-			Err(_) => String::from("Unknown Device Name"),
-		}
-	}
-	/// return device name as rust string
-	pub fn get_device_name(&self) -> String {
-		self.get_name(&self.device_name)
-	}
-	/// return plugin name as rust string
-	pub fn get_plugin_name(&self) -> String {
-		self.get_name(&self.plugin_name)
-	}
-	/// return plugin name as rust string
-	pub fn get_error_reason(&self) -> String {
-		self.get_name(&self.error_reason)
-	}
-	/// set plugin name
-	pub fn set_plugin_name(&mut self, name: &str) {
-		let c_vec = CString::new(name).unwrap().into_bytes();
-		for i in 0..c_vec.len() {
-			self.plugin_name[i] = c_vec[i];
-		}
-	}
-}
-
-/// A single solution
-#[repr(C)]
-#[derive(Clone, Copy)]
-pub struct Solution {
-	/// Optional ID
-	pub id: uint64_t,
-	/// Nonce
-	pub nonce: uint64_t,
-	/// Proof
-	pub proof: [uint64_t; PROOFSIZE],
-}
-
-impl Default for Solution {
-	fn default() -> Solution {
-		Solution {
-			id: 0,
-			nonce: 0,
-			proof: [0u64; PROOFSIZE],
-		}
-	}
-}
-
-impl fmt::Display for Solution {
-	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-		let mut comma_separated = String::new();
-
-		for num in &self.proof[0..self.proof.len()] {
-			comma_separated.push_str(&format!("0x{:X}", &num));
-			comma_separated.push_str(", ");
-		}
-		comma_separated.pop();
-		comma_separated.pop();
-
-		write!(f, "Nonce:{} [{}]", self.nonce, comma_separated)
-	}
-}
-
-impl fmt::Debug for Solution {
-	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-		write!(f, "{:?}", &self.proof[..])
-	}
-}
-
-impl cmp::PartialEq for Solution {
-	fn eq(&self, other: &Solution) -> bool {
-		for i in 0..PROOFSIZE {
-			if self.proof[i] != other.proof[i] {
-				return false;
-			}
-		}
-		return true;
-	}
-}
-
-impl Solution {
-	/// Converts the proof to a vector of u64s
-	pub fn to_u64s(&self) -> Vec<u64> {
-		let mut nonces = Vec::with_capacity(PROOFSIZE);
-		for n in self.proof.iter() {
-			nonces.push(*n as u64);
-		}
-		nonces
-	}
-
-	/// Returns the hash of the solution, as performed in
-	/// grin
-	/// TODO: Check whether grin sticks to u32s like this
-	pub fn hash(&self) -> [u8; 32] {
-		// Hash
-		let mut blake2b = Blake2b::new(32);
-		for n in 0..self.proof.len() {
-			let mut bytes = [0; 4];
-			BigEndian::write_u32(&mut bytes, self.proof[n] as u32);
-			blake2b.update(&bytes);
-		}
-		let mut ret = [0; 32];
-		ret.copy_from_slice(blake2b.finalize().as_bytes());
-		ret
-	}
-}
-
-/// All solutions returned
-#[derive(Clone, Copy)]
-#[repr(C)]
-pub struct SolverSolutions {
-	/// graph size
-	pub edge_bits: u32,
-	/// number of solutions
-	pub num_sols: u32,
-	/// solutions themselves
-	pub sols: [Solution; MAX_SOLS],
-}
-
-impl Default for SolverSolutions {
-	fn default() -> SolverSolutions {
-		SolverSolutions {
-			edge_bits: 0,
-			num_sols: 0,
-			sols: [Solution::default(); MAX_SOLS],
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/README.md grin-miner-copy/README.md
--- grin-miner-1.0.2/README.md	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/README.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,88 +0,0 @@
-# Grin Miner
-
-A standalone mining implementation intended for mining Grin against a running Grin node.
-
-## Supported Platforms
-
-At present, only mining plugins for linux-x86_64 and MacOS exist. This will likely change over time as the community creates more solvers for different platforms.
-
-## Requirements
-
-- rust 1.30+ (use [rustup]((https://www.rustup.rs/))- i.e. `curl https://sh.rustup.rs -sSf | sh; source $HOME/.cargo/env`)
-- cmake 3.2+ (for [Cuckoo mining plugins]((https://github.com/mimblewimble/cuckoo-miner)))
-- ncurses and libs (ncurses, ncursesw5)
-- zlib libs (zlib1g-dev or zlib-devel)
-- linux-headers (reported needed on Alpine linux)
-
-And a [running Grin node](https://github.com/mimblewimble/grin/blob/master/doc/build.md) to mine into!
-
-## Build steps
-
-```sh
-git clone https://github.com/mimblewimble/grin-miner.git
-cd grin-miner
-git submodule update --init
-cargo build
-```
-
-### Building the Cuckoo-Miner plugins
-
-Grin-miner automatically builds x86_64 CPU plugins. Cuda plugins are also provided, but are
-not enabled by default. To enable them, modify `Cargo.toml` as follows:
-
-```
-change:
-cuckoo_miner = { path = "./cuckoo-miner" }
-to:
-cuckoo_miner = { path = "./cuckoo-miner", features = ["build-cuda-plugins"]}
-```
-
-The Cuda toolkit 9+ must be installed on your system (check with `nvcc --version`)
-
-### Building the OpenCL plugins
-OpenCL plugins are not enabled by default. Run `install_ocl_plugins.sh` script to build and install them.
-
-```
-./install_ocl_plugins.sh
-```
-You must install OpenCL libraries for your operating system before.
-If you just need to compile them (for development or testing purposes) build grin-miner the following way:
-
-```
-cargo build --features opencl
-```
-
-### Build errors
-
-See [Troubleshooting](https://github.com/mimblewimble/docs/wiki/Troubleshooting)
-
-## What was built?
-
-A successful build gets you:
-
- - `target/debug/grin-miner` - the main grin-miner binary
- - `target/debug/plugins/*` - mining plugins
-
-Make sure you always run grin-miner within a directory that contains a
-`grin-miner.toml` configuration file.
-
-While testing, put the grin-miner binary on your path like this:
-
-```
-export PATH=/path/to/grin-miner/dir/target/debug:$PATH
-```
-
-You can then run `grin-miner` directly.
-
-# Configuration
-
-Grin-miner can be further configured via the `grin-miner.toml` file.
-This file contains contains inline documentation on all configuration
-options, and should be the first point of reference.
-
-You should always ensure that this file exists in the directory from which you're
-running grin-miner.
-
-# Using grin-miner
-
-There is a [Grin forum post](https://www.grin-forum.org/t/how-to-mine-cuckoo-30-in-grin-help-us-test-and-collect-stats/152) with further detail on how to configure grin-miner and mine grin's testnet.
diff -urN '--exclude=.git' grin-miner-1.0.2/rustfmt.toml grin-miner-copy/rustfmt.toml
--- grin-miner-1.0.2/rustfmt.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/rustfmt.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-hard_tabs = true
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/client.rs grin-miner-copy/src/bin/client.rs
--- grin-miner-1.0.2/src/bin/client.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/client.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,604 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Client network controller, controls requests and responses from the
-//! stratum server
-
-use std;
-use std::io::{self, BufRead, ErrorKind, Read, Write};
-use std::net::TcpStream;
-use std::sync::{mpsc, Arc, RwLock};
-use std::thread;
-
-use bufstream::BufStream;
-use native_tls::{TlsConnector, TlsStream};
-use serde_json;
-use time;
-
-use stats;
-use types;
-use util::LOGGER;
-
-#[derive(Debug)]
-pub enum Error {
-	ConnectionError(String),
-}
-
-struct Stream {
-	stream: Option<BufStream<TcpStream>>,
-	tls_stream: Option<BufStream<TlsStream<TcpStream>>>,
-}
-
-impl Stream {
-	fn new() -> Stream {
-		Stream {
-			stream: None,
-			tls_stream: None,
-		}
-	}
-	fn try_connect(&mut self, server_url: &str, tls: Option<bool>) -> Result<(), Error> {
-		match TcpStream::connect(server_url) {
-			Ok(conn) => {
-				if tls.is_some() && tls.unwrap() {
-					let connector = TlsConnector::new().unwrap();
-					let url_port: Vec<&str> = server_url.split(":").collect();
-					let splitted_url: Vec<&str> = url_port[0].split(".").collect();
-					let base_host = format!(
-						"{}.{}",
-						splitted_url[splitted_url.len() - 2],
-						splitted_url[splitted_url.len() - 1]
-					);
-					let mut stream = connector.connect(&base_host, conn).unwrap();
-					let _ = stream.get_mut().set_nonblocking(true);
-					self.tls_stream = Some(BufStream::new(stream));
-					Ok(())
-				} else {
-					let _ = conn.set_nonblocking(true);
-					self.stream = Some(BufStream::new(conn));
-					Ok(())
-				}
-			}
-			Err(e) => Err(Error::ConnectionError(format!("{}", e))),
-		}
-	}
-}
-
-impl Write for Stream {
-	fn write(&mut self, b: &[u8]) -> Result<usize, std::io::Error> {
-		if self.tls_stream.is_some() {
-			self.tls_stream.as_mut().unwrap().write(b)
-		} else {
-			self.stream.as_mut().unwrap().write(b)
-		}
-	}
-	fn flush(&mut self) -> Result<(), std::io::Error> {
-		if self.tls_stream.is_some() {
-			self.tls_stream.as_mut().unwrap().flush()
-		} else {
-			self.stream.as_mut().unwrap().flush()
-		}
-	}
-}
-impl Read for Stream {
-	fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-		if self.tls_stream.is_some() {
-			self.tls_stream.as_mut().unwrap().read(buf)
-		} else {
-			self.stream.as_mut().unwrap().read(buf)
-		}
-	}
-}
-
-impl BufRead for Stream {
-	fn fill_buf(&mut self) -> io::Result<&[u8]> {
-		if self.tls_stream.is_some() {
-			self.tls_stream.as_mut().unwrap().fill_buf()
-		} else {
-			self.stream.as_mut().unwrap().fill_buf()
-		}
-	}
-	fn consume(&mut self, amt: usize) {
-		if self.tls_stream.is_some() {
-			self.tls_stream.as_mut().unwrap().consume(amt)
-		} else {
-			self.stream.as_mut().unwrap().consume(amt)
-		}
-	}
-	fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {
-		if self.tls_stream.is_some() {
-			self.tls_stream.as_mut().unwrap().read_until(byte, buf)
-		} else {
-			self.stream.as_mut().unwrap().read_until(byte, buf)
-		}
-	}
-	fn read_line(&mut self, string: &mut String) -> io::Result<usize> {
-		if self.tls_stream.is_some() {
-			self.tls_stream.as_mut().unwrap().read_line(string)
-		} else {
-			self.stream.as_mut().unwrap().read_line(string)
-		}
-	}
-}
-
-pub struct Controller {
-	_id: u32,
-	server_url: String,
-	server_login: Option<String>,
-	server_password: Option<String>,
-	server_tls_enabled: Option<bool>,
-	stream: Option<Stream>,
-	rx: mpsc::Receiver<types::ClientMessage>,
-	pub tx: mpsc::Sender<types::ClientMessage>,
-	miner_tx: mpsc::Sender<types::MinerMessage>,
-	last_request_id: u32,
-	stats: Arc<RwLock<stats::Stats>>,
-}
-
-fn invlalid_error_response() -> types::RpcError {
-	types::RpcError {
-		code: 0,
-		message: "Invalid error response received".to_owned(),
-	}
-}
-
-impl Controller {
-	pub fn new(
-		server_url: &str,
-		server_login: Option<String>,
-		server_password: Option<String>,
-		server_tls_enabled: Option<bool>,
-		miner_tx: mpsc::Sender<types::MinerMessage>,
-		stats: Arc<RwLock<stats::Stats>>,
-	) -> Result<Controller, Error> {
-		let (tx, rx) = mpsc::channel::<types::ClientMessage>();
-		Ok(Controller {
-			_id: 0,
-			server_url: server_url.to_string(),
-			server_login: server_login,
-			server_password: server_password,
-			server_tls_enabled: server_tls_enabled,
-			stream: None,
-			tx: tx,
-			rx: rx,
-			miner_tx: miner_tx,
-			last_request_id: 0,
-			stats: stats,
-		})
-	}
-
-	pub fn try_connect(&mut self) -> Result<(), Error> {
-		self.stream = Some(Stream::new());
-		self.stream
-			.as_mut()
-			.unwrap()
-			.try_connect(&self.server_url, self.server_tls_enabled)?;
-		Ok(())
-	}
-
-	fn read_message(&mut self) -> Result<Option<String>, Error> {
-		if let None = self.stream {
-			return Err(Error::ConnectionError("broken pipe".to_string()));
-		}
-		let mut line = String::new();
-		match self.stream.as_mut().unwrap().read_line(&mut line) {
-			Ok(_) => {
-				// stream is not returning a proper error on disconnect
-				if line == "" {
-					return Err(Error::ConnectionError("broken pipe".to_string()));
-				}
-				return Ok(Some(line));
-			}
-			Err(ref e) if e.kind() == ErrorKind::BrokenPipe => {
-				return Err(Error::ConnectionError("broken pipe".to_string()));
-			}
-			Err(ref e) if e.kind() == ErrorKind::WouldBlock => {
-				return Ok(None);
-			}
-			Err(e) => {
-				error!(LOGGER, "Communication error with stratum server: {}", e);
-				return Err(Error::ConnectionError("broken pipe".to_string()));
-			}
-		}
-	}
-
-	fn send_message(&mut self, message: &str) -> Result<(), Error> {
-		if let None = self.stream {
-			return Err(Error::ConnectionError(String::from("No server connection")));
-		}
-		debug!(LOGGER, "sending request: {}", message);
-		let _ = self.stream.as_mut().unwrap().write(message.as_bytes());
-		let _ = self.stream.as_mut().unwrap().write("\n".as_bytes());
-		let _ = self.stream.as_mut().unwrap().flush();
-		Ok(())
-	}
-
-	fn send_message_get_job_template(&mut self) -> Result<(), Error> {
-		let req = types::RpcRequest {
-			id: self.last_request_id.to_string(),
-			jsonrpc: "2.0".to_string(),
-			method: "getjobtemplate".to_string(),
-			params: None,
-		};
-		let req_str = serde_json::to_string(&req).unwrap();
-		{
-			let mut stats = self.stats.write().unwrap();
-			stats.client_stats.last_message_sent = format!("Last Message Sent: Get New Job");
-		}
-		self.send_message(&req_str)
-	}
-
-	fn send_login(&mut self) -> Result<(), Error> {
-		// only send the login request if a login string is configured
-		let login_str = match self.server_login.clone() {
-			None => "".to_string(),
-			Some(server_login) => server_login.clone(),
-		};
-		if login_str == "" {
-			return Ok(());
-		}
-		let password_str = match self.server_password.clone() {
-			None => "".to_string(),
-			Some(server_password) => server_password.clone(),
-		};
-		let params = types::LoginParams {
-			login: login_str,
-			pass: password_str,
-			agent: "grin-miner".to_string(),
-		};
-		let req = types::RpcRequest {
-			id: self.last_request_id.to_string(),
-			jsonrpc: "2.0".to_string(),
-			method: "login".to_string(),
-			params: Some(serde_json::to_value(params).unwrap()),
-		};
-		let req_str = serde_json::to_string(&req).unwrap();
-		{
-			let mut stats = self.stats.write().unwrap();
-			stats.client_stats.last_message_sent = format!("Last Message Sent: Login");
-		}
-		self.send_message(&req_str)
-	}
-
-	fn send_message_get_status(&mut self) -> Result<(), Error> {
-		let req = types::RpcRequest {
-			id: self.last_request_id.to_string(),
-			jsonrpc: "2.0".to_string(),
-			method: "status".to_string(),
-			params: None,
-		};
-		let req_str = serde_json::to_string(&req).unwrap();
-		self.send_message(&req_str)
-	}
-
-	fn send_message_submit(
-		&mut self,
-		height: u64,
-		job_id: u64,
-		edge_bits: u32,
-		nonce: u64,
-		pow: Vec<u64>,
-	) -> Result<(), Error> {
-		let params_in = types::SubmitParams {
-			height: height,
-			job_id: job_id,
-			edge_bits: edge_bits,
-			nonce: nonce,
-			pow: pow,
-		};
-		let params = serde_json::to_string(&params_in).unwrap();
-		let req = types::RpcRequest {
-			id: self.last_request_id.to_string(),
-			jsonrpc: "2.0".to_string(),
-			method: "submit".to_string(),
-			params: Some(serde_json::from_str(&params).unwrap()),
-		};
-		let req_str = serde_json::to_string(&req).unwrap();
-		{
-			let mut stats = self.stats.write().unwrap();
-			stats.client_stats.last_message_sent = format!(
-				"Last Message Sent: Found share for height: {} - nonce: {}",
-				params_in.height, params_in.nonce
-			);
-		}
-		self.send_message(&req_str)
-	}
-
-	fn send_miner_job(&mut self, job: types::JobTemplate) -> Result<(), Error> {
-		let miner_message =
-			types::MinerMessage::ReceivedJob(job.height, job.job_id, job.difficulty, job.pre_pow);
-		let mut stats = self.stats.write().unwrap();
-		stats.client_stats.last_message_received = format!(
-			"Last Message Received: Start Job for Height: {}, Difficulty: {}",
-			job.height, job.difficulty
-		);
-		let _ = self.miner_tx.send(miner_message);
-		Ok(())
-	}
-
-	fn send_miner_stop(&mut self) -> Result<(), Error> {
-		let miner_message = types::MinerMessage::StopJob;
-		let _ = self.miner_tx.send(miner_message);
-		Ok(())
-	}
-
-	pub fn handle_request(&mut self, req: types::RpcRequest) -> Result<(), Error> {
-		debug!(LOGGER, "Received request type: {}", req.method);
-		let _ = match req.method.as_str() {
-			"job" => {
-				let job: types::JobTemplate = serde_json::from_value(req.params.unwrap()).unwrap();
-				info!(LOGGER, "Got a new job: {:?}", job);
-				self.send_miner_job(job)
-			}
-			_ => Ok(()),
-		};
-		Ok(())
-	}
-
-	pub fn handle_response(&mut self, res: types::RpcResponse) -> Result<(), Error> {
-		debug!(LOGGER, "Received response with id: {}", res.id);
-		match res.method.as_str() {
-			// "status" response can be used to further populate stats object
-			"status" => {
-				if res.result.is_some() {
-					let st: types::WorkerStatus =
-						serde_json::from_value(res.result.unwrap()).unwrap();
-					info!(
-						LOGGER,
-						"Status for worker {} - Height: {}, Difficulty: {}, ({}/{}/{})",
-						st.id,
-						st.height,
-						st.difficulty,
-						st.accepted,
-						st.rejected,
-						st.stale
-					);
-					// Add these status to the stats
-					let mut stats = self.stats.write().unwrap();
-					stats.client_stats.last_message_received = format!(
-						"Last Message Received: Accepted: {}, Rejected: {}, Stale: {}",
-						st.accepted, st.rejected, st.stale
-					);
-				} else {
-					let err = res.error.unwrap_or_else(|| invlalid_error_response());
-					let mut stats = self.stats.write().unwrap();
-					stats.client_stats.last_message_received =
-						format!("Last Message Received: Failed to get status: {:?}", err);
-					error!(LOGGER, "Failed to get status: {:?}", err);
-				}
-				()
-			}
-			// "getjobtemplate" response gets sent to miners to work on
-			"getjobtemplate" => {
-				if res.result.is_some() {
-					let job: types::JobTemplate =
-						serde_json::from_value(res.result.unwrap()).unwrap();
-					{
-						let mut stats = self.stats.write().unwrap();
-						stats.client_stats.last_message_received = format!(
-							"Last Message Received: Got job for block {} at difficulty {}",
-							job.height, job.difficulty
-						);
-					}
-					info!(
-						LOGGER,
-						"Got a job at height {} and difficulty {}", job.height, job.difficulty
-					);
-					let _ = self.send_miner_job(job);
-				} else {
-					let err = res.error.unwrap_or_else(|| invlalid_error_response());
-					let mut stats = self.stats.write().unwrap();
-					stats.client_stats.last_message_received = format!(
-						"Last Message Received: Failed to get job template: {:?}",
-						err
-					);
-					error!(LOGGER, "Failed to get a job template: {:?}", err);
-				}
-				()
-			}
-			// "submit" response
-			"submit" => {
-				if res.result.is_some() {
-					info!(LOGGER, "Share Accepted!!");
-					let mut stats = self.stats.write().unwrap();
-					stats.client_stats.last_message_received =
-						format!("Last Message Received: Share Accepted!!");
-					stats.mining_stats.solution_stats.num_shares_accepted += 1;
-					let result = serde_json::to_string(&res.result).unwrap();
-					if result.contains("blockfound") {
-						info!(LOGGER, "Block Found!!");
-						stats.client_stats.last_message_received =
-							format!("Last Message Received: Block Found!!");
-						stats.mining_stats.solution_stats.num_blocks_found += 1;
-					}
-				} else {
-					let err = res.error.unwrap_or_else(|| invlalid_error_response());
-					let mut stats = self.stats.write().unwrap();
-					stats.client_stats.last_message_received = format!(
-						"Last Message Received: Failed to submit a solution: {:?}",
-						err.message
-					);
-					if err.message.contains("too late") {
-						stats.mining_stats.solution_stats.num_staled += 1;
-					} else {
-						stats.mining_stats.solution_stats.num_rejected += 1;
-					}
-					error!(LOGGER, "Failed to submit a solution: {:?}", err);
-				}
-				()
-			}
-			// "keepalive" response
-			"keepalive" => {
-				if res.result.is_some() {
-					// Nothing to do for keepalive "ok"
-					// dont update last_message_received with good keepalive response
-				} else {
-					let err = res.error.unwrap_or_else(|| invlalid_error_response());
-					let mut stats = self.stats.write().unwrap();
-					stats.client_stats.last_message_received = format!(
-						"Last Message Received: Failed to request keepalive: {:?}",
-						err
-					);
-					error!(LOGGER, "Failed to request keepalive: {:?}", err);
-				}
-			}
-			// "login" response
-			"login" => {
-				if res.result.is_some() {
-					// Nothing to do for login "ok"
-					// dont update last_message_received with good login response
-				} else {
-					// This is a fatal error
-					let err = res.error.unwrap_or_else(|| invlalid_error_response());
-					let mut stats = self.stats.write().unwrap();
-					stats.client_stats.last_message_received =
-						format!("Last Message Received: Failed to log in: {:?}", err);
-					stats.client_stats.connection_status =
-						"Connection Status: Server requires login".to_string();
-					stats.client_stats.connected = false;
-					error!(LOGGER, "Failed to log in: {:?}", err);
-				}
-			}
-			// unknown method response
-			_ => {
-				let mut stats = self.stats.write().unwrap();
-				stats.client_stats.last_message_received =
-					format!("Last Message Received: Unknown Response: {:?}", res);
-				warn!(LOGGER, "Unknown Response: {:?}", res);
-				()
-			}
-		}
-
-		return Ok(());
-	}
-
-	pub fn run(mut self) {
-		let server_read_interval = 1;
-		let server_retry_interval = 5;
-		let mut next_server_read = time::get_time().sec + server_read_interval;
-		let status_interval = 30;
-		let mut next_status_request = time::get_time().sec + status_interval;
-		let mut next_server_retry = time::get_time().sec;
-		// Request the first job template
-		thread::sleep(std::time::Duration::from_secs(1));
-		let mut was_disconnected = true;
-		loop {
-			// Check our connection status, and try to correct if possible
-			if let None = self.stream {
-				if !was_disconnected {
-					let _ = self.send_miner_stop();
-				}
-				was_disconnected = true;
-				if time::get_time().sec > next_server_retry {
-					if let Err(_) = self.try_connect() {
-						let status = format!("Connection Status: Can't establish server connection to {}. Will retry every {} seconds",
-							self.server_url,
-							server_retry_interval);
-						warn!(LOGGER, "{}", status);
-						let mut stats = self.stats.write().unwrap();
-						stats.client_stats.connection_status = status;
-						stats.client_stats.connected = false;
-						self.stream = None;
-					} else {
-						let status = format!(
-							"Connection Status: Connected to Grin server at {}.",
-							self.server_url
-						);
-						warn!(LOGGER, "{}", status);
-						let mut stats = self.stats.write().unwrap();
-						stats.client_stats.connection_status = status;
-					}
-					next_server_retry = time::get_time().sec + server_retry_interval;
-					if let None = self.stream {
-						thread::sleep(std::time::Duration::from_secs(1));
-						continue;
-					}
-				}
-			} else {
-				// get new job template
-				if was_disconnected {
-					let _ = self.send_login();
-					let _ = self.send_message_get_job_template();
-					was_disconnected = false;
-				}
-				// read messages from server
-				if time::get_time().sec > next_server_read {
-					match self.read_message() {
-						Ok(message) => {
-							match message {
-								Some(m) => {
-									{
-										let mut stats = self.stats.write().unwrap();
-										stats.client_stats.connected = true;
-									}
-									// figure out what kind of message,
-									// and dispatch appropriately
-									debug!(LOGGER, "Received message: {}", m);
-									// Deserialize to see what type of object it is
-									let v: serde_json::Value = serde_json::from_str(&m).unwrap();
-									// Is this a response or request?
-									if v["id"] == String::from("Stratum") {
-										// this is a request
-										let request: types::RpcRequest =
-											serde_json::from_str(&m).unwrap();
-										let _ = self.handle_request(request);
-										continue;
-									} else {
-										// this is a response
-										let response: types::RpcResponse =
-											serde_json::from_str(&m).unwrap();
-										let _ = self.handle_response(response);
-										continue;
-									}
-								}
-								None => {} // No messages from the server at this time
-							}
-						}
-						Err(e) => {
-							error!(LOGGER, "Error reading message: {:?}", e);
-							self.stream = None;
-							continue;
-						}
-					}
-					next_server_read = time::get_time().sec + server_read_interval;
-				}
-
-				// Request a status message from the server
-				if time::get_time().sec > next_status_request {
-					let _ = self.send_message_get_status();
-					next_status_request = time::get_time().sec + status_interval;
-				}
-			}
-
-			// Talk to the cuckoo miner plugin
-			while let Some(message) = self.rx.try_iter().next() {
-				debug!(LOGGER, "Client received message: {:?}", message);
-				let result = match message {
-					types::ClientMessage::FoundSolution(height, job_id, edge_bits, nonce, pow) => {
-						self.send_message_submit(height, job_id, edge_bits, nonce, pow)
-					}
-					types::ClientMessage::Shutdown => {
-						//TODO: Inform server?
-						debug!(LOGGER, "Shutting down client controller");
-						return;
-					}
-				};
-				if let Err(e) = result {
-					error!(LOGGER, "Mining Controller Error {:?}", e);
-					self.stream = None;
-				}
-			}
-			thread::sleep(std::time::Duration::from_millis(10));
-		} // loop
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/grin_miner.rs grin-miner-copy/src/bin/grin_miner.rs
--- grin-miner-1.0.2/src/bin/grin_miner.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/grin_miner.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,239 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Stratum client implementation, for standalone mining against a running
-//! grin node
-extern crate cuckoo_miner as cuckoo;
-extern crate grin_miner_config as config;
-extern crate grin_miner_plugin as plugin;
-extern crate grin_miner_util as util;
-
-extern crate bufstream;
-extern crate native_tls;
-extern crate time;
-#[macro_use]
-extern crate serde_derive;
-extern crate serde_json;
-#[macro_use]
-extern crate slog;
-
-#[cfg(feature="tui")]
-extern crate cursive;
-
-pub mod client;
-pub mod mining;
-pub mod stats;
-pub mod types;
-
-#[cfg(feature="tui")]
-pub mod tui;
-
-use config::GlobalConfig;
-use std::sync::atomic::{AtomicBool, Ordering};
-use std::sync::{Arc, RwLock};
-use std::thread;
-
-use util::{init_logger, LOGGER};
-
-// include build information
-pub mod built_info {
-	include!(concat!(env!("OUT_DIR"), "/built.rs"));
-}
-
-pub fn info_strings() -> (String, String, String) {
-	(
-		format!(
-			"This is Grin-Miner version {}{}, built for {} by {}.",
-			built_info::PKG_VERSION,
-			built_info::GIT_VERSION.map_or_else(|| "".to_owned(), |v| format!(" (git {})", v)),
-			built_info::TARGET,
-			built_info::RUSTC_VERSION
-		)
-		.to_string(),
-		format!(
-			"Built with profile \"{}\", features \"{}\" on {}.",
-			built_info::PROFILE,
-			built_info::FEATURES_STR,
-			built_info::BUILT_TIME_UTC
-		)
-		.to_string(),
-		format!("Dependencies:\n {}", built_info::DEPENDENCIES_STR).to_string(),
-	)
-}
-
-fn log_build_info() {
-	let (basic_info, detailed_info, deps) = info_strings();
-	info!(LOGGER, "{}", basic_info);
-	debug!(LOGGER, "{}", detailed_info);
-	trace!(LOGGER, "{}", deps);
-}
-
-#[cfg(feature="tui")]
-mod with_tui {
-	use std::sync::{mpsc, Arc, RwLock};
-	use std::sync::atomic::{AtomicBool, Ordering};
-	use std::thread;
-	use types;
-	use stats;
-	use tui::ui;
-
-    pub fn start_tui(
-	    s: Arc<RwLock<stats::Stats>>,
-	    client_tx: mpsc::Sender<types::ClientMessage>,
-	    miner_tx: mpsc::Sender<types::MinerMessage>,
-	    stop: Arc<AtomicBool>,
-    ) {
-	    // Run the UI controller.. here for now for simplicity to access
-	    // everything it might need
-	    println!("Starting Grin Miner in UI mode...");
-	    println!("Waiting for solvers to shutdown...");
-	    let _ = thread::Builder::new()
-		    .name("ui".to_string())
-		    .spawn(move || {
-			    let mut controller = ui::Controller::new().unwrap_or_else(|e| {
-				    panic!("Error loading UI controller: {}", e);
-			    });
-			    controller.run(s.clone());
-			    // Shut down everything else on tui exit
-			    let _ = client_tx.send(types::ClientMessage::Shutdown);
-			    let _ = miner_tx.send(types::MinerMessage::Shutdown);
-			    stop.store(true, Ordering::Relaxed);
-		    });
-    }
-}
-
-fn main() {
-	// Init configuration
-	let mut global_config = GlobalConfig::new(None).unwrap_or_else(|e| {
-		panic!("Error parsing config file: {}", e);
-	});
-	println!(
-		"Starting Grin-Miner from config file at: {}",
-		global_config.config_file_path.unwrap().to_str().unwrap()
-	);
-	// Init logging
-	let mut log_conf = global_config
-		.members
-		.as_mut()
-		.unwrap()
-		.logging
-		.clone()
-		.unwrap();
-
-	let mining_config = global_config.members.as_mut().unwrap().mining.clone();
-
-	if cfg!(feature = "tui") && mining_config.run_tui {
-		log_conf.log_to_stdout = false;
-		log_conf.tui_running = Some(true);
-	}
-
-	init_logger(Some(log_conf));
-
-	log_build_info();
-	let stats = Arc::new(RwLock::new(stats::Stats::default()));
-
-	let mut mc =
-		mining::Controller::new(mining_config.clone(), stats.clone()).unwrap_or_else(|e| {
-			panic!("Error loading mining controller: {}", e);
-		});
-	let cc = client::Controller::new(
-		&mining_config.stratum_server_addr,
-		mining_config.stratum_server_login.clone(),
-		mining_config.stratum_server_password.clone(),
-		mining_config.stratum_server_tls_enabled.clone(),
-		mc.tx.clone(),
-		stats.clone(),
-	)
-	.unwrap_or_else(|e| {
-		panic!("Error loading stratum client controller: {:?}", e);
-	});
-	let tui_stopped = Arc::new(AtomicBool::new(false));
-	let miner_stopped = Arc::new(AtomicBool::new(false));
-	let client_stopped = Arc::new(AtomicBool::new(false));
-
-	// Load plugin configuration and start solvers first,
-	// so we can exit pre-tui if something is obviously wrong
-	debug!(LOGGER, "Starting solvers");
-	let result = config::read_configs(
-		mining_config.miner_plugin_dir.clone(),
-		mining_config.miner_plugin_config.clone()
-        );
-	let mut miner = match result {
-		Ok(cfgs) => cuckoo::CuckooMiner::new(cfgs),
-		Err(e) => {
-			println!("Error loading plugins. Please check logs for further info.");
-			println!("Error details:");
-			println!("{:?}", e);
-			println!("Exiting");
-			return;
-		}
-	};
-	if let Err(e) = miner.start_solvers() {
-		println!("Error starting plugins. Please check logs for further info.");
-		println!("Error details:");
-		println!("{:?}", e);
-		println!("Exiting");
-		return;
-	}
-
-	if mining_config.run_tui {
-        #[cfg(feature="tui")]
-		with_tui::start_tui(
-			stats.clone(),
-			cc.tx.clone(),
-			mc.tx.clone(),
-			tui_stopped.clone(),
-		);
-
-        #[cfg(not(feature="tui"))]
-		warn!(LOGGER, "Grin-miner was built with TUI support disabled!");
-	} else {
-		tui_stopped.store(true, Ordering::Relaxed);
-	}
-
-	mc.set_client_tx(cc.tx.clone());
-
-	let miner_stopped_internal = miner_stopped.clone();
-	let _ = thread::Builder::new()
-		.name("mining_controller".to_string())
-		.spawn(move || {
-			if let Err(e) = mc.run(miner) {
-				error!(
-					LOGGER,
-					"Error loading plugins. Please check logs for further info: {:?}", e
-				);
-				return;
-			}
-			miner_stopped_internal.store(true, Ordering::Relaxed);
-		});
-
-	let client_stopped_internal = client_stopped.clone();
-	let _ = thread::Builder::new()
-		.name("client_controller".to_string())
-		.spawn(move || {
-			cc.run();
-			client_stopped_internal.store(true, Ordering::Relaxed);
-		});
-
-	loop {
-		if miner_stopped.load(Ordering::Relaxed)
-			&& client_stopped.load(Ordering::Relaxed)
-			&& tui_stopped.load(Ordering::Relaxed)
-		{
-			thread::sleep(std::time::Duration::from_millis(100));
-			break;
-		}
-		thread::sleep(std::time::Duration::from_millis(100));
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/mining.rs grin-miner-copy/src/bin/mining.rs
--- grin-miner-1.0.2/src/bin/mining.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/mining.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,178 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-/// Plugin controller, listens for messages sent from the stratum
-/// server, controls plugins and responds appropriately
-use std::sync::{mpsc, Arc, RwLock};
-use std::{self, thread};
-use time;
-use util::LOGGER;
-use {config, stats, types};
-
-use cuckoo::{CuckooMiner, CuckooMinerError};
-
-use plugin::SolverStats;
-
-pub struct Controller {
-	_config: config::MinerConfig,
-	rx: mpsc::Receiver<types::MinerMessage>,
-	pub tx: mpsc::Sender<types::MinerMessage>,
-	client_tx: Option<mpsc::Sender<types::ClientMessage>>,
-	current_height: u64,
-	current_job_id: u64,
-	current_target_diff: u64,
-	stats: Arc<RwLock<stats::Stats>>,
-}
-
-impl Controller {
-	pub fn new(
-		config: config::MinerConfig,
-		stats: Arc<RwLock<stats::Stats>>,
-	) -> Result<Controller, String> {
-		{
-			let mut stats_w = stats.write().unwrap();
-			stats_w.client_stats.server_url = config.stratum_server_addr.clone();
-		}
-		let (tx, rx) = mpsc::channel::<types::MinerMessage>();
-		Ok(Controller {
-			_config: config,
-			rx: rx,
-			tx: tx,
-			client_tx: None,
-			current_height: 0,
-			current_job_id: 0,
-			current_target_diff: 0,
-			stats: stats,
-		})
-	}
-
-	pub fn set_client_tx(&mut self, client_tx: mpsc::Sender<types::ClientMessage>) {
-		self.client_tx = Some(client_tx);
-	}
-
-	/// Run the mining controller, solvers in miner should already be going
-	pub fn run(&mut self, mut miner: CuckooMiner) -> Result<(), CuckooMinerError> {
-		// how often to output stats
-		let stat_output_interval = 2;
-		let mut next_stat_output = time::get_time().sec + stat_output_interval;
-
-		loop {
-			while let Some(message) = self.rx.try_iter().next() {
-				debug!(LOGGER, "Miner received message: {:?}", message);
-				let result = match message {
-					types::MinerMessage::ReceivedJob(height, job_id, diff, pre_pow) => {
-						self.current_height = height;
-						self.current_job_id = job_id;
-						self.current_target_diff = diff;
-						miner.notify(self.current_job_id as u32, self.current_height, &pre_pow, "", diff)
-					}
-					types::MinerMessage::StopJob => {
-						debug!(LOGGER, "Stopping jobs");
-						miner.pause_solvers();
-						Ok(())
-					}
-					types::MinerMessage::Shutdown => {
-						debug!(LOGGER, "Stopping jobs and Shutting down mining controller");
-						miner.stop_solvers();
-						miner.wait_for_solver_shutdown();
-						return Ok(());
-					}
-				};
-				if let Err(e) = result {
-					error!(LOGGER, "Mining Controller Error {:?}", e);
-				}
-			}
-
-			if time::get_time().sec > next_stat_output {
-				self.output_job_stats(miner.get_stats().unwrap());
-				next_stat_output = time::get_time().sec + stat_output_interval;
-			}
-
-			let solutions = miner.get_solutions();
-			if let Some(ss) = solutions {
-				let edge_bits = ss.edge_bits;
-				for i in 0..ss.num_sols {
-					let _ =
-						self.client_tx
-							.as_mut()
-							.unwrap()
-							.send(types::ClientMessage::FoundSolution(
-								self.current_height,
-								ss.sols[i as usize].id,
-								edge_bits,
-								ss.sols[i as usize].nonce,
-								ss.sols[i as usize].proof.to_vec(),
-							));
-				}
-				let mut s_stats = self.stats.write().unwrap();
-				s_stats.mining_stats.solution_stats.num_solutions_found += ss.num_sols;
-			}
-			thread::sleep(std::time::Duration::from_millis(100));
-		}
-	}
-
-	fn output_job_stats(&mut self, stats: Vec<SolverStats>) {
-		let mut sps_total = 0.0;
-		let mut i = 0;
-		for s in stats.clone() {
-			let last_solution_time_secs = s.last_solution_time as f64 / 1000000000.0;
-			let last_hashes_per_sec = 1.0 / last_solution_time_secs;
-			let status = match s.has_errored {
-				false => "OK",
-				_ => "ERRORED",
-			};
-			if !s.has_errored {
-				debug!(
-					LOGGER,
-							"Mining: Plugin {} - Device {} ({}) at Cuck(at)oo{} - Status: {} : Last Graph time: {}s; \
-					 Graphs per second: {:.*} - Total Attempts: {}",
-							i,
-					s.device_id,
-					s.get_device_name(),
-					s.edge_bits,
-					status,
-					last_solution_time_secs,
-					3,
-					last_hashes_per_sec,
-					s.iterations
-				);
-				if last_hashes_per_sec.is_finite() {
-					sps_total += last_hashes_per_sec;
-				}
-			} else {
-				debug!(
-					LOGGER,
-					"Mining: Plugin {} - Device {} ({}) Has ERRORED! Reason: {}",
-					i,
-					s.device_id,
-					s.get_device_name(),
-					s.get_error_reason(),
-				);
-			}
-			i += 1;
-		}
-		info!(
-			LOGGER,
-			"Mining: Cuck(at)oo at {} gps (graphs per second)", sps_total
-		);
-
-		if sps_total.is_finite() {
-			let mut s_stats = self.stats.write().unwrap();
-			s_stats.mining_stats.add_combined_gps(sps_total);
-			s_stats.mining_stats.target_difficulty = self.current_target_diff;
-			s_stats.mining_stats.block_height = self.current_height;
-			s_stats.mining_stats.device_stats = stats;
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/stats.rs grin-miner-copy/src/bin/stats.rs
--- grin-miner-1.0.2/src/bin/stats.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/stats.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,132 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Miner stats collection types, to be used by tests, logging or GUI/TUI
-//! to collect information about mining status
-
-/// Struct to return relevant information about the mining process
-/// back to interested callers (such as the TUI)
-
-use plugin;
-
-#[derive(Clone)]
-pub struct SolutionStats {
-	/// total solutions found
-	pub num_solutions_found: u32,
-	/// total shares accepted
-	pub num_shares_accepted: u32,
-	/// total solutions rejected
-	pub num_rejected: u32,
-	/// total solutions staled
-	pub num_staled: u32,
-	/// total blocks found
-	pub num_blocks_found: u32,
-}
-
-impl Default for SolutionStats {
-	fn default() -> SolutionStats {
-		SolutionStats {
-			num_solutions_found: 0,
-			num_shares_accepted: 0,
-			num_rejected: 0,
-			num_staled: 0,
-			num_blocks_found: 0,
-		}
-	}
-}
-
-#[derive(Clone)]
-pub struct MiningStats {
-	/// combined graphs per second
-	combined_gps: Vec<f64>,
-	/// what block height we're mining at
-	pub block_height: u64,
-	/// current target for share difficulty we're working on
-	pub target_difficulty: u64,
-	/// solution statistics
-	pub solution_stats: SolutionStats,
-	/// Individual device status from Cuckoo-Miner
-	pub device_stats: Vec<plugin::SolverStats>,
-}
-
-impl Default for MiningStats {
-	fn default() -> MiningStats {
-		MiningStats {
-			combined_gps: vec![],
-			block_height: 0,
-			target_difficulty: 0,
-			solution_stats: SolutionStats::default(),
-			device_stats: vec![],
-		}
-	}
-}
-
-impl MiningStats {
-	pub fn add_combined_gps(&mut self, val: f64) {
-		self.combined_gps.insert(0, val);
-		self.combined_gps.truncate(50);
-	}
-
-	pub fn combined_gps(&self) -> f64 {
-		if self.combined_gps.is_empty() {
-			0.0
-		} else {
-			let sum: f64 = self.combined_gps.iter().sum();
-			sum / (self.combined_gps.len() as f64)
-		}
-	}
-}
-
-#[derive(Clone)]
-pub struct ClientStats {
-	/// Server we're connected to
-	pub server_url: String,
-	/// whether we're connected
-	pub connected: bool,
-	/// Connection status
-	pub connection_status: String,
-	/// Last message sent to server
-	pub last_message_sent: String,
-	/// Last response/command received from server
-	pub last_message_received: String,
-}
-
-impl Default for ClientStats {
-	fn default() -> ClientStats {
-		ClientStats {
-			server_url: "".to_string(),
-			connected: false,
-			connection_status: "Connection Status: Starting".to_string(),
-			last_message_sent: "Last Message Sent: None".to_string(),
-			last_message_received: "Last Message Received: None".to_string(),
-		}
-	}
-}
-
-#[derive(Clone)]
-pub struct Stats {
-	/// Client/networking stats
-	pub client_stats: ClientStats,
-	/// Mining stats
-	pub mining_stats: MiningStats,
-}
-
-impl Default for Stats {
-	fn default() -> Stats {
-		Stats {
-			client_stats: ClientStats::default(),
-			mining_stats: MiningStats::default(),
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/constants.rs grin-miner-copy/src/bin/tui/constants.rs
--- grin-miner-1.0.2/src/bin/tui/constants.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/constants.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,31 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Identifiers for various TUI elements, because they may be referenced
-//! from a few different places
-
-/// Mining View
-pub const VIEW_MINING: &str = "mining_view";
-/// Mining status
-pub const TABLE_MINING_STATUS: &str = "mining_status_table";
-
-// Mining View
-/// Version view
-pub const VIEW_VERSION: &str = "version_view";
-
-// Menu and root elements
-/// Main menu
-pub const MAIN_MENU: &str = "main_menu";
-/// root stack
-pub const ROOT_STACK: &str = "root_stack";
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/menu.rs grin-miner-copy/src/bin/tui/menu.rs
--- grin-miner-1.0.2/src/bin/tui/menu.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/menu.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,71 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Main Menu definition
-
-use cursive::Cursive;
-use cursive::view::View;
-use cursive::align::HAlign;
-use cursive::event::{EventResult, Key};
-use cursive::view::Identifiable;
-use cursive::views::{BoxView, LinearLayout, OnEventView, SelectView, StackView, TextView, ViewRef};
-use cursive::direction::Orientation;
-
-use tui::constants::*;
-
-/// Create menu
-pub fn create() -> Box<View> {
-	let mut main_menu = SelectView::new().h_align(HAlign::Left).with_id(MAIN_MENU);
-	main_menu.get_mut().add_item("Mining", VIEW_MINING);
-	main_menu.get_mut().add_item("Version Info", VIEW_VERSION);
-	let change_view = |s: &mut Cursive, v: &&str| {
-		if *v == "" {
-			return;
-		}
-
-		let _ = s.call_on_id(ROOT_STACK, |sv: &mut StackView| {
-			let pos = sv.find_layer_from_id(v).unwrap();
-			sv.move_to_front(pos);
-		});
-	};
-
-	main_menu.get_mut().set_on_select(change_view);
-	let main_menu = OnEventView::new(main_menu)
-		.on_pre_event('j', move |c| {
-			let mut s: ViewRef<SelectView<&str>> = c.find_id(MAIN_MENU).unwrap();
-			s.select_down(1)(c);
-			Some(EventResult::Consumed(None));
-		})
-		.on_pre_event('k', move |c| {
-			let mut s: ViewRef<SelectView<&str>> = c.find_id(MAIN_MENU).unwrap();
-			s.select_up(1)(c);
-			Some(EventResult::Consumed(None));
-		})
-		.on_pre_event(Key::Tab, move |c| {
-			let mut s: ViewRef<SelectView<&str>> = c.find_id(MAIN_MENU).unwrap();
-			if s.selected_id().unwrap() == s.len() - 1 {
-				s.set_selection(0)(c);
-			} else {
-				s.select_down(1)(c);
-			}
-			Some(EventResult::Consumed(None));
-		});
-	let main_menu = LinearLayout::new(Orientation::Vertical)
-		.child(BoxView::with_full_height(main_menu))
-		.child(TextView::new("------------------"))
-		.child(TextView::new("Tab/Arrow : Cycle "))
-		.child(TextView::new("Enter     : Select"))
-		.child(TextView::new("Q         : Quit  "));
-	Box::new(main_menu)
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/mining.rs grin-miner-copy/src/bin/tui/mining.rs
--- grin-miner-1.0.2/src/bin/tui/mining.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/mining.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,234 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Mining status view definition
-
-use std::cmp::Ordering;
-use std::sync::{Arc, RwLock};
-
-use cursive::direction::Orientation;
-use cursive::traits::*;
-use cursive::view::View;
-use cursive::views::{BoxView, Dialog, LinearLayout, StackView, TextView};
-use cursive::Cursive;
-
-use tui::constants::*;
-use tui::types::*;
-
-use plugin::SolverStats;
-use stats;
-use tui::table::{TableView, TableViewItem};
-
-#[derive(Copy, Clone, PartialEq, Eq, Hash)]
-enum MiningDeviceColumn {
-	Plugin,
-	DeviceId,
-	DeviceName,
-	EdgeBits,
-	ErrorStatus,
-	LastGraphTime,
-	GraphsPerSecond,
-}
-
-impl MiningDeviceColumn {
-	fn _as_str(&self) -> &str {
-		match *self {
-			MiningDeviceColumn::Plugin => "Plugin",
-			MiningDeviceColumn::DeviceId => "Device ID",
-			MiningDeviceColumn::DeviceName => "Name",
-			MiningDeviceColumn::EdgeBits => "Graph Size",
-			MiningDeviceColumn::ErrorStatus => "Status",
-			MiningDeviceColumn::LastGraphTime => "Last Graph Time",
-			MiningDeviceColumn::GraphsPerSecond => "GPS",
-		}
-	}
-}
-
-impl TableViewItem<MiningDeviceColumn> for SolverStats {
-	fn to_column(&self, column: MiningDeviceColumn) -> String {
-		let last_solution_time_secs = self.last_solution_time as f64 / 1000000000.0;
-		match column {
-			MiningDeviceColumn::Plugin => self.get_plugin_name(),
-			MiningDeviceColumn::DeviceId => format!("{}", self.device_id).to_owned(),
-			MiningDeviceColumn::DeviceName => self.get_device_name(),
-			MiningDeviceColumn::EdgeBits => format!("{}", self.edge_bits).to_owned(),
-			MiningDeviceColumn::ErrorStatus => match self.has_errored {
-				false => String::from("OK"),
-				_ => String::from("Errored"),
-			},
-			MiningDeviceColumn::LastGraphTime => {
-				String::from(format!("{}s", last_solution_time_secs))
-			}
-			MiningDeviceColumn::GraphsPerSecond => {
-				String::from(format!("{:.*}", 4, 1.0 / last_solution_time_secs))
-			}
-		}
-	}
-
-	fn cmp(&self, other: &Self, column: MiningDeviceColumn) -> Ordering
-	where
-		Self: Sized,
-	{
-		let last_solution_time_secs_self = self.last_solution_time as f64 / 1000000000.0;
-		let gps_self = 1.0 / last_solution_time_secs_self;
-		let last_solution_time_secs_other = other.last_solution_time as f64 / 1000000000.0;
-		let gps_other = 1.0 / last_solution_time_secs_other;
-		match column {
-			MiningDeviceColumn::Plugin => self.plugin_name.cmp(&other.plugin_name),
-			MiningDeviceColumn::DeviceId => self.device_id.cmp(&other.device_id),
-			MiningDeviceColumn::DeviceName => self.device_name.cmp(&other.device_name),
-			MiningDeviceColumn::EdgeBits => self.edge_bits.cmp(&other.edge_bits),
-			MiningDeviceColumn::ErrorStatus => self.has_errored.cmp(&other.has_errored),
-			MiningDeviceColumn::LastGraphTime => {
-				self.last_solution_time.cmp(&other.last_solution_time)
-			}
-			MiningDeviceColumn::GraphsPerSecond => gps_self.partial_cmp(&gps_other).unwrap(),
-		}
-	}
-}
-
-/// Mining status view
-pub struct TUIMiningView;
-
-impl TUIStatusListener for TUIMiningView {
-	/// Create the mining view
-	fn create() -> Box<View> {
-		let table_view = TableView::<SolverStats, MiningDeviceColumn>::new()
-			.column(MiningDeviceColumn::Plugin, "Plugin", |c| {
-				c.width_percent(20)
-			}).column(MiningDeviceColumn::DeviceId, "Device ID", |c| {
-				c.width_percent(5)
-			}).column(MiningDeviceColumn::DeviceName, "Device Name", |c| {
-				c.width_percent(20)
-			}).column(MiningDeviceColumn::EdgeBits, "Size", |c| c.width_percent(5))
-			.column(MiningDeviceColumn::ErrorStatus, "Status", |c| {
-				c.width_percent(8)
-			}).column(MiningDeviceColumn::LastGraphTime, "Graph Time", |c| {
-				c.width_percent(10)
-			}).column(MiningDeviceColumn::GraphsPerSecond, "GPS", |c| {
-				c.width_percent(10)
-			});
-
-		let status_view =
-			LinearLayout::new(Orientation::Vertical)
-				.child(LinearLayout::new(Orientation::Horizontal).child(
-					TextView::new("Connection Status: Starting...").with_id("mining_server_status"),
-				)).child(
-					LinearLayout::new(Orientation::Horizontal)
-						.child(TextView::new("Mining Status: ").with_id("mining_status")),
-				).child(
-					LinearLayout::new(Orientation::Horizontal)
-						.child(TextView::new("  ").with_id("network_info")),
-				).child(
-				LinearLayout::new(Orientation::Horizontal)
-					.child(TextView::new("  ").with_id("mining_statistics")),
-				).child(
-				LinearLayout::new(Orientation::Horizontal)
-					.child(TextView::new("Last Message Sent:  ").with_id("last_message_sent")),
-				).child(LinearLayout::new(Orientation::Horizontal).child(
-				TextView::new("Last Message Received:  ").with_id("last_message_received"),
-				));
-
-		let mining_device_view = LinearLayout::new(Orientation::Vertical)
-			.child(status_view)
-			.child(BoxView::with_full_screen(
-				Dialog::around(table_view.with_id(TABLE_MINING_STATUS).min_size((50, 20)))
-					.title("Mining Devices"),
-			)).with_id("mining_device_view");
-
-		let view_stack = StackView::new()
-			.layer(mining_device_view)
-			.with_id("mining_stack_view");
-
-		let mining_view = LinearLayout::new(Orientation::Vertical).child(view_stack);
-
-		Box::new(mining_view.with_id(VIEW_MINING))
-	}
-
-	/// update
-	fn update(c: &mut Cursive, stats: Arc<RwLock<stats::Stats>>) {
-
-		let (client_stats, mining_stats) = {
-			let stats = stats.read().unwrap();
-			(stats.client_stats.clone(), stats.mining_stats.clone())
-		};
-
-		c.call_on_id("mining_server_status", |t: &mut TextView| {
-			t.set_content(client_stats.connection_status.clone());
-		});
-
-		let (basic_mining_status, basic_network_info) = {
-			if client_stats.connected {
-				if mining_stats.combined_gps() == 0.0 {
-					(
-						"Mining Status: Starting miner and awaiting first graph time..."
-							.to_string(),
-						" ".to_string(),
-					)
-				} else {
-					(
-						format!(
-							"Mining Status: Mining at height {} at {:.*} GPS",
-							mining_stats.block_height, 4, mining_stats.combined_gps()
-						),
-						format!(
-							"Cuck(at)oo - Target Share Difficulty {}",
-							mining_stats.target_difficulty.to_string()
-						),
-					)
-				}
-			} else {
-				(
-					"Mining Status: Waiting for server".to_string(),
-					"  ".to_string(),
-				)
-			}
-		};
-
-		// device
-		c.call_on_id("mining_status", |t: &mut TextView| {
-			t.set_content(basic_mining_status);
-		});
-		c.call_on_id("network_info", |t: &mut TextView| {
-			t.set_content(basic_network_info);
-		});
-
-		c.call_on_id("last_message_sent", |t: &mut TextView| {
-			t.set_content(client_stats.last_message_sent.clone());
-		});
-		c.call_on_id("last_message_received", |t: &mut TextView| {
-			t.set_content(client_stats.last_message_received.clone());
-		});
-
-		if mining_stats.solution_stats.num_solutions_found > 0 {
-			let sol_stat = format!("Solutions found: {}. Accepted: {}, Rejected: {}, Stale: {}, Blocks found: {}",
-								   mining_stats.solution_stats.num_solutions_found,
-								   mining_stats.solution_stats.num_shares_accepted,
-								   mining_stats.solution_stats.num_rejected,
-								   mining_stats.solution_stats.num_staled,
-								   mining_stats.solution_stats.num_blocks_found,
-			);
-			c.call_on_id("mining_statistics", |t: &mut TextView| {
-				t.set_content(sol_stat);
-			});
-		}
-
-		let _ = c.call_on_id(
-			TABLE_MINING_STATUS,
-			|t: &mut TableView<SolverStats, MiningDeviceColumn>| {
-				t.set_items(mining_stats.device_stats);
-			},
-		);
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/mod.rs grin-miner-copy/src/bin/tui/mod.rs
--- grin-miner-1.0.2/src/bin/tui/mod.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/mod.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Grin Miner TUI
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-pub mod ui;
-pub mod table;
-pub mod constants;
-pub mod menu;
-pub mod mining;
-pub mod version;
-pub mod types;
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/table.rs grin-miner-copy/src/bin/tui/table.rs
--- grin-miner-1.0.2/src/bin/tui/table.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/table.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,985 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Copyright (c) 2015-2017 Ivo Wetzel
-//
-// Permission is hereby granted, free of charge, to any
-// person obtaining a copy of this software and associated
-// documentation files (the "Software"), to deal in the
-// Software without restriction, including without
-// limitation the rights to use, copy, modify, merge,
-// publish, distribute, sublicense, and/or sell copies of
-// the Software, and to permit persons to whom the Software
-// is furnished to do so, subject to the following
-// conditions:
-//
-// The above copyright notice and this permission notice
-// shall be included in all copies or substantial portions
-// of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
-// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
-// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
-// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
-// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-
-//! Adapted from https://github.com/behnam/rust-cursive-table-view
-//! A basic table view implementation for [cursive](https://crates.io/crates/cursive).
-
-#![deny(missing_docs, missing_copy_implementations, trivial_casts, trivial_numeric_casts,
-        unsafe_code, unused_import_braces, unused_qualifications)]
-
-// Crate Dependencies ---------------------------------------------------------
-extern crate cursive;
-
-// STD Dependencies -----------------------------------------------------------
-use std::rc::Rc;
-use std::hash::Hash;
-use std::cmp::{self, Ordering};
-use std::collections::HashMap;
-
-// External Dependencies ------------------------------------------------------
-use cursive::With;
-use cursive::vec::Vec2;
-use cursive::align::HAlign;
-use cursive::theme::ColorStyle;
-use cursive::{Cursive, Printer};
-use cursive::direction::Direction;
-use cursive::view::{ScrollBase, View};
-use cursive::event::{Callback, Event, EventResult, Key};
-use cursive::theme::PaletteColor::*;
-
-/// A trait for displaying and sorting items inside a
-/// [`TableView`](struct.TableView.html).
-pub trait TableViewItem<H>: Clone + Sized
-where
-	H: Eq + Hash + Copy + Clone + 'static,
-{
-	/// Method returning a string representation of the item for the
-	/// specified column from type `H`.
-	fn to_column(&self, column: H) -> String;
-
-	/// Method comparing two items via their specified column from type `H`.
-	fn cmp(&self, other: &Self, column: H) -> Ordering
-	where
-		Self: Sized;
-}
-
-/// View to select an item among a list, supporting multiple columns for sorting.
-///
-/// # Examples
-///
-/// ```rust
-/// # extern crate cursive;
-/// # extern crate cursive_table_view;
-/// # use std::cmp::Ordering;
-/// # use cursive_table_view::{TableView, TableViewItem};
-/// # use cursive::align::HAlign;
-/// # fn main() {
-/// // Provide a type for the table's columns
-/// #[derive(Copy, Clone, PartialEq, Eq, Hash)]
-/// enum BasicColumn {
-///     Name,
-///     Count,
-///     Rate
-/// }
-///
-/// // Define the item type
-/// #[derive(Clone, Debug)]
-/// struct Foo {
-///     name: String,
-///     count: usize,
-///     rate: usize
-/// }
-///
-/// impl TableViewItem<BasicColumn> for Foo {
-///
-///     fn to_column(&self, column: BasicColumn) -> String {
-///         match column {
-///             BasicColumn::Name => self.name.to_string(),
-///             BasicColumn::Count => format!("{}", self.count),
-///             BasicColumn::Rate => format!("{}", self.rate)
-///         }
-///     }
-///
-///     fn cmp(&self, other: &Self, column: BasicColumn) -> Ordering where Self: Sized {
-///         match column {
-///             BasicColumn::Name => self.name.cmp(&other.name),
-///             BasicColumn::Count => self.count.cmp(&other.count),
-///             BasicColumn::Rate => self.rate.cmp(&other.rate)
-///         }
-///     }
-///
-/// }
-///
-/// // Configure the actual table
-/// let table = TableView::<Foo, BasicColumn>::new()
-///                      .column(BasicColumn::Name, "Name", |c| c.width(20))
-///                      .column(BasicColumn::Count, "Count", |c| c.align(HAlign::Center))
-///                      .column(BasicColumn::Rate, "Rate", |c| {
-///                          c.ordering(Ordering::Greater).align(HAlign::Right).width(20)
-///                      })
-///                      .default_column(BasicColumn::Name);
-/// # }
-/// ```
-pub struct TableView<T: TableViewItem<H>, H: Eq + Hash + Copy + Clone + 'static> {
-	enabled: bool,
-	scrollbase: ScrollBase,
-	last_size: Vec2,
-
-	column_select: bool,
-	columns: Vec<TableColumn<H>>,
-	column_indicies: HashMap<H, usize>,
-
-	focus: usize,
-	items: Vec<T>,
-	rows_to_items: Vec<usize>,
-
-	on_sort: Option<Rc<Fn(&mut Cursive, H, Ordering)>>,
-	// TODO Pass drawing offsets into the handlers so a popup menu
-	// can be created easily?
-	on_submit: Option<Rc<Fn(&mut Cursive, usize, usize)>>,
-	on_select: Option<Rc<Fn(&mut Cursive, usize, usize)>>,
-}
-
-impl<T: TableViewItem<H>, H: Eq + Hash + Copy + Clone + 'static> TableView<T, H> {
-	/// Creates a new empty `TableView` without any columns.
-	///
-	/// A TableView should be accompanied by a enum of type `H` representing
-	/// the table columns.
-	pub fn new() -> Self {
-		Self {
-			enabled: true,
-			scrollbase: ScrollBase::new(),
-			last_size: Vec2::new(0, 0),
-
-			column_select: false,
-			columns: Vec::new(),
-			column_indicies: HashMap::new(),
-
-			focus: 0,
-			items: Vec::new(),
-			rows_to_items: Vec::new(),
-
-			on_sort: None,
-			on_submit: None,
-			on_select: None,
-		}
-	}
-
-	/// Adds a column for the specified table colum from type `H` along with
-	/// a title for its visual display.
-	///
-	/// The provided callback can be used to further configure the
-	/// created [`TableColumn`](struct.TableColumn.html).
-	pub fn column<S: Into<String>, C: FnOnce(TableColumn<H>) -> TableColumn<H>>(
-		mut self,
-		column: H,
-		title: S,
-		callback: C,
-	) -> Self {
-		self.column_indicies.insert(column, self.columns.len());
-		self.columns
-			.push(callback(TableColumn::new(column, title.into())));
-
-		// Make the first colum the default one
-		if self.columns.len() == 1 {
-			self.default_column(column)
-		} else {
-			self
-		}
-	}
-
-	/// Sets the initially active column of the table.
-	pub fn default_column(mut self, column: H) -> Self {
-		if self.column_indicies.contains_key(&column) {
-			for c in &mut self.columns {
-				c.selected = c.column == column;
-				if c.selected {
-					c.order = c.default_order;
-				} else {
-					c.order = Ordering::Equal;
-				}
-			}
-		}
-		self
-	}
-
-	/// Sorts the table using the specified table `column` and the passed
-	/// `order`.
-	pub fn sort_by(&mut self, column: H, order: Ordering) {
-		if self.column_indicies.contains_key(&column) {
-			for c in &mut self.columns {
-				c.selected = c.column == column;
-				if c.selected {
-					c.order = order;
-				} else {
-					c.order = Ordering::Equal;
-				}
-			}
-		}
-
-		self.sort_items(column, order);
-	}
-
-	/// Sorts the table using the currently active column and its
-	/// ordering.
-	pub fn sort(&mut self) {
-		if let Some((column, order)) = self.order() {
-			self.sort_items(column, order);
-		}
-	}
-
-	/// Returns the currently active column that is used for sorting
-	/// along with its ordering.
-	///
-	/// Might return `None` if there are currently no items in the table
-	/// and it has not been sorted yet.
-	pub fn order(&self) -> Option<(H, Ordering)> {
-		for c in &self.columns {
-			if c.order != Ordering::Equal {
-				return Some((c.column, c.order));
-			}
-		}
-		None
-	}
-
-	/// Disables this view.
-	///
-	/// A disabled view cannot be selected.
-	pub fn disable(&mut self) {
-		self.enabled = false;
-	}
-
-	/// Re-enables this view.
-	pub fn enable(&mut self) {
-		self.enabled = true;
-	}
-
-	/// Enable or disable this view.
-	pub fn set_enabled(&mut self, enabled: bool) {
-		self.enabled = enabled;
-	}
-
-	/// Returns `true` if this view is enabled.
-	pub fn is_enabled(&self) -> bool {
-		self.enabled
-	}
-
-	/// Sets a callback to be used when a selected column is sorted by
-	/// pressing `<Enter>`.
-	///
-	/// # Example
-	///
-	/// ```norun
-	/// table.set_on_sort(|siv: &mut Cursive, column: BasicColumn, order: Ordering| {
-	///
-	/// });
-	/// ```
-	pub fn set_on_sort<F>(&mut self, cb: F)
-	where
-		F: Fn(&mut Cursive, H, Ordering) + 'static,
-	{
-		self.on_sort = Some(Rc::new(move |s, h, o| cb(s, h, o)));
-	}
-
-	/// Sets a callback to be used when a selected column is sorted by
-	/// pressing `<Enter>`.
-	///
-	/// Chainable variant.
-	///
-	/// # Example
-	///
-	/// ```norun
-	/// table.on_sort(|siv: &mut Cursive, column: BasicColumn, order: Ordering| {
-	///
-	/// });
-	/// ```
-	pub fn on_sort<F>(self, cb: F) -> Self
-	where
-		F: Fn(&mut Cursive, H, Ordering) + 'static,
-	{
-		self.with(|t| t.set_on_sort(cb))
-	}
-
-	/// Sets a callback to be used when `<Enter>` is pressed while an item
-	/// is selected.
-	///
-	/// Both the currently selected row and the index of the corresponding item
-	/// within the underlying storage vector will be given to the callback.
-	///
-	/// # Example
-	///
-	/// ```norun
-	/// table.set_on_submit(|siv: &mut Cursive, row: usize, index: usize| {
-	///
-	/// });
-	/// ```
-	pub fn set_on_submit<F>(&mut self, cb: F)
-	where
-		F: Fn(&mut Cursive, usize, usize) + 'static,
-	{
-		self.on_submit = Some(Rc::new(move |s, row, index| cb(s, row, index)));
-	}
-
-	/// Sets a callback to be used when `<Enter>` is pressed while an item
-	/// is selected.
-	///
-	/// Both the currently selected row and the index of the corresponding item
-	/// within the underlying storage vector will be given to the callback.
-	///
-	/// Chainable variant.
-	///
-	/// # Example
-	///
-	/// ```norun
-	/// table.on_submit(|siv: &mut Cursive, row: usize, index: usize| {
-	///
-	/// });
-	/// ```
-	pub fn on_submit<F>(self, cb: F) -> Self
-	where
-		F: Fn(&mut Cursive, usize, usize) + 'static,
-	{
-		self.with(|t| t.set_on_submit(cb))
-	}
-
-	/// Sets a callback to be used when an item is selected.
-	///
-	/// Both the currently selected row and the index of the corresponding item
-	/// within the underlying storage vector will be given to the callback.
-	///
-	/// # Example
-	///
-	/// ```norun
-	/// table.set_on_select(|siv: &mut Cursive, row: usize, index: usize| {
-	///
-	/// });
-	/// ```
-	pub fn set_on_select<F>(&mut self, cb: F)
-	where
-		F: Fn(&mut Cursive, usize, usize) + 'static,
-	{
-		self.on_select = Some(Rc::new(move |s, row, index| cb(s, row, index)));
-	}
-
-	/// Sets a callback to be used when an item is selected.
-	///
-	/// Both the currently selected row and the index of the corresponding item
-	/// within the underlying storage vector will be given to the callback.
-	///
-	/// Chainable variant.
-	///
-	/// # Example
-	///
-	/// ```norun
-	/// table.on_select(|siv: &mut Cursive, row: usize, index: usize| {
-	///
-	/// });
-	/// ```
-	pub fn on_select<F>(self, cb: F) -> Self
-	where
-		F: Fn(&mut Cursive, usize, usize) + 'static,
-	{
-		self.with(|t| t.set_on_select(cb))
-	}
-
-	/// Removes all items from this view.
-	pub fn clear(&mut self) {
-		self.items.clear();
-		self.rows_to_items.clear();
-		self.focus = 0;
-	}
-
-	/// Returns the number of items in this table.
-	pub fn len(&self) -> usize {
-		self.items.len()
-	}
-
-	/// Returns `true` if this table has no items.
-	pub fn is_empty(&self) -> bool {
-		self.items.is_empty()
-	}
-
-	/// Returns the index of the currently selected table row.
-	pub fn row(&self) -> Option<usize> {
-		if self.items.is_empty() {
-			None
-		} else {
-			Some(self.focus)
-		}
-	}
-
-	/// Selects the row at the specified index.
-	pub fn set_selected_row(&mut self, row_index: usize) {
-		self.focus = row_index;
-		self.scrollbase.scroll_to(row_index);
-	}
-
-	/// Selects the row at the specified index.
-	///
-	/// Chainable variant.
-	pub fn selected_row(self, row_index: usize) -> Self {
-		self.with(|t| t.set_selected_row(row_index))
-	}
-
-	/// Sets the contained items of the table.
-	///
-	/// The currently active sort order is preserved and will be applied to all
-	/// items.
-	pub fn set_items(&mut self, items: Vec<T>) {
-		self.items = items;
-		self.rows_to_items = Vec::with_capacity(self.items.len());
-
-		for i in 0..self.items.len() {
-			self.rows_to_items.push(i);
-		}
-
-		if let Some((column, order)) = self.order() {
-			self.sort_by(column, order);
-		}
-
-		self.scrollbase
-			.set_heights(self.last_size.y.saturating_sub(2), self.rows_to_items.len());
-
-		self.set_selected_row(0);
-	}
-
-	/// Sets the contained items of the table.
-	///
-	/// The order of the items will be preserved even when the table is sorted.
-	///
-	/// Chainable variant.
-	pub fn items(self, items: Vec<T>) -> Self {
-		self.with(|t| t.set_items(items))
-	}
-
-	/// Returns a immmutable reference to the item at the specified index
-	/// within the underlying storage vector.
-	pub fn borrow_item(&mut self, index: usize) -> Option<&T> {
-		self.items.get(index)
-	}
-
-	/// Returns a mutable reference to the item at the specified index within
-	/// the underlying storage vector.
-	pub fn borrow_item_mut(&mut self, index: usize) -> Option<&mut T> {
-		self.items.get_mut(index)
-	}
-
-	/// Returns a immmutable reference to the items contained within the table.
-	pub fn borrow_items(&mut self) -> &Vec<T> {
-		&self.items
-	}
-
-	/// Returns a mutable reference to the items contained within the table.
-	///
-	/// Can be used to modify the items in place.
-	pub fn borrow_items_mut(&mut self) -> &mut Vec<T> {
-		&mut self.items
-	}
-
-	/// Returns the index of the currently selected item within the underlying
-	/// storage vector.
-	pub fn item(&self) -> Option<usize> {
-		if self.items.is_empty() {
-			None
-		} else {
-			Some(self.rows_to_items[self.focus])
-		}
-	}
-
-	/// Selects the item at the specified index within the underlying storage
-	/// vector.
-	pub fn set_selected_item(&mut self, item_index: usize) {
-		// TODO optimize the performance for very large item lists
-		if item_index < self.items.len() {
-			for (row, item) in self.rows_to_items.iter().enumerate() {
-				if *item == item_index {
-					self.focus = row;
-					self.scrollbase.scroll_to(row);
-					break;
-				}
-			}
-		}
-	}
-
-	/// Selects the item at the specified index within the underlying storage
-	/// vector.
-	///
-	/// Chainable variant.
-	pub fn selected_item(self, item_index: usize) -> Self {
-		self.with(|t| t.set_selected_item(item_index))
-	}
-
-	/// Inserts a new item into the table.
-	///
-	/// The currently active sort order is preserved and will be applied to the
-	/// newly inserted item.
-	pub fn insert_item(&mut self, item: T) {
-		self.items.push(item);
-		self.rows_to_items.push(self.items.len());
-
-		self.scrollbase
-			.set_heights(self.last_size.y.saturating_sub(2), self.rows_to_items.len());
-
-		if let Some((column, order)) = self.order() {
-			self.sort_by(column, order);
-		}
-	}
-
-	/// Removes the item at the specified index within the underlying storage
-	/// vector and returns it.
-	pub fn remove_item(&mut self, item_index: usize) -> Option<T> {
-		if item_index < self.items.len() {
-			// Move the selection if the currently selected item gets removed
-			if let Some(selected_index) = self.item() {
-				if selected_index == item_index {
-					self.focus_up(1);
-				}
-			}
-
-			// Remove the sorted reference to the item
-			self.rows_to_items.retain(|i| *i != item_index);
-
-			// Adjust remaining references
-			for ref_index in &mut self.rows_to_items {
-				if *ref_index > item_index {
-					*ref_index -= 1;
-				}
-			}
-
-			// Update scroll height to prevent out of index drawing
-			self.scrollbase
-				.set_heights(self.last_size.y.saturating_sub(2), self.rows_to_items.len());
-
-			// Remove actual item from the underlying storage
-			Some(self.items.remove(item_index))
-		} else {
-			None
-		}
-	}
-
-	/// Removes all items from the underlying storage and returns them.
-	pub fn take_items(&mut self) -> Vec<T> {
-		self.scrollbase
-			.set_heights(self.last_size.y.saturating_sub(2), 0);
-		self.set_selected_row(0);
-		self.rows_to_items.clear();
-		self.items.drain(0..).collect()
-	}
-}
-
-impl<T: TableViewItem<H>, H: Eq + Hash + Copy + Clone + 'static> TableView<T, H> {
-	fn draw_columns<C: Fn(&Printer, &TableColumn<H>)>(
-		&self,
-		printer: &Printer,
-		sep: &str,
-		callback: C,
-	) {
-		let mut column_offset = 0;
-		let column_count = self.columns.len();
-		for (index, column) in self.columns.iter().enumerate() {
-			let printer = &printer.offset((column_offset, 0)).focused(true); 
-
-			callback(printer, column);
-
-			if index < column_count - 1 {
-				printer.print((column.width + 1, 0), sep);
-			}
-
-			column_offset += column.width + 3;
-		}
-	}
-
-	fn sort_items(&mut self, column: H, order: Ordering) {
-		if !self.is_empty() {
-			let old_item = self.item().unwrap();
-
-			let mut rows_to_items = self.rows_to_items.clone();
-			rows_to_items.sort_by(|a, b| {
-				if order == Ordering::Less {
-					self.items[*a].cmp(&self.items[*b], column)
-				} else {
-					self.items[*b].cmp(&self.items[*a], column)
-				}
-			});
-			self.rows_to_items = rows_to_items;
-
-			self.set_selected_item(old_item);
-		}
-	}
-
-	fn draw_item(&self, printer: &Printer, i: usize) {
-		self.draw_columns(printer, "┆ ", |printer, column| {
-			let value = self.items[self.rows_to_items[i]].to_column(column.column);
-			column.draw_row(printer, value.as_str());
-		});
-	}
-
-	fn focus_up(&mut self, n: usize) {
-		self.focus -= cmp::min(self.focus, n);
-	}
-
-	fn focus_down(&mut self, n: usize) {
-		self.focus = cmp::min(self.focus + n, self.items.len() - 1);
-	}
-
-	fn active_column(&self) -> usize {
-		self.columns.iter().position(|c| c.selected).unwrap_or(0)
-	}
-
-	fn column_cancel(&mut self) {
-		self.column_select = false;
-		for column in &mut self.columns {
-			column.selected = column.order != Ordering::Equal;
-		}
-	}
-
-	fn column_next(&mut self) -> bool {
-		let column = self.active_column();
-		if column < self.columns.len() - 1 {
-			self.columns[column].selected = false;
-			self.columns[column + 1].selected = true;
-			true
-		} else {
-			false
-		}
-	}
-
-	fn column_prev(&mut self) -> bool {
-		let column = self.active_column();
-		if column > 0 {
-			self.columns[column].selected = false;
-			self.columns[column - 1].selected = true;
-			true
-		} else {
-			false
-		}
-	}
-
-	fn column_select(&mut self) {
-		let next = self.active_column();
-		let column = self.columns[next].column;
-		let current = self.columns
-			.iter()
-			.position(|c| c.order != Ordering::Equal)
-			.unwrap_or(0);
-
-		let order = if current != next {
-			self.columns[next].default_order
-		} else if self.columns[current].order == Ordering::Less {
-			Ordering::Greater
-		} else {
-			Ordering::Less
-		};
-
-		self.sort_by(column, order);
-	}
-}
-
-impl<T: TableViewItem<H> + 'static, H: Eq + Hash + Copy + Clone + 'static> View
-	for TableView<T, H> {
-	fn draw(&self, printer: &Printer) {
-		self.draw_columns(printer, "╷ ", |printer, column| {
-			let color = if column.order != Ordering::Equal || column.selected {
-				if self.column_select && column.selected && self.enabled && printer.focused {
-					Highlight
-				} else {
-					HighlightInactive
-				}
-			} else {
-				Primary
-			};
-
-			printer.with_color(ColorStyle::from(color), |printer| {
-				column.draw_header(printer);
-			});
-		});
-
-		self.draw_columns(
-			&printer.offset((0, 1)).focused(true),
-			"┴─",
-			|printer, column| {
-				printer.print_hline((0, 0), column.width + 1, "─");
-			},
-		);
-
-		let printer = &printer.offset((0, 2)).focused(true);
-		self.scrollbase.draw(printer, |printer, i| {
-			let color = if i == self.focus {
-				if !self.column_select && self.enabled && printer.focused {
-					Highlight
-				} else {
-					HighlightInactive
-				}
-			} else {
-				Primary
-			};
-
-			printer.with_color(ColorStyle::from(color), |printer| {
-				self.draw_item(printer, i);
-			});
-		});
-	}
-
-	fn layout(&mut self, size: Vec2) {
-		if size == self.last_size {
-			return;
-		}
-
-		let item_count = self.items.len();
-		let column_count = self.columns.len();
-
-		// Split up all columns into sized / unsized groups
-		let (mut sized, mut usized): (Vec<&mut TableColumn<H>>, Vec<&mut TableColumn<H>>) =
-			self.columns
-				.iter_mut()
-				.partition(|c| c.requested_width.is_some());
-
-		// Subtract one for the seperators between our columns (that's column_count - 1)
-		let mut available_width = size.x.saturating_sub(column_count.saturating_sub(1) * 3);
-
-		// Reduce the with in case we are displaying a scrollbar
-		if size.y.saturating_sub(1) < item_count {
-			available_width = available_width.saturating_sub(2);
-		}
-
-		// Calculate widths for all requested columns
-		let mut remaining_width = available_width;
-		for column in &mut sized {
-			column.width = match *column.requested_width.as_ref().unwrap() {
-				TableColumnWidth::Percent(width) => cmp::min(
-					(size.x as f32 / 100.0 * width as f32).ceil() as usize,
-					remaining_width,
-				),
-				TableColumnWidth::Absolute(width) => width,
-			};
-			remaining_width = remaining_width.saturating_sub(column.width);
-		}
-
-		// Spread the remaining with across the unsized columns
-		let remaining_columns = usized.len();
-		for column in &mut usized {
-			column.width = (remaining_width as f32 / remaining_columns as f32).floor() as usize;
-		}
-
-		self.scrollbase
-			.set_heights(size.y.saturating_sub(2), item_count);
-		self.last_size = size;
-	}
-
-	fn take_focus(&mut self, _: Direction) -> bool {
-		self.enabled && !self.items.is_empty()
-	}
-
-	fn on_event(&mut self, event: Event) -> EventResult {
-		if !self.enabled {
-			return EventResult::Ignored;
-		}
-
-		let last_focus = self.focus;
-		match event {
-			Event::Key(Key::Right) => {
-				if self.column_select {
-					if !self.column_next() {
-						return EventResult::Ignored;
-					}
-				} else {
-					self.column_select = true;
-				}
-			}
-			Event::Key(Key::Left) => {
-				if self.column_select {
-					if !self.column_prev() {
-						return EventResult::Ignored;
-					}
-				} else {
-					self.column_select = true;
-				}
-			}
-			Event::Key(Key::Up) if self.focus > 0 || self.column_select => {
-				if self.column_select {
-					self.column_cancel();
-				} else {
-					self.focus_up(1);
-				}
-			}
-			Event::Key(Key::Down) if self.focus + 1 < self.items.len() || self.column_select => {
-				if self.column_select {
-					self.column_cancel();
-				} else {
-					self.focus_down(1);
-				}
-			}
-			Event::Key(Key::PageUp) => {
-				self.column_cancel();
-				self.focus_up(10);
-			}
-			Event::Key(Key::PageDown) => {
-				self.column_cancel();
-				self.focus_down(10);
-			}
-			Event::Key(Key::Home) => {
-				self.column_cancel();
-				self.focus = 0;
-			}
-			Event::Key(Key::End) => {
-				self.column_cancel();
-				self.focus = self.items.len() - 1;
-			}
-			Event::Key(Key::Enter) => {
-				if self.column_select {
-					self.column_select();
-
-					if self.on_sort.is_some() {
-						let c = &self.columns[self.active_column()];
-						let column = c.column;
-						let order = c.order;
-
-						let cb = self.on_sort.clone().unwrap();
-						return EventResult::Consumed(Some(Callback::from_fn(move |s| {
-							cb(s, column, order)
-						})));
-					}
-				} else if !self.is_empty() && self.on_submit.is_some() {
-					let cb = self.on_submit.clone().unwrap();
-					let row = self.row().unwrap();
-					let index = self.item().unwrap();
-					return EventResult::Consumed(Some(Callback::from_fn(move |s| {
-						cb(s, row, index)
-					})));
-				}
-			}
-			_ => return EventResult::Ignored,
-		}
-
-		let focus = self.focus;
-		self.scrollbase.scroll_to(focus);
-
-		if self.column_select {
-			EventResult::Consumed(None)
-		} else if !self.is_empty() && last_focus != focus {
-			let row = self.row().unwrap();
-			let index = self.item().unwrap();
-			EventResult::Consumed(
-				self.on_select
-					.clone()
-					.map(|cb| Callback::from_fn(move |s| cb(s, row, index))),
-			)
-		} else {
-			EventResult::Ignored
-		}
-	}
-}
-
-/// A type used for the construction of columns in a
-/// [`TableView`](struct.TableView.html).
-pub struct TableColumn<H: Copy + Clone + 'static> {
-	column: H,
-	title: String,
-	selected: bool,
-	alignment: HAlign,
-	order: Ordering,
-	width: usize,
-	default_order: Ordering,
-	requested_width: Option<TableColumnWidth>,
-}
-
-enum TableColumnWidth {
-	Percent(usize),
-	Absolute(usize),
-}
-
-impl<H: Copy + Clone + 'static> TableColumn<H> {
-	/// Sets the default ordering of the column.
-	pub fn ordering(mut self, order: Ordering) -> Self {
-		self.default_order = order;
-		self
-	}
-
-	/// Sets the horizontal text alignment of the column.
-	pub fn align(mut self, alignment: HAlign) -> Self {
-		self.alignment = alignment;
-		self
-	}
-
-	/// Sets how many characters of width this column will try to occupy.
-	pub fn width(mut self, width: usize) -> Self {
-		self.requested_width = Some(TableColumnWidth::Absolute(width));
-		self
-	}
-
-	/// Sets what percentage of the width of the entire table this column will
-	/// try to occupy.
-	pub fn width_percent(mut self, width: usize) -> Self {
-		self.requested_width = Some(TableColumnWidth::Percent(width));
-		self
-	}
-
-	fn new(column: H, title: String) -> Self {
-		Self {
-			column: column,
-			title: title,
-			selected: false,
-			alignment: HAlign::Left,
-			order: Ordering::Equal,
-			width: 0,
-			default_order: Ordering::Less,
-			requested_width: None,
-		}
-	}
-
-	fn draw_header(&self, printer: &Printer) {
-		let order = match self.order {
-			Ordering::Less => "^",
-			Ordering::Greater => "v",
-			Ordering::Equal => " ",
-		};
-
-		let header = match self.alignment {
-			HAlign::Left => format!(
-				"{:<width$} [{}]",
-				self.title,
-				order,
-				width = self.width.saturating_sub(4)
-			),
-			HAlign::Right => format!(
-				"{:>width$} [{}]",
-				self.title,
-				order,
-				width = self.width.saturating_sub(4)
-			),
-			HAlign::Center => format!(
-				"{:^width$} [{}]",
-				self.title,
-				order,
-				width = self.width.saturating_sub(4)
-			),
-		};
-		printer.print((0, 0), header.as_str());
-	}
-
-	fn draw_row(&self, printer: &Printer, value: &str) {
-		let value = match self.alignment {
-			HAlign::Left => format!("{:<width$} ", value, width = self.width),
-			HAlign::Right => format!("{:>width$} ", value, width = self.width),
-			HAlign::Center => format!("{:^width$} ", value, width = self.width),
-		};
-		printer.print((0, 0), value.as_str());
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/types.rs grin-miner-copy/src/bin/tui/types.rs
--- grin-miner-1.0.2/src/bin/tui/types.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/types.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Types specific to the UI module
-
-use std::sync::{Arc, RwLock};
-
-use cursive::Cursive;
-use cursive::view::View;
-use stats::Stats;
-
-/// Main message struct to communicate between the UI and
-/// the main process
-pub enum UIMessage {
-	/// Update mining status
-	UpdateStatus(Arc<RwLock<Stats>>),
-}
-
-/// Trait for a UI element that recieves status update messages
-/// and updates itself
-
-pub trait TUIStatusListener {
-	/// create the view, to return to the main UI controller
-	fn create() -> Box<View>;
-	/// Update according to status update contents
-	fn update(c: &mut Cursive, stats: Arc<RwLock<Stats>>);
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/ui.rs grin-miner-copy/src/bin/tui/ui.rs
--- grin-miner-1.0.2/src/bin/tui/ui.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/ui.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,183 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Basic TUI to better output the overall system status and status
-//! of various subsystems
-
-use std::{self, thread};
-use std::sync::{mpsc, Arc, RwLock};
-use time;
-
-use cursive::Cursive;
-use cursive::theme::{BaseColor, BorderStyle, Color, Theme};
-use cursive::theme::PaletteColor::*;
-use cursive::theme::Color::*;
-use cursive::theme::BaseColor::*;
-use cursive::utils::markup::StyledString;
-use cursive::views::{LinearLayout, Panel, StackView, TextView, ViewBox};
-use cursive::direction::Orientation;
-use cursive::traits::*;
-
-use tui::{menu, mining, version};
-use tui::types::*;
-use tui::constants::*;
-
-use stats;
-
-use built_info;
-
-/// Main UI
-pub struct UI {
-	cursive: Cursive,
-	ui_rx: mpsc::Receiver<UIMessage>,
-	ui_tx: mpsc::Sender<UIMessage>,
-	controller_tx: mpsc::Sender<ControllerMessage>,
-}
-
-fn modify_theme(theme: &mut Theme) {
-	theme.shadow = false;
-	theme.borders = BorderStyle::Simple;
-	theme.palette[Background] = Dark(Black);
-	theme.palette[Shadow] = Dark(Black);
-	theme.palette[View] = Dark(Black);
-	theme.palette[Primary] = Dark(White);
-	theme.palette[Highlight] = Dark(Cyan);
-	theme.palette[HighlightInactive] = Dark(Blue);
-	// also secondary, tertiary, TitlePrimary, TitleSecondary
-}
-
-impl UI {
-	/// Create a new UI
-	pub fn new(controller_tx: mpsc::Sender<ControllerMessage>) -> UI {
-		let (ui_tx, ui_rx) = mpsc::channel::<UIMessage>();
-		let mut grin_ui = UI {
-			cursive: Cursive::default(),
-			ui_tx: ui_tx,
-			ui_rx: ui_rx,
-			controller_tx: controller_tx,
-		};
-
-		// Create UI objects, etc
-		let mining_view = mining::TUIMiningView::create();
-		let version_view = version::TUIVersionView::create();
-
-		let main_menu = menu::create();
-
-		let root_stack = StackView::new()
-			.layer(version_view)
-			.layer(mining_view)
-			.with_id(ROOT_STACK);
-
-		let mut title_string = StyledString::new();
-		title_string.append(StyledString::styled(
-			format!("Grin Miner Version {}", built_info::PKG_VERSION),
-			Color::Dark(BaseColor::Yellow),
-		));
-
-		let main_layer = LinearLayout::new(Orientation::Vertical)
-			.child(Panel::new(TextView::new(title_string)))
-			.child(
-				LinearLayout::new(Orientation::Horizontal)
-					.child(Panel::new(ViewBox::new(main_menu)))
-					.child(Panel::new(root_stack)),
-			);
-
-		//set theme
-		let mut theme = grin_ui.cursive.current_theme().clone();
-		modify_theme(&mut theme);
-		grin_ui.cursive.set_theme(theme);
-		grin_ui.cursive.add_layer(main_layer);
-
-		// Configure a callback (shutdown, for the first test)
-		let controller_tx_clone = grin_ui.controller_tx.clone();
-		grin_ui.cursive.add_global_callback('q', move |_| {
-			controller_tx_clone
-				.send(ControllerMessage::Shutdown)
-				.unwrap();
-		});
-		grin_ui.cursive.set_fps(4);
-		grin_ui
-	}
-
-	/// Step the UI by calling into Cursive's step function, then
-	/// processing any UI messages
-	pub fn step(&mut self) -> bool {
-		if !self.cursive.is_running() {
-			return false;
-		}
-
-		// Process any pending UI messages
-		while let Some(message) = self.ui_rx.try_iter().next() {
-			match message {
-				UIMessage::UpdateStatus(update) => {
-					mining::TUIMiningView::update(&mut self.cursive, update.clone());
-					version::TUIVersionView::update(&mut self.cursive, update.clone());
-				}
-			}
-		}
-
-		// Step the UI
-		self.cursive.step();
-		true
-	}
-
-	/// Stop the UI
-	pub fn stop(&mut self) {
-		self.cursive.quit();
-	}
-}
-
-/// Controller message
-
-pub struct Controller {
-	rx: mpsc::Receiver<ControllerMessage>,
-	ui: UI,
-}
-
-/// Controller Message
-pub enum ControllerMessage {
-	/// Shutdown
-	Shutdown,
-}
-
-impl Controller {
-	/// Create a new controller
-	pub fn new() -> Result<Controller, String> {
-		let (tx, rx) = mpsc::channel::<ControllerMessage>();
-		Ok(Controller {
-			rx: rx,
-			ui: UI::new(tx.clone()),
-		})
-	}
-	/// Run the controller
-	pub fn run(&mut self, stats: Arc<RwLock<stats::Stats>>) {
-		let stat_update_interval = 1;
-		let mut next_stat_update = time::get_time().sec + stat_update_interval;
-		while self.ui.step() {
-			while let Some(message) = self.rx.try_iter().next() {
-				match message {
-					ControllerMessage::Shutdown => {
-						self.ui.stop();
-						return;
-					}
-				}
-			}
-			if time::get_time().sec > next_stat_update {
-				self.ui.ui_tx.send(UIMessage::UpdateStatus(stats.clone())).unwrap();
-				next_stat_update = time::get_time().sec + stat_update_interval;
-			}
-			thread::sleep(std::time::Duration::from_millis(100));
-		}
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/tui/version.rs grin-miner-copy/src/bin/tui/version.rs
--- grin-miner-1.0.2/src/bin/tui/version.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/tui/version.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,49 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Version and build info
-
-use std::sync::{Arc, RwLock};
-
-use cursive::Cursive;
-use cursive::view::View;
-use cursive::views::{BoxView, LinearLayout, TextView};
-use cursive::direction::Orientation;
-use cursive::traits::*;
-
-use tui::constants::*;
-use tui::types::*;
-
-use stats::Stats;
-use info_strings;
-
-/// Version view
-pub struct TUIVersionView;
-
-impl TUIStatusListener for TUIVersionView {
-	/// Create basic status view
-	fn create() -> Box<View> {
-		let (basic_info, detailed_info, _) = info_strings();
-		let basic_status_view = BoxView::with_full_screen(
-			LinearLayout::new(Orientation::Vertical)
-				.child(TextView::new(basic_info))
-				.child(TextView::new(" "))
-				.child(TextView::new(detailed_info)),
-		);
-		Box::new(basic_status_view.with_id(VIEW_VERSION))
-	}
-
-	/// update
-	fn update(_c: &mut Cursive, _stats: Arc<RwLock<Stats>>) {}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/bin/types.rs grin-miner-copy/src/bin/types.rs
--- grin-miner-1.0.2/src/bin/types.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/bin/types.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,90 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use serde_json::Value;
-
-/// Types used for stratum
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct JobTemplate {
-	pub height: u64,
-	pub job_id: u64,
-	pub difficulty: u64,
-	pub pre_pow: String,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct RpcRequest {
-	pub id: String,
-	pub jsonrpc: String,
-	pub method: String,
-	pub params: Option<Value>,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct RpcResponse {
-	pub id: String,
-	pub method: String,
-	pub jsonrpc: String,
-	pub result: Option<Value>,
-	pub error: Option<RpcError>,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct RpcError {
-	pub code: i32,
-	pub message: String,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct LoginParams {
-	pub login: String,
-	pub pass: String,
-	pub agent: String,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct SubmitParams {
-	pub height: u64,
-	pub job_id: u64,
-	pub edge_bits: u32,
-	pub nonce: u64,
-	pub pow: Vec<u64>,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct WorkerStatus {
-        pub id: String,
-        pub height: u64,
-        pub difficulty: u64,
-        pub accepted: u64,
-        pub rejected: u64,
-        pub stale: u64,
-}
-
-/// Types used for internal communication from stratum client to miner
-#[derive(Serialize, Deserialize, Debug)]
-pub enum MinerMessage{
-	// Height, difficulty, pre_pow
-	ReceivedJob(u64, u64, u64, String),
-	StopJob,
-	Shutdown,
-}
-
-#[derive(Serialize, Deserialize, Debug)]
-pub enum ClientMessage{
-	// height, job_id, edge_bits, nonce, pow
-	FoundSolution(u64, u64, u32, u64, Vec<u64>),
-	Shutdown,
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/src/build/build.rs grin-miner-copy/src/build/build.rs
--- grin-miner-1.0.2/src/build/build.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/src/build/build.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Build hooks to spit out version+build time info
-
-extern crate built;
-use std::env;
-
-fn main() {
-	let mut opts = built::Options::default();
-	opts.set_dependencies(true);
-	built::write_built_file_with_opts(
-		&opts,
-		env!("CARGO_MANIFEST_DIR"),
-		format!("{}{}", env::var("OUT_DIR").unwrap(), "/built.rs"),
-	)
-	.expect("Failed to acquire build-time information");
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/.travis/install.sh grin-miner-copy/.travis/install.sh
--- grin-miner-1.0.2/.travis/install.sh	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/.travis/install.sh	1969-12-31 19:00:00.000000000 -0500
@@ -1,9 +0,0 @@
-#!/bin/bash
-
-if [[ $TRAVIS_OS_NAME == 'linux' ]]; then
-    wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_10.0.130-1_amd64.deb
-    sudo dpkg -i cuda-repo-ubuntu1604_10.0.130-1_amd64.deb
-    sudo apt-key adv --fetch-keys http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub
-    sudo apt-get update
-    sudo apt-get install cuda
-fi
diff -urN '--exclude=.git' grin-miner-1.0.2/.travis.yml grin-miner-copy/.travis.yml
--- grin-miner-1.0.2/.travis.yml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/.travis.yml	1969-12-31 19:00:00.000000000 -0500
@@ -1,96 +0,0 @@
-language: rust
-
-git:
-  depth: false
-
-dist: xenial
-sudo: required
-
-cache:
-  cargo: true
-  timeout: 240
-  directories:
-    - $HOME/.cargo
-    - $TRAVIS_BUILD_DIR/target
-
-before_cache:
-  - rm -rf $TRAVIS_BUILD_DIR/target/tmp
-
-rust:
-  - stable
-
-addons:
-  apt:
-    sources:
-      - ubuntu-toolchain-r-test
-    packages:
-      - g++-5
-      - cmake
-      - libcurl4-openssl-dev
-      - libelf-dev
-      - libdw-dev
-      - cmake
-      - gcc
-      - binutils-dev
-      - ocl-icd-opencl-dev
-      - wget
-
-env:
-  global:
-    - RUST_BACKTRACE="1"
-    - RUST_FLAGS="-C debug-assertions"
-
-matrix:
-  include:
-    - os: linux
-      env: TEST_SUITE=cuckoo-miner
-    - os: linux
-      env: TEST_SUITE=release
-    - os: osx
-      env: TEST_SUITE=release
-
-# install CUDA 10 on ubuntu 16.04 via DEB from directions here 
-# https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=debnetwork
-install:
-  - ./.travis/install.sh
-  
-script:
-  - IFS=',' read -r -a DIRS <<< "$TEST_SUITE"; DIR=${DIRS[0]};
-    echo "start testing on folder $DIR...";
-    if [[ -n "$DIR" ]] && [[ "$TRAVIS_OS_NAME" == "linux" ]] && [[ "$DIR" != "release" ]];  then cd $DIR && cargo test --release && cd - > /dev/null; fi;
-  - IFS=',' read -r -a DIRS <<< "$TEST_SUITE"; DIR=${DIRS[1]};
-    if [[ -n "$DIR" ]];  then
-      echo "start testing on folder $DIR...";
-      cd $DIR && cargo test --release && cd - > /dev/null;
-    fi;
-  - IFS=',' read -r -a DIRS <<< "$TEST_SUITE"; DIR=${DIRS[2]};
-    if [[ -n "$DIR" ]];  then
-      echo "start testing on folder $DIR...";
-      cd $DIR && cargo test --release && cd - > /dev/null;
-    fi;
-
-# NB, we won't be able to build cuckatoo 31 + CUDA plugins until travis supports
-# ubuntu bionic beaver (18.04), which contains CUDA 10
-# For now, we need to use xenial (16.04) which uses CUDA 7.5, sufficient to build
-# cuckaroo29 using sm_35 architecture
-
-before_deploy:
-  - if [[ "$TEST_SUITE" == "release" ]] && [[ "$TRAVIS_OS_NAME" == "linux" ]]; then
-      sed -i.bak 's/cuckoo_miner =/#cuckoo_miner =/g; s/##cuckoo_miner/cuckoo_miner/g' Cargo.toml;
-      cargo clean; cargo build --release --features opencl && ./.auto-release.sh;
-    fi
-  - if [[ "$TEST_SUITE" == "release" ]] && [[ "$TRAVIS_OS_NAME" == "osx" ]]; then
-      brew update;
-      cargo clean; cargo build --release; ./.auto-release.sh;
-    fi
-
-deploy:
-  provider: releases
-  api-key:
-    secure: hyoP1dOINIFF4LoVF3zh52tLg3GmKzj1urFU4o91dhB4XZazOqI5vqlMWUzmT+/fAxT+3Vf7L4Lh41BGqIGjKPOB/UQvo3PimGv2Aaz13faEyAR4HSI/NNZIx6NvAnYALy9f9pzo7D0xbfaXlIEdv4p0/KeE2RkOyRrP/twmlaLMWGKGmkHb8+TJUuDitE4A1WcnDFS9krNyNcYJeFgJJvqkw5EnPKZQrRey3LBMxQh/1PxeWgvJQBJpSFVeE+Hys5LFTcjEcnVTubjagYICw0Hslu1WYQVpP2ruolEodWOOcWU/lnKZ9X9dydZJuu1VRi/eteA73qntiRwSXz0gJlnq4MLuQl8aaDc5JZ1zvFk8jIflc44CX0fKaLakH0HlXdPBSFs9cFM4rw+5DHWc3QinrfV10EXxekybRPcwOQ2yVQObNIq+TBGoXENyY6HXNb9p4yhSdxygG72k9Nrxx79t8AFKjpbEhYgSvcFqPKv+5Y9n1fLNM1RiaKoPcUBVdkyaIDvck6ja2tu02UVTYdeIXQ53dewWEr8dGZiQMGtE23/+YppfZavxBjSiZ6QTnm1UdVjqkRIPohYbsBh9vydAtr6Ufx4GvBf6r3U2LkuaL2s/NbJsEO9JTeSjOH3zTOJdR90+lTSKUKXYAGC5i3qvRfVWFefjxqWv0nyLTrs=
-  file_glob: true
-  file: deploy/grin-miner-*.tgz*
-  skip_cleanup: true
-  on:
-    repo: mimblewimble/grin-miner
-    tags: true
diff -urN '--exclude=.git' grin-miner-1.0.2/util/Cargo.toml grin-miner-copy/util/Cargo.toml
--- grin-miner-1.0.2/util/Cargo.toml	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/util/Cargo.toml	1969-12-31 19:00:00.000000000 -0500
@@ -1,19 +0,0 @@
-[package]
-name = "grin_miner_util"
-version = "1.0.2"
-authors = ["Grin Developers <mimblewimble@lists.launchpad.net>"]
-description = "Utilities for the grin miner"
-repository = "https://github.com/mimblewimble/grin-miner"
-license = "Apache-2.0"
-workspace = ".."
-
-[dependencies]
-backtrace = "0.3"
-byteorder = "1"
-lazy_static = "0.2"
-rand = "0.3"
-serde = "1"
-serde_derive = "1"
-slog = { version = "~2.1", features = ["max_level_trace", "release_max_level_trace"] }
-slog-term = "2.1"
-slog-async = "2.1"
diff -urN '--exclude=.git' grin-miner-1.0.2/util/src/hex.rs grin-miner-copy/util/src/hex.rs
--- grin-miner-1.0.2/util/src/hex.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/util/src/hex.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,74 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-/// Implements hex-encoding from bytes to string and decoding of strings
-/// to bytes. Given that rustc-serialize is deprecated and serde doesn't
-/// provide easy hex encoding, hex is a bit in limbo right now in Rust-
-/// land. It's simple enough that we can just have our own.
-
-use std::fmt::Write;
-use std::num;
-
-/// Encode the provided bytes into a hex string
-pub fn to_hex(bytes: Vec<u8>) -> String {
-	let mut s = String::new();
-	for byte in bytes {
-		write!(&mut s, "{:02x}", byte).expect("Unable to write");
-	}
-	s
-}
-
-/// Decode a hex string into bytes.
-pub fn from_hex(hex_str: String) -> Result<Vec<u8>, num::ParseIntError> {
-	let hex_trim = if &hex_str[..2] == "0x" {
-		hex_str[2..].to_owned()
-	} else {
-		hex_str.clone()
-	};
-	split_n(&hex_trim.trim()[..], 2)
-		.iter()
-		.map(|b| u8::from_str_radix(b, 16))
-		.collect::<Result<Vec<u8>, _>>()
-}
-
-fn split_n(s: &str, n: usize) -> Vec<&str> {
-	(0..(s.len() - n + 1) / 2 + 1)
-		.map(|i| &s[2 * i..2 * i + n])
-		.collect()
-}
-
-#[cfg(test)]
-mod test {
-	use super::*;
-
-	#[test]
-	fn test_to_hex() {
-		assert_eq!(to_hex(vec![0, 0, 0, 0]), "00000000");
-		assert_eq!(to_hex(vec![10, 11, 12, 13]), "0a0b0c0d");
-		assert_eq!(to_hex(vec![0, 0, 0, 255]), "000000ff");
-	}
-
-	#[test]
-	fn test_from_hex() {
-		assert_eq!(from_hex("00000000".to_string()).unwrap(), vec![0, 0, 0, 0]);
-		assert_eq!(
-			from_hex("0a0b0c0d".to_string()).unwrap(),
-			vec![10, 11, 12, 13]
-		);
-		assert_eq!(
-			from_hex("000000ff".to_string()).unwrap(),
-			vec![0, 0, 0, 255]
-		);
-	}
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/util/src/lib.rs grin-miner-copy/util/src/lib.rs
--- grin-miner-1.0.2/util/src/lib.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/util/src/lib.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,51 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Logging, as well as various low-level utilities that factor Rust
-//! patterns that are frequent within the grin codebase.
-
-#![deny(non_upper_case_globals)]
-#![deny(non_camel_case_types)]
-#![deny(non_snake_case)]
-#![deny(unused_mut)]
-#![warn(missing_docs)]
-
-extern crate backtrace;
-extern crate byteorder;
-extern crate rand;
-#[macro_use]
-extern crate slog;
-extern crate slog_async;
-extern crate slog_term;
-
-#[macro_use]
-extern crate lazy_static;
-
-extern crate serde;
-#[macro_use]
-extern crate serde_derive;
-
-// Logging related
-pub mod logger;
-pub use logger::{init_logger, init_test_logger, LOGGER};
-
-pub mod types;
-pub use types::{LogLevel, LoggingConfig};
-
-// other utils
-#[allow(unused_imports)]
-use std::ops::Deref;
-
-mod hex;
-pub use hex::*;
diff -urN '--exclude=.git' grin-miner-1.0.2/util/src/logger.rs grin-miner-copy/util/src/logger.rs
--- grin-miner-1.0.2/util/src/logger.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/util/src/logger.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,159 +0,0 @@
-// Copyright 2018 The Grin Developers
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Logging wrapper to be used throughout all crates in the workspace
-use std::fs::OpenOptions;
-use std::sync::Mutex;
-use std::ops::Deref;
-use slog::{Discard, Drain, Duplicate, Level, LevelFilter, Logger};
-use slog_term;
-use slog_async;
-
-use backtrace::Backtrace;
-use std::{panic, thread};
-
-use types::{LogLevel, LoggingConfig};
-
-fn convert_log_level(in_level: &LogLevel) -> Level {
-	match *in_level {
-		LogLevel::Info => Level::Info,
-		LogLevel::Critical => Level::Critical,
-		LogLevel::Warning => Level::Warning,
-		LogLevel::Debug => Level::Debug,
-		LogLevel::Trace => Level::Trace,
-		LogLevel::Error => Level::Error,
-	}
-}
-
-lazy_static! {
-	/// Flag to observe whether logging was explicitly initialised (don't output otherwise)
-	static ref WAS_INIT: Mutex<bool> = Mutex::new(false);
-	/// Flag to observe whether tui is running, and we therefore don't want to attempt to write
-	/// panics to stdout
-	static ref TUI_RUNNING: Mutex<bool> = Mutex::new(false);
-	/// Static Logging configuration, should only be set once, before first logging call
-	static ref LOGGING_CONFIG: Mutex<LoggingConfig> = Mutex::new(LoggingConfig::default());
-
-	/// And a static reference to the logger itself, accessible from all crates
-	pub static ref LOGGER: Logger = {
-		let was_init = WAS_INIT.lock().unwrap().clone();
-		let config = LOGGING_CONFIG.lock().unwrap();
-		let slog_level_stdout = convert_log_level(&config.stdout_log_level);
-		let slog_level_file = convert_log_level(&config.file_log_level);
-		if config.tui_running.is_some() && config.tui_running.unwrap() {
-			let mut tui_running_ref = TUI_RUNNING.lock().unwrap();
-			*tui_running_ref = true;
-		}
-
-		//Terminal output drain
-		let terminal_decorator = slog_term::TermDecorator::new().build();
-		let terminal_drain = slog_term::FullFormat::new(terminal_decorator).build().fuse();
-		let terminal_drain = LevelFilter::new(terminal_drain, slog_level_stdout).fuse();
-		let mut terminal_drain = slog_async::Async::new(terminal_drain).build().fuse();
-		if !config.log_to_stdout || !was_init {
-			terminal_drain = slog_async::Async::new(Discard{}).build().fuse();
-		}
-
-		//File drain
-		let mut file_drain_final = slog_async::Async::new(Discard{}).build().fuse();
-		if config.log_to_file && was_init {
-			let file = OpenOptions::new()
-				.create(true)
-				.write(true)
-				.append(config.log_file_append)
-				.truncate(false)
-				.open(&config.log_file_path)
-				.unwrap();
-
-			let file_decorator = slog_term::PlainDecorator::new(file);
-			let file_drain = slog_term::FullFormat::new(file_decorator).build().fuse();
-			let file_drain = LevelFilter::new(file_drain, slog_level_file).fuse();
-			file_drain_final = slog_async::Async::new(file_drain).build().fuse();
-		}
-
-		//Compose file and terminal drains
-		let composite_drain = Duplicate::new(terminal_drain, file_drain_final).fuse();
-
-		let log = Logger::root(composite_drain, o!());
-		log
-	};
-}
-
-/// Initialises the logger with the given configuration
-pub fn init_logger(config: Option<LoggingConfig>) {
-	if let Some(c) = config {
-		let mut config_ref = LOGGING_CONFIG.lock().unwrap();
-		*config_ref = c.clone();
-		// Logger configuration successfully injected into LOGGING_CONFIG...
-		let mut was_init_ref = WAS_INIT.lock().unwrap();
-		*was_init_ref = true;
-		// .. allow logging, having ensured that paths etc are immutable
-	}
-	send_panic_to_log();
-}
-
-/// Initializes the logger for unit and integration tests
-pub fn init_test_logger() {
-	let mut was_init_ref = WAS_INIT.lock().unwrap();
-	if *was_init_ref.deref() {
-		return;
-	}
-	let mut config_ref = LOGGING_CONFIG.lock().unwrap();
-	*config_ref = LoggingConfig::default();
-	*was_init_ref = true;
-	send_panic_to_log();
-}
-
-/// hook to send panics to logs as well as stderr
-fn send_panic_to_log() {
-	panic::set_hook(Box::new(|info| {
-		let backtrace = Backtrace::new();
-
-		let thread = thread::current();
-		let thread = thread.name().unwrap_or("unnamed");
-
-		let msg = match info.payload().downcast_ref::<&'static str>() {
-			Some(s) => *s,
-			None => match info.payload().downcast_ref::<String>() {
-				Some(s) => &**s,
-				None => "Box<Any>",
-			},
-		};
-
-		match info.location() {
-			Some(location) => {
-				error!(
-					LOGGER,
-					"\nthread '{}' panicked at '{}': {}:{}{:?}\n\n",
-					thread,
-					msg,
-					location.file(),
-					location.line(),
-					backtrace
-				);
-			}
-			None => error!(
-				LOGGER,
-				"thread '{}' panicked at '{}'{:?}", thread, msg, backtrace
-			),
-		}
-		//also print to stderr
-		let tui_running = TUI_RUNNING.lock().unwrap().clone();
-		if !tui_running {
-			eprintln!(
-				"Thread '{}' panicked with message:\n\"{}\"\nSee grin.log for further details.",
-				thread, msg
-			);
-		}
-	}));
-}
diff -urN '--exclude=.git' grin-miner-1.0.2/util/src/types.rs grin-miner-copy/util/src/types.rs
--- grin-miner-1.0.2/util/src/types.rs	2019-01-17 04:23:39.000000000 -0500
+++ grin-miner-copy/util/src/types.rs	1969-12-31 19:00:00.000000000 -0500
@@ -1,65 +0,0 @@
-// Copyright 2018 The Grin Developers
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Logging configuration types
-
-/// Log level types, as slog's don't implement serialize
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub enum LogLevel {
-	/// Critical
-	Critical,
-	/// Error
-	Error,
-	/// Warning
-	Warning,
-	/// Info
-	Info,
-	/// Debug
-	Debug,
-	/// Trace
-	Trace,
-}
-
-/// Logging config
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct LoggingConfig {
-	/// whether to log to stdout
-	pub log_to_stdout: bool,
-	/// logging level for stdout
-	pub stdout_log_level: LogLevel,
-	/// whether to log to file
-	pub log_to_file: bool,
-	/// log file level
-	pub file_log_level: LogLevel,
-	/// Log file path
-	pub log_file_path: String,
-	/// Whether to append to log or replace
-	pub log_file_append: bool,
-	/// Whether the tui is running (optional)
-	pub tui_running: Option<bool>,
-}
-
-impl Default for LoggingConfig {
-	fn default() -> LoggingConfig {
-		LoggingConfig {
-			log_to_stdout: true,
-			stdout_log_level: LogLevel::Debug,
-			log_to_file: false,
-			file_log_level: LogLevel::Trace,
-			log_file_path: String::from("grin.log"),
-			log_file_append: false,
-			tui_running: None,
-		}
-	}
-}
